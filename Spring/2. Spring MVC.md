# 1) Kiến trúc Spring MVC (Front Controller & các thành phần)

1. Mô tả mô hình **Front Controller** của Spring MVC. `DispatcherServlet` đứng ở đâu trong kiến trúc?
2. Phân biệt vai trò: `DispatcherServlet`, `HandlerMapping`, `HandlerAdapter`, `Controller`, `ViewResolver`, `View`, `Model`, `ModelAndView`, `HttpMessageConverter`.
3. ⚠️ Gài: Khi nào Spring gọi **HandlerMapping** trước **HandlerAdapter**? Nếu có nhiều HandlerMapping, Spring ưu tiên thế nào?
4. `Model` khác gì `ModelMap` và `ModelAndView`? Khi nào chọn mỗi loại?
5. Cơ chế **Content Negotiation** hoạt động ra sao (header `Accept`, extension, query param)?
6. Liên hệ Spring MVC với **Template Engines** (Thymeleaf, JSP): `ViewResolver` cấu hình thế nào, `prefix`/`suffix` ảnh hưởng gì?
7. ⚠️ Gài: Vì sao đôi khi view không render dù controller trả về tên view hợp lệ? Kể ít nhất 3 nguyên nhân có thể.
8. Phân biệt **Filter**, **Interceptor**, **AOP** về vị trí trong pipeline và use case điển hình.
9. `ControllerAdvice`/`RestControllerAdvice` nằm ở tầng nào trong pipeline? Tác động tới binding/exception ra sao?
10. Khi nào nên tách **DTO** ra khỏi **Entity** ở tầng MVC? Hệ quả nếu bind trực tiếp Entity lên form/JSON?

# 2) Luồng xử lý request end-to-end

1. Mô tả chi tiết luồng: HTTP request → `DispatcherServlet` → chọn handler → gọi controller method → xử lý service/repo → trả `ModelAndView`/`ResponseEntity` → resolve view/serialize → HTTP response.
2. Spring chọn **controller method** dựa trên những tiêu chí nào (URL, HTTP method, params, headers, consumes/produces)?
3. ⚠️ Gài: Hai method mapping “na ná” nhau—Spring ném lỗi gì, và cách disambiguate (cụ thể tiêu chí ưu tiên)?
4. Giải thích các **HandlerMethodArgumentResolver** phổ biến (bind `@PathVariable`, `@RequestParam`, `@RequestBody`, `@RequestHeader`, `@CookieValue`, `Principal`, `Pageable` …).
5. **HandlerMethodReturnValueHandler** xử lý những kiểu trả về nào (`String`, `ModelAndView`, `ResponseEntity`, object với `@ResponseBody`, `void`)?
6. Trình tự chạy của **Interceptor** (`preHandle`/`postHandle`/`afterCompletion`) trong lifecycle một request.
7. ⚠️ Gài: Sự khác nhau về phạm vi xử lý lỗi giữa `@ExceptionHandler`, `ControllerAdvice`, và `HandlerExceptionResolver`.
8. Cơ chế **HttpMessageConverter**: Khi nào được dùng? Cách chọn converter cho JSON/XML/Form.
9. Ảnh hưởng của **async** (`Callable`, `DeferredResult`, `SseEmitter`) tới luồng xử lý và timeouts.
10. CORS kiểm soát ở đâu trong luồng (Filter vs `@CrossOrigin`)? Ưu/nhược mỗi cách?

# 3) Vai trò của Controller, Model, ViewResolver

1. `@Controller` chịu trách nhiệm gì? Khi nào trả tên view vs trả dữ liệu JSON?
2. `Model` dùng để làm gì? Dữ liệu trong `Model` đi tới view như thế nào?
3. ⚠️ Gài: `RedirectAttributes` khác `Model` gì trong pattern **PRG** (Post/Redirect/Get)? Khi nào dùng **flash attributes**?
4. `ViewResolver` là gì, có những loại phổ biến nào? Thứ tự `order` của nhiều ViewResolver ảnh hưởng thế nào?
5. Khi render Thymeleaf, lấy biến từ `Model` ở view; kể 3 lỗi binding thường gặp và cách nhận diện.
6. `@SessionAttributes` làm gì? Rủi ro khi quên xóa dữ liệu session-bound?
7. ⚠️ Gài: Khi controller trả `String` tên view nhưng **cũng có** `@ResponseBody` trên method thì chuyện gì xảy ra?

# 4) Xử lý request & response (HTTP, status, headers)

1. Chuẩn REST: phân biệt **GET/POST/PUT/PATCH/DELETE** về tính **safe**/**idempotent**. Hệ quả khi dùng sai.
2. Khi nào nên dùng `ResponseEntity` thay vì trả object thuần + `@ResponseBody`? Cách set status, headers, cookies.
3. ⚠️ Gài: Trả về **201 Created** cần kèm header nào? Cách set `Location` chuẩn.
4. Set **cache headers** (ETag, `Cache-Control`, `Last-Modified`) trong Spring MVC thế nào?
5. Mapping và validate **file upload** (multipart) cần cấu hình gì (`MultipartResolver`, giới hạn kích thước, lưu tạm)?
6. **Pagination & Sorting**: nhận `Pageable` từ request như thế nào? Tránh lộ thông tin nội bộ khi trả `Page<T>`.
7. CORS: `@CrossOrigin` trên method/class vs cấu hình global khác gì?
8. ⚠️ Gài: Sự cố **JSON infinite recursion** (quan hệ vòng JPA) — dấu hiệu, nguyên nhân, hướng xử lý ở tầng MVC.

# 5) Mapping & annotations thường dùng

1. Phân biệt `@RequestMapping` (class/method-level) với `@GetMapping`, `@PostMapping`… Ưu/nhược trong tổ chức route.
2. `@PathVariable` — ép kiểu, optional, multi-variables, regex trong path; xử lý khi thiếu biến path.
3. `@RequestParam` — required vs defaultValue, multiple values (List/array), Map params.
4. `@RequestBody` vs `@ModelAttribute`: khác biệt binding; khi nào form-encoded nên dùng cái nào?
5. ⚠️ Gài: Đặt **cả** `@RequestBody` **và** `@RequestParam` cho cùng dữ liệu—Spring xử lý ra sao?
6. `@ResponseBody` ở method vs `@RestController` ở class: hành vi có gì khác?
7. `consumes`/`produces` trong mapping: cách Spring match theo **Content-Type**/**Accept**.
8. `@RequestHeader`, `@CookieValue`, `@RequestAttribute`: use case điển hình.
9. `@InitBinder` dùng để làm gì? Ảnh hưởng tới conversion/formatting ở level method/controller.
10. ⚠️ Gài: **Matrix variables** là gì? Khi nào hoạt động/không hoạt động với `UrlPathHelper`/`PathPatternParser`?
11. Versioning API qua **header**/**param**/**path** — mapping định nghĩa thế nào, trade-off từng cách.
12. Kiểm soát trailing slash và case-sensitivity trong path matching như thế nào?

# 6) @Controller vs @RestController

1. Khác nhau về **mặc định** `@ResponseBody`: vì sao `@RestController` tiện cho API JSON?
2. Dùng `@Controller` nhưng muốn trả JSON cho một vài method—cách nào sạch nhất?
3. ⚠️ Gài: Khi kết hợp `@Controller` + `@ResponseBody` + trả `String` — phân biệt trả **raw body** vs tên view.
4. Khi nào nên **không** dùng `@RestController` cho API? (VD: content negotiation phức tạp, hoặc cần render view).
5. Tác động tới **Exception Handling**: `@ControllerAdvice` vs `@RestControllerAdvice` trả lỗi theo chuẩn JSON khác gì?

# 7) Binding & Validation (@Valid, BindingResult, …)

1. Luồng **data binding** từ request → object: conversion service, formatters, property editors hoạt động thế nào?
2. `@Valid` vs `@Validated`: khác biệt, **validation groups**, cách áp dụng cho create/update.
3. ⚠️ Gài: `BindingResult` phải đứng ở đâu trong chữ ký method? Nếu thiếu thì chuyện gì xảy ra khi validation fail?
4. Validate **nested object** và **list**: yêu cầu chú thích gì trên field?
5. Tùy biến thông điệp lỗi i18n qua `MessageSource` (`messages.properties`): cơ chế key resolution.
6. Viết **custom constraint** (annotation + validator) như thế nào? Case: unique email.
7. Validate **path variable**, **request param** (không có body) — dùng cơ chế gì?
8. ⚠️ Gài: Validate **partial update** (PATCH) — tránh bắt buộc field khi không gửi; các chiến lược khả thi.
9. Định dạng ngày/giờ trong binding: `@DateTimeFormat` vs `@JsonFormat` — phạm vi tác dụng khác nhau như thế nào?
10. Bind **enum** từ request (string/int): conversion & lỗi thường gặp.
11. Thiết kế **error response** thống nhất cho toàn API khi validation fail: cần chứa những trường nào?
12. Tránh **over-posting**/**mass assignment**: kỹ thuật và vị trí phòng vệ (DTO, whitelist fields, binder, service).

# 8) Xử lý lỗi & tư vấn toàn cục (Exception Handling)

1. `@ExceptionHandler` ở controller vs `@ControllerAdvice`/`@RestControllerAdvice` toàn cục: phạm vi, ưu tiên.
2. ⚠️ Gài: Khi có **nhiều** handler bắt cùng exception, Spring chọn cái nào? `@Order` hoạt động ra sao?
3. `ResponseStatusException` vs `@ResponseStatus` vs trả `ResponseEntity` — chọn cái nào cho tính rõ ràng & testability?
4. Chuẩn lỗi REST: map lỗi chuẩn Spring (ví dụ `MethodArgumentNotValidException`) sang JSON domain-specific như thế nào?
5. Log lỗi ở đâu để không trùng lặp (controller, advice, filter)? Mức log nào phù hợp (INFO/WARN/ERROR)?

# 9) Bảo mật & các chủ đề cận kề MVC (nhẹ)

1. Ảnh hưởng của **CSRF** tới form POST trong MVC truyền thống; cách bật/tắt hợp lý khi chỉ có REST API.
2. Thêm **rate limit**/**throttling** ở tầng MVC (interceptor/filter) — câu hỏi thiết kế.
3. ⚠️ Gài: Truyền trực tiếp entity JPA qua JSON có nguy cơ gì (lazy loading, N+1, dữ liệu nhạy cảm)?

# 10) Mini case thực chiến (luyện nói 2–5 phút mỗi case)

1. Thiết kế endpoint **tạo user** (POST) với validation groups (Create vs Update). Trả 201 + Location. Trình bày mapping & error format.
2. API **search** với `@RequestParam` nhiều tiêu chí + phân trang `Pageable`. Cách validate tham số & trả metadata trang.
3. Form upload nhiều tệp: cấu hình multipart, giới hạn size, trả progress, xử lý lỗi thiếu dung lượng đĩa.
4. Chuẩn hóa **error handling**: trình bày `@RestControllerAdvice` gom lỗi validation & business, kèm mã lỗi nội bộ.
5. Sự cố JSON recursion khi trả entity có quan hệ hai chiều: mô tả triệu chứng và 2–3 hướng xử lý ở tầng MVC.
