# 1) Authentication vs Authorization – khái niệm & dòng chảy

1. Phân biệt **authentication** và **authorization** bằng ví dụ cụ thể trong web app.
2. `Principal`, `Authentication`, `GrantedAuthority` là gì và liên hệ giữa chúng?
3. **Role** vs **Authority** khác nhau ra sao? Ý nghĩa tiền tố `ROLE_` và các hàm `hasRole()`/`hasAuthority()`?
4. Security Context: `SecurityContext`/`SecurityContextHolder` lưu cái gì? Vòng đời theo request/thread?
5. ⚠️ Gài: Vì sao `SecurityContext` có thể “mất” khi dùng `@Async` hoặc thread pool? Cách khắc phục?
6. Authentication flow: từ `UsernamePasswordAuthenticationFilter` → `AuthenticationManager` → `AuthenticationProvider` → `UserDetailsService` → `PasswordEncoder`. Trình bày thứ tự.
7. Khác nhau giữa `AuthenticationManager` và `AuthenticationProvider`. Vì sao có thể có **nhiều** provider?
8. Cơ chế **anonymous authentication** hoạt động thế nào? Khi nào hữu ích/không nên bật?
9. **Method Security** (`@PreAuthorize`, `@PostAuthorize`) vs Web security (URL/HTTP) khác nhau ở đâu và khi nào dùng cái nào?

# 2) Cấu hình bảo mật cơ bản & filter chain

1. Mặc định Spring Security làm gì khi bạn **chưa cấu hình gì**? (trang login, deny-all, CSRF…)
2. Cấu trúc **SecurityFilterChain** là gì? Vì sao cần bean `SecurityFilterChain` trong config hiện đại (Spring Security 6)?
3. `authorizeHttpRequests()` dùng để định nghĩa gì? So sánh `permitAll()` vs `authenticated()` vs matcher cụ thể.
4. ⚠️ Gài: Đặt `permitAll()` cho `/login` nhưng vẫn bị 403 — liệt kê 2–3 nguyên nhân điển hình.
5. CSRF: tại sao bật mặc định? Khi nào nên tắt (API stateless)? Ảnh hưởng với POST form truyền thống?
6. CORS vs CSRF khác nhau gì? Chặn tình huống nào?
7. Session management cơ bản: stateless vs stateful; `SessionCreationPolicy` các giá trị thường dùng.
8. Exception handling: `authenticationEntryPoint` vs `accessDeniedHandler` dùng khi nào?

# 3) In-Memory Authentication

1. In-memory auth: tạo user bằng `InMemoryUserDetailsManager` như thế nào?
2. ⚠️ Gài: Vì sao thêm user `{noop}password` chạy được, nhưng bỏ `{noop}` thì lỗi? Ý nghĩa **id** trong `DelegatingPasswordEncoder`.
3. Phân biệt `withUsername().password().roles()` vs `authorities()`; mapping role → authority.
4. Tổ chức **nhiều** user với nhiều role trong in-memory sao cho dễ đọc/bảo trì?
5. Hạn chế của in-memory auth trong thực tế (triển khai, thay đổi mật khẩu, phân quyền động…).
6. Cách test nhanh in-memory auth với `@WithMockUser` và `SecurityMockMvcRequestPostProcessors`.

# 4) JDBC Authentication (dựa trên DB)

1. JDBC authentication khác gì so với `UserDetailsService` tự viết? Khi nào chọn JDBC auth?
2. **Default schema** Spring Security (bảng `users`, `authorities`) gồm cột gì? Có bắt buộc dùng schema mặc định không?
3. ⚠️ Gài: DB đang có bảng user khác tên/cột — cấu hình `usersByUsernameQuery`/`authoritiesByUsernameQuery` như thế nào để map đúng?
4. Quản lý **DataSource**: lấy từ đâu (Hikari, Spring Boot auto-config)? Cần quyền DB gì?
5. Mật khẩu trong DB phải được **mã hoá** như thế nào để `PasswordEncoder` match được?
6. Xử lý tài khoản **disabled/locked/expired** với JDBC auth: trường/bool nào cần trong DB?
7. Chiến lược **phân trang/tra cứu** quyền khi user có nhiều role/authority (index cần thiết).

# 5) UserDetailsService – hợp đồng & tuỳ biến

1. Hợp đồng của `UserDetailsService#loadUserByUsername`: trả về gì, ném exception gì khi không tìm thấy user?
2. ⚠️ Gài: Vì sao nên **ẩn** thông tin “user không tồn tại” khi login fail? Ảnh hưởng bảo mật?
3. `UserDetails` gồm những thuộc tính nào quan trọng (enabled, accountNonExpired…). Tương ứng cột DB nào?
4. So sánh `InMemoryUserDetailsManager`, `JdbcUserDetailsManager`, `UserDetailsService` tự viết (JPA).
5. Mapping từ **domain User** (JPA entity) sang `UserDetails`: nơi đặt logic & trách nhiệm của mỗi lớp?
6. Tích hợp `UserDetailsService` với caching (ví dụ cache quyền) có rủi ro gì khi đổi role động?
7. `AuthenticationProvider` tuỳ biến có thể **bỏ qua** `UserDetailsService` không? Tình huống nào cần (ví dụ, LDAP, SSO)?

# 6) PasswordEncoder – mã hoá mật khẩu an toàn

1. Tại sao **không** được lưu plain text? Khác biệt giữa hash một chiều vs mã hoá hai chiều.
2. `PasswordEncoder` phổ biến: `BCrypt`, `PBKDF2`, `scrypt`, `Argon2`. Chọn cái nào cho web app thông thường?
3. `DelegatingPasswordEncoder` và cú pháp `{id}hash` hoạt động ra sao? Lợi ích khi **migrate** thuật toán.
4. ⚠️ Gài: App đang dùng `{noop}` trong dev, đẩy lên prod quên đổi — chỉ ra rủi ro và biện pháp **fail-fast**.
5. Thiết lập **strength/cost** cho BCrypt: tiêu chí chọn (hiệu năng vs an toàn), cách benchmark.
6. Nâng cấp mật khẩu “nhẹ nhàng”: chiến lược **on-login rehash** là gì?
7. Kiểm tra trùng mật khẩu cũ mới (password reuse) nên làm ở đâu (service/validator)?
8. Lưu hash kèm salt như thế nào với BCrypt (salt embedded)? Có cần cột salt riêng?
9. ⚠️ Gài: Vì sao `passwordEncoder.matches(raw, encoded)` luôn false? Liệt kê 2–3 nguyên nhân (id sai, double-encode, trim…).

# 7) Authorization cơ bản (URL & Method)

1. `authorizeHttpRequests()` với các matcher: thứ tự kiểm tra quan trọng thế nào?
2. Khác nhau `hasRole("ADMIN")` vs `hasAuthority("ROLE_ADMIN")` trong URL authorization.
3. Method security (`@EnableMethodSecurity`) bật thế nào? `@PreAuthorize("hasRole('ADMIN')")` hoạt động khi nào?
4. ⚠️ Gài: Vì sao method security **không chạy** khi gọi method **trong cùng class**?
5. Thiết kế ma trận quyền **ROLE vs PERMISSION**: khi nào chỉ dùng role là đủ, khi nào cần authority chi tiết?

# 8) Mini case (thực chiến 2–5 phút mỗi câu)

1. Thiết kế đăng nhập form đơn giản: in-memory cho dev, JDBC cho staging/prod. Mô tả cấu hình chuyển **profile** và `PasswordEncoder`.
2. DB hiện tại lưu MD5 không salt. Trình bày kế hoạch migration sang BCrypt mà **không bắt** toàn bộ user đổi mật khẩu ngay.
3. API REST stateless: tắt session, bật CORS, tắt CSRF — chỉ rõ các bước cấu hình và nguy cơ nếu tắt sai.
4. Viết `UserDetailsService` dựa JPA: mapping entity → `UserDetails`, xử lý user disabled/locked, và nơi đặt `@Transactional`.
5. Tổ chức phân quyền: `/admin/**` chỉ ADMIN, `/user/**` cho USER & ADMIN, `/public/**` mở. Trình bày rule theo **thứ tự đúng** tránh bị “lọt”.
6. Sự cố: nhập đúng user/pass nhưng luôn 403. Liệt kê checklist chẩn đoán (role prefix, matcher, method security, CSRF…).
7. Tạo 2 user in-memory: `user/USER`, `admin/ADMIN`. Chỉ ra khác biệt khi dùng `roles("ADMIN")` vs `authorities("ROLE_ADMIN")` trong cấu hình.
8. Thiết lập chính sách **độ mạnh mật khẩu** và kiểm tra “pwned passwords” ở đâu trong luồng login/đổi mật khẩu?
