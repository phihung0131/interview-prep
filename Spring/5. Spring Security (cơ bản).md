# 1) Authentication vs Authorization – Khái niệm & Dòng chảy

### 1. Phân biệt **authentication** và **authorization** bằng ví dụ cụ thể trong web app.
- **Authentication (Xác thực)**:
    - Xác minh danh tính người dùng (ai là người dùng?).
    - Ví dụ: Người dùng nhập username/password vào form login → hệ thống kiểm tra khớp với DB.
- **Authorization (Phân quyền)**:
    - Quyết định người dùng được làm gì sau khi xác thực.
    - Ví dụ: Người dùng có role `ADMIN` được truy cập `/admin/**`, còn `USER` chỉ vào `/user/**`.
- **Trong web app**:
    - Authentication: Đăng nhập vào trang web bằng email/password.
    - Authorization: Sau đăng nhập, chỉ `ADMIN` được xóa tài khoản khác.

---

### 2. `Principal`, `Authentication`, `GrantedAuthority` là gì và liên hệ giữa chúng?
- **`Principal`**:
    - Đại diện cho người dùng đã xác thực (thường là `UserDetails` hoặc username).
    - Ví dụ: `UserDetails` với username và roles.
- **`Authentication`**:
    - Đối tượng chứa thông tin xác thực: `Principal`, `Credentials`, `Authorities`.
    - Ví dụ: `UsernamePasswordAuthenticationToken` sau khi login.
- **`GrantedAuthority`**:
    - Quyền của người dùng (như `ROLE_ADMIN`, `ROLE_USER`).
- **Liên hệ**:
    - `Authentication` chứa `Principal` (user) và danh sách `GrantedAuthority` (quyền).
    - Ví dụ:
      ```java
      Authentication auth = SecurityContextHolder.getContext().getAuthentication();
      UserDetails user = (UserDetails) auth.getPrincipal();
      Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();
      ```

---

### 3. **Role** vs **Authority** khác nhau ra sao? Ý nghĩa tiền tố `ROLE_` và các hàm `hasRole()`/`hasAuthority()`?
- **Role**:
    - Nhóm quyền cấp cao, thường đại diện vai trò (như `ADMIN`, `USER`).
    - Lưu dưới dạng `ROLE_<name>` trong `GrantedAuthority`.
- **Authority**:
    - Quyền cụ thể hơn, có thể là `ROLE_<name>` hoặc quyền chi tiết (như `READ_PROFILE`).
- **Tiền tố `ROLE_`**:
    - Quy ước của Spring Security, dùng để phân biệt role với authority khác.
    - Ví dụ: `ROLE_ADMIN` là role, `READ_PROFILE` là authority.
- **`hasRole()` vs `hasAuthority()`**:
    - `hasRole("ADMIN")`: Kiểm tra `ROLE_ADMIN` (tự động thêm tiền tố `ROLE_`).
    - `hasAuthority("ROLE_ADMIN")`: Kiểm tra chính xác chuỗi `ROLE_ADMIN`.
    - Ví dụ:
      ```java
      @PreAuthorize("hasRole('ADMIN')") // Kiểm tra ROLE_ADMIN
      public void adminOnly() {}
      ```

---

### 4. Security Context: `SecurityContext`/`SecurityContextHolder` lưu cái gì? Vòng đời theo request/thread?
- **Lưu gì**:
    - `SecurityContext` chứa `Authentication` (thông tin người dùng, quyền).
    - `SecurityContextHolder` lưu `SecurityContext` trong `ThreadLocal` hoặc `SecurityContextRepository`.
- **Vòng đời**:
    - Trong một request:
        - `SecurityContextHolder` tạo `SecurityContext` khi filter chain bắt đầu (như `UsernamePasswordAuthenticationFilter`).
        - Sau khi xác thực, `Authentication` được lưu vào.
        - Cuối request, `SecurityContext` được xóa (trừ khi dùng session).
    - Mỗi thread có `SecurityContext` riêng.
- **Ví dụ**:
  ```java
  SecurityContext context = SecurityContextHolder.getContext();
  Authentication auth = context.getAuthentication();
  ```

---

### 5. ⚠️ Gài: Vì sao `SecurityContext` có thể “mất” khi dùng `@Async` hoặc thread pool? Cách khắc phục?
- **Nguyên nhân**:
    - `SecurityContext` lưu trong `ThreadLocal`, không tự động truyền sang thread mới (như `@Async`).
    - Thread pool tạo thread mới, không kế thừa `SecurityContext` từ thread gốc.
- **Khắc phục**:
    1. **Sử dụng `DelegatingSecurityContextExecutor`**:
       ```java
       @Bean
       public Executor taskExecutor() {
           ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
           executor.setThreadFactory(new DelegatingSecurityContextThreadFactory());
           return new DelegatingSecurityContextExecutor(executor);
       }
       ```
    2. **Truyền `SecurityContext` thủ công**:
       ```java
       @Async
       public void asyncTask() {
           SecurityContext context = SecurityContextHolder.getContext();
           // Truyền context sang thread mới
       }
       ```
    3. **Bật `MODE_INHERITABLETHREADLOCAL`**:
       ```java
       SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);
       ```

---

### 6. Authentication flow: từ `UsernamePasswordAuthenticationFilter` → `AuthenticationManager` → `AuthenticationProvider` → `UserDetailsService` → `PasswordEncoder`. Trình bày thứ tự.
- **Dòng chảy**:
    1. **`UsernamePasswordAuthenticationFilter`**:
        - Xử lý request POST `/login`, lấy username/password.
        - Tạo `UsernamePasswordAuthenticationToken` (chưa xác thực).
    2. **`AuthenticationManager`**:
        - Gọi `authenticate()` để giao việc cho các `AuthenticationProvider`.
    3. **`AuthenticationProvider`**:
        - Kiểm tra `AuthenticationToken` (như `DaoAuthenticationProvider`).
        - Gọi `UserDetailsService` để lấy `UserDetails`.
    4. **`UserDetailsService`**:
        - Truy vấn DB (hoặc in-memory) để lấy `UserDetails` qua `loadUserByUsername`.
    5. **`PasswordEncoder`**:
        - So khớp password người dùng nhập với hash trong `UserDetails`.
    6. **Kết quả**:
        - Nếu khớp, trả `Authentication` đã xác thực, lưu vào `SecurityContext`.
        - Nếu không, ném `AuthenticationException`.

---

### 7. Khác nhau giữa `AuthenticationManager` và `AuthenticationProvider`. Vì sao có thể có **nhiều** provider?
- **`AuthenticationManager`**:
    - Quản lý danh sách `AuthenticationProvider`, thử từng provider cho đến khi xác thực thành công hoặc thất bại.
    - Ví dụ: `ProviderManager`.
- **`AuthenticationProvider`**:
    - Thực hiện xác thực cụ thể (như username/password, JWT, LDAP).
    - Ví dụ: `DaoAuthenticationProvider`.
- **Nhiều provider**:
    - Hỗ trợ nhiều cơ chế xác thực (như form login, OAuth2, LDAP).
    - Ví dụ:
      ```java
      @Bean
      public AuthenticationManager authManager(List<AuthenticationProvider> providers) {
          return new ProviderManager(providers);
      }
      ```

---

### 8. Cơ chế **anonymous authentication** hoạt động thế nào? Khi nào hữu ích/không nên bật?
- **Hoạt động**:
    - Spring Security tạo `AnonymousAuthenticationToken` cho request không xác thực.
    - Gán `Principal` là `anonymousUser` với role `ROLE_ANONYMOUS`.
- **Hữu ích**:
    - Cho phép truy cập public endpoint (như `/public/**`).
    - Theo dõi hành vi người dùng chưa đăng nhập (audit).
- **Không nên bật**:
    - Khi cần chặn toàn bộ request không xác thực (dùng `authenticated()`).
    - Trong hệ thống nhạy cảm, yêu cầu mọi request phải có danh tính.

---

### 9. **Method Security** (`@PreAuthorize`, `@PostAuthorize`) vs Web security (URL/HTTP) khác nhau ở đâu và khi nào dùng cái nào?
- **Method Security**:
    - Dùng annotation như `@PreAuthorize`, `@PostAuthorize` để kiểm tra quyền trên method.
    - Ví dụ:
      ```java
      @PreAuthorize("hasRole('ADMIN')")
      public void deleteUser(Long id) {}
      ```
    - **Khi dùng**: Kiểm tra quyền chi tiết trên logic nghiệp vụ (như xóa user cụ thể).
- **Web Security**:
    - Dùng `authorizeHttpRequests()` để kiểm tra quyền trên URL.
    - Ví dụ:
      ```java
      http.authorizeHttpRequests(auth -> auth
          .requestMatchers("/admin/**").hasRole("ADMIN")
          .anyRequest().authenticated());
      ```
    - **Khi dùng**: Kiểm soát truy cập URL (như `/admin/**`).
- **Lựa chọn**:
    - Method Security: Logic nghiệp vụ phức tạp, cần kiểm tra điều kiện cụ thể.
    - Web Security: Quy tắc chung cho URL.

---

# 2) Cấu hình bảo mật cơ bản & Filter Chain

### 1. Mặc định Spring Security làm gì khi bạn **chưa cấu hình gì**?
- **Hành vi mặc định**:
    - Tạo form login tại `/login`.
    - Yêu cầu xác thực cho mọi request (deny-all trừ `/login`).
    - Bật CSRF protection.
    - Tạo session cho người dùng (stateful).
    - Tất cả endpoint trả 403 nếu không xác thực.

---

### 2. Cấu trúc **SecurityFilterChain** là gì? Vì sao cần bean `SecurityFilterChain` trong config hiện đại (Spring Security 6)?
- **Cấu trúc**:
    - Là chuỗi các filter xử lý request (như `UsernamePasswordAuthenticationFilter`, `CsrfFilter`).
    - Được cấu hình qua `HttpSecurity`.
- **Tại sao cần bean**:
    - Từ Spring Security 5.7/6, cấu hình dựa trên `@Bean` thay vì extend `WebSecurityConfigurerAdapter`.
    - Tăng tính linh hoạt, hỗ trợ nhiều filter chain.
    - Ví dụ:
      ```java
      @Bean
      public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
          http.authorizeHttpRequests(auth -> auth
              .requestMatchers("/public/**").permitAll()
              .anyRequest().authenticated());
          return http.build();
      }
      ```

---

### 3. `authorizeHttpRequests()` dùng để định nghĩa gì? So sánh `permitAll()` vs `authenticated()` vs matcher cụ thể.
- **`authorizeHttpRequests()`**:
    - Định nghĩa quy tắc phân quyền cho request dựa trên URL.
    - Ví dụ:
      ```java
      http.authorizeHttpRequests(auth -> auth
          .requestMatchers("/admin/**").hasRole("ADMIN")
          .requestMatchers("/public/**").permitAll()
          .anyRequest().authenticated());
      ```
- **So sánh**:
    - **`permitAll()`**: Cho phép mọi request, kể cả anonymous.
    - **`authenticated()`**: Yêu cầu xác thực (phải đăng nhập).
    - **Matcher cụ thể**: Áp dụng quyền chi tiết (như `hasRole("ADMIN")`).

---

### 4. ⚠️ Gài: Đặt `permitAll()` cho `/login` nhưng vẫn bị 403 — liệt kê 2–3 nguyên nhân điển hình.
- **Nguyên nhân**:
    1. **CSRF token thiếu**: POST `/login` yêu cầu CSRF token, nhưng client không gửi.
    2. **Thứ tự rule sai**: Rule nghiêm ngặt hơn (như `authenticated()`) được kiểm tra trước.
       ```java
       http.authorizeHttpRequests(auth -> auth
           .anyRequest().authenticated() // Chạy trước, chặn /login
           .requestMatchers("/login").permitAll());
       ```
    3. **Filter chain sai**: Có filter chain khác chặn request trước.
- **Giải pháp**:
    - Đảm bảo gửi CSRF token cho POST.
    - Đặt `permitAll()` trước `anyRequest()`:
      ```java
      http.authorizeHttpRequests(auth -> auth
          .requestMatchers("/login").permitAll()
          .anyRequest().authenticated());
      ```

---

### 5. CSRF: tại sao bật mặc định? Khi nào nên tắt (API stateless)? Ảnh hưởng với POST form truyền thống?
- **Tại sao bật mặc định**:
    - Ngăn tấn công CSRF (giả mạo request từ site khác).
    - Yêu cầu CSRF token cho các request thay đổi trạng thái (POST, PUT, DELETE).
- **Khi tắt**:
    - API stateless (dùng JWT, không session).
    - Ví dụ:
      ```java
      http.csrf(csrf -> csrf.disable());
      ```
- **Ảnh hưởng POST form**:
    - Form cần gửi CSRF token (thẻ `<input name="_csrf">`).
    - Nếu tắt CSRF, form POST không cần token, nhưng dễ bị tấn công CSRF.

---

### 6. CORS vs CSRF khác nhau gì? Chặn tình huống nào?
- **CORS**:
    - Kiểm soát truy cập tài nguyên từ domain khác.
    - Ngăn client không được phép (như domain lạ) gọi API.
    - Ví dụ:
      ```java
      @Bean
      public CorsConfigurationSource corsConfigurationSource() {
          CorsConfiguration config = new CorsConfiguration();
          config.addAllowedOrigin("http://example.com");
          config.addAllowedMethod("*");
          UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
          source.registerCorsConfiguration("/**", config);
          return source;
      }
      ```
- **CSRF**:
    - Ngăn request giả mạo từ site khác (như gửi POST từ site độc).
    - Yêu cầu CSRF token trong request thay đổi trạng thái.
- **Chặn**:
    - CORS: Chặn truy cập cross-origin không được phép.
    - CSRF: Chặn request giả mạo từ site khác.

---

### 7. Session management cơ bản: stateless vs stateful; `SessionCreationPolicy` các giá trị thường dùng.
- **Stateless**:
    - Không lưu session, dùng token (như JWT).
    - `SessionCreationPolicy.STATELESS`:
      ```java
      http.sessionManagement(session -> session
          .sessionCreationPolicy(SessionCreationPolicy.STATELESS));
      ```
- **Stateful**:
    - Lưu session trong server, dùng cookie (như JSESSIONID).
    - `SessionCreationPolicy.IF_REQUIRED` (mặc định).
- **Các giá trị**:
    - `ALWAYS`: Luôn tạo session.
    - `IF_REQUIRED`: Tạo session khi cần.
    - `NEVER`: Không tạo session, nhưng dùng nếu có sẵn.
    - `STATELESS`: Không tạo, không dùng session.

---

### 8. Exception handling: `authenticationEntryPoint` vs `accessDeniedHandler` dùng khi nào?
- **`authenticationEntryPoint`**:
    - Xử lý khi request không xác thực (401 Unauthorized).
    - Ví dụ: Trả JSON cho API khi chưa đăng nhập:
      ```java
      http.exceptionHandling(ex -> ex
          .authenticationEntryPoint((req, res, ex) -> res.sendError(HttpServletResponse.SC_UNAUTHORIZED)));
      ```
- **`accessDeniedHandler`**:
    - Xử lý khi đã xác thực nhưng không đủ quyền (403 Forbidden).
    - Ví dụ: Chuyển hướng đến trang lỗi:
      ```java
      http.exceptionHandling(ex -> ex
          .accessDeniedHandler((req, res, ex) -> res.sendRedirect("/access-denied")));
      ```

---

# 3) In-Memory Authentication

### 1. In-memory auth: tạo user bằng `InMemoryUserDetailsManager` như thế nào?
- **Cấu hình**:
  ```java
  @Bean
  public UserDetailsService userDetailsService() {
      UserDetails user = User.withUsername("user")
          .password("{bcrypt}$2a$10$...")
          .roles("USER")
          .build();
      return new InMemoryUserDetailsManager(user);
  }
  ```

---

### 2. ⚠️ Gài: Vì sao thêm user `{noop}password` chạy được, nhưng bỏ `{noop}` thì lỗi? Ý nghĩa **id** trong `DelegatingPasswordEncoder`.
- **Nguyên nhân**:
    - `{noop}` chỉ định `NoOpPasswordEncoder` (không mã hóa, lưu plain text).
    - Nếu bỏ `{noop}`, Spring Security yêu cầu password được mã hóa (như BCrypt), gây lỗi `BadCredentialsException`.
- **Ý nghĩa `id` trong `DelegatingPasswordEncoder`**:
    - `id` (như `bcrypt`, `noop`) chỉ thuật toán mã hóa trong chuỗi `{id}hash`.
    - `DelegatingPasswordEncoder` chọn encoder dựa trên `id`.
    - Ví dụ: `{bcrypt}$2a$10$...` dùng `BCryptPasswordEncoder`.
- **Giải pháp**:
    - Dùng `BCryptPasswordEncoder`:
      ```java
      @Bean
      public PasswordEncoder passwordEncoder() {
          return new BCryptPasswordEncoder();
      }
      ```

---

### 3. Phân biệt `withUsername().password().roles()` vs `authorities()`; mapping role → authority.
- **`roles()`**:
    - Tự động thêm tiền tố `ROLE_` (như `roles("ADMIN")` → `ROLE_ADMIN`).
- **`authorities()`**:
    - Gán trực tiếp `GrantedAuthority` (như `authorities("ROLE_ADMIN", "READ_PROFILE")`).
- **Mapping**:
    - `roles("ADMIN")` → `authorities("ROLE_ADMIN")`.
    - Ví dụ:
      ```java
      UserDetails user = User.withUsername("user")
          .password("{bcrypt}...")
          .roles("USER") // Tương đương authorities("ROLE_USER")
          .build();
      ```

---

### 4. Tổ chức **nhiều** user với nhiều role trong in-memory sao cho dễ đọc/bảo trì?
- **Cấu hình**:
  ```java
  @Bean
  public UserDetailsService userDetailsService() {
      UserDetails user1 = User.withUsername("user")
          .password("{bcrypt}...")
          .roles("USER")
          .build();
      UserDetails admin = User.withUsername("admin")
          .password("{bcrypt}...")
          .roles("ADMIN", "USER")
          .build();
      return new InMemoryUserDetailsManager(user1, admin);
  }
  ```
- **Cách bảo trì**:
    - Tách cấu hình vào file YAML:
      ```yaml
      spring:
        security:
          user:
            name: user
            password: {bcrypt}...
            roles: USER
      ```
    - Hoặc dùng `@ConfigurationProperties` để load danh sách user.

---

### 5. Hạn chế của in-memory auth trong thực tế (triển khai, thay đổi mật khẩu, phân quyền động…).
- **Hạn chế**:
    - Không lưu trữ vĩnh viễn, mất khi restart app.
    - Khó thay đổi mật khẩu/role mà không rebuild.
    - Không hỗ trợ phân quyền động (như thêm user qua UI).
    - Không phù hợp với hệ thống lớn, nhiều user.
- **Giải pháp**:
    - Chuyển sang JDBC hoặc JPA-based `UserDetailsService`.

---

### 6. Cách test nhanh in-memory auth với `@WithMockUser` và `SecurityMockMvcRequestPostProcessors`.
- **Sử dụng**:
    - **`@WithMockUser`**:
      ```java
      @Test
      @WithMockUser(username = "user", roles = {"USER"})
      public void testUserAccess() throws Exception {
          mockMvc.perform(get("/user"))
              .andExpect(status().isOk());
      }
      ```
    - **`SecurityMockMvcRequestPostProcessors`**:
      ```java
      @Test
      public void testLogin() throws Exception {
          mockMvc.perform(post("/login")
              .with(SecurityMockMvcRequestPostProcessors.user("user").roles("USER")))
              .andExpect(status().isOk());
      }
      ```

---

# 4) JDBC Authentication (dựa trên DB)

### 1. JDBC authentication khác gì so với `UserDetailsService` tự viết? Khi nào chọn JDBC auth?
- **Khác biệt**:
    - **JDBC auth**:
        - Dùng `JdbcUserDetailsManager`, truy vấn DB với schema mặc định (`users`, `authorities`).
        - Cung cấp sẵn các method như `createUser`, `updateUser`.
    - **`UserDetailsService` tự viết**:
        - Tùy chỉnh logic lấy `UserDetails` (như dùng JPA).
        - Linh hoạt hơn, nhưng phải tự viết code.
- **Khi chọn JDBC auth**:
    - DB có schema tương thích hoặc dễ điều chỉnh.
    - Cần các tính năng quản lý user (tạo, xóa, cập nhật).
    - Muốn dùng cấu hình có sẵn của Spring Security.

---

### 2. **Default schema** Spring Security (bảng `users`, `authorities`) gồm cột gì? Có bắt buộc dùng schema mặc định không?
- **Schema mặc định**:
    - **users**:
        - `username` (VARCHAR, primary key)
        - `password` (VARCHAR)
        - `enabled` (BOOLEAN)
    - **authorities**:
        - `username` (VARCHAR, foreign key)
        - `authority` (VARCHAR)
- **Bắt buộc**:
    - Không bắt buộc, có thể tùy chỉnh qua `usersByUsernameQuery` và `authoritiesByUsernameQuery`.

---

### 3. ⚠️ Gài: DB đang có bảng user khác tên/cột — cấu hình `usersByUsernameQuery`/`authoritiesByUsernameQuery` như thế nào để map đúng?
- **Cấu hình**:
  ```java
  @Bean
  public UserDetailsService userDetailsService(DataSource dataSource) {
      JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);
      manager.setUsersByUsernameQuery(
          "SELECT email AS username, password, active AS enabled FROM my_users WHERE email = ?");
      manager.setAuthoritiesByUsernameQuery(
          "SELECT email AS username, role AS authority FROM my_roles WHERE email = ?");
      return manager;
  }
  ```
- **Chú ý**:
    - Query phải trả đúng cột: `username`, `password`, `enabled` (cho users) và `username`, `authority` (cho authorities).

---

### 4. Quản lý **DataSource**: lấy từ đâu (Hikari, Spring Boot auto-config)? Cần quyền DB gì?
- **Nguồn DataSource**:
    - Spring Boot auto-config: Tự tạo `DataSource` (HikariCP mặc định) từ `application.properties`:
      ```properties
      spring.datasource.url=jdbc:mysql://localhost:3306/db
      spring.datasource.username=root
      spring.datasource.password=secret
      ```
- **Quyền DB**:
    - SELECT trên `users` và `authorities` để xác thực.
    - INSERT/UPDATE/DELETE nếu dùng `JdbcUserDetailsManager` để quản lý user.

---

### 5. Mật khẩu trong DB phải được **mã hoá** như thế nào để `PasswordEncoder` match được?
- **Yêu cầu**:
    - Mật khẩu phải được mã hóa bằng `PasswordEncoder` (như BCrypt).
    - Lưu dưới dạng `{id}hash` (như `{bcrypt}$2a$10$...`).
- **Ví dụ**:
  ```java
  @Bean
  public PasswordEncoder passwordEncoder() {
      return new BCryptPasswordEncoder();
  }
  ```
    - Khi lưu user:
      ```java
      userDetailsManager.createUser(
          User.withUsername("user")
              .password(passwordEncoder.encode("password"))
              .roles("USER")
              .build());
      ```

---

### 6. Xử lý tài khoản **disabled/locked/expired** với JDBC auth: trường/bool nào cần trong DB?
- **Trường cần**:
    - `enabled` (BOOLEAN): Kiểm tra tài khoản có active không.
    - `account_non_locked` (BOOLEAN): Kiểm tra tài khoản bị khóa không.
    - `account_non_expired` (BOOLEAN): Kiểm tra tài khoản hết hạn không.
    - `credentials_non_expired` (BOOLEAN): Kiểm tra mật khẩu hết hạn không.
- **Schema tùy chỉnh**:
  ```sql
  CREATE TABLE users (
      username VARCHAR(50) PRIMARY KEY,
      password VARCHAR(100),
      enabled BOOLEAN,
      account_non_locked BOOLEAN,
      account_non_expired BOOLEAN,
      credentials_non_expired BOOLEAN
  );
  ```

---

### 7. Chiến lược **phân trang/tra cứu** quyền khi user có nhiều role/authority (index cần thiết).
- **Chiến lược**:
    - Lưu `authorities` trong bảng riêng, liên kết qua `username`.
    - Dùng query tối ưu:
      ```sql
      SELECT username, authority FROM authorities WHERE username = ?
      ```
    - Phân trang nếu số lượng quyền lớn:
      ```java
      @Query("SELECT a.authority FROM Authority a WHERE a.username = :username")
      Page<String> findAuthoritiesByUsername(@Param("username") String username, Pageable pageable);
      ```
- **Index**:
    - Tạo index trên `username` trong bảng `authorities`:
      ```sql
      CREATE INDEX idx_authorities_username ON authorities (username);
      ```

---

# 5) UserDetailsService – Hợp đồng & Tùy biến

### 1. Hợp đồng của `UserDetailsService#loadUserByUsername`: trả về gì, ném exception gì khi không tìm thấy user?
- **Hợp đồng**:
    - Method: `UserDetails loadUserByUsername(String username)`.
    - Trả về: `UserDetails` (chứa username, password, authorities, trạng thái tài khoản).
    - Exception: `UsernameNotFoundException` khi không tìm thấy user.
- **Ví dụ**:
  ```java
  public class CustomUserDetailsService implements UserDetailsService {
      @Override
      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
          UserEntity user = repository.findByUsername(username)
              .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
          return new User(user.getUsername(), user.getPassword(), user.getAuthorities());
      }
  }
  ```

---

### 2. ⚠️ Gài: Vì sao nên **ẩn** thông tin “user không tồn tại” khi login fail? Ảnh hưởng bảo mật?
- **Tại sao ẩn**:
    - Lộ thông tin “user không tồn tại” giúp hacker đoán được username hợp lệ.
    - Tăng nguy cơ tấn công brute force hoặc enumeration.
- **Ảnh hưởng bảo mật**:
    - Hacker có thể thu thập danh sách username để thử password.
- **Giải pháp**:
    - Trả lỗi chung:
      ```java
      throw new BadCredentialsException("Invalid username or password");
      ```

---

### 3. `UserDetails` gồm những thuộc tính nào quan trọng (enabled, accountNonExpired…)? Tương ứng cột DB nào?
- **Thuộc tính**:
    - `getUsername()`: Tên người dùng (DB: `username`).
    - `getPassword()`: Mật khẩu mã hóa (DB: `password`).
    - `getAuthorities()`: Danh sách quyền (DB: `authorities`).
    - `isEnabled()`: Tài khoản active (DB: `enabled`).
    - `isAccountNonLocked()`: Tài khoản không bị khóa (DB: `account_non_locked`).
    - `isAccountNonExpired()`: Tài khoản không hết hạn (DB: `account_non_expired`).
    - `isCredentialsNonExpired()`: Mật khẩu không hết hạn (DB: `credentials_non_expired`).
- **Mapping DB**:
  ```sql
  CREATE TABLE users (
      username VARCHAR(50),
      password VARCHAR(100),
      enabled BOOLEAN,
      account_non_locked BOOLEAN,
      account_non_expired BOOLEAN,
      credentials_non_expired BOOLEAN
  );
  ```

---

### 4. So sánh `InMemoryUserDetailsManager`, `JdbcUserDetailsManager`, `UserDetailsService` tự viết (JPA).
- **`InMemoryUserDetailsManager`**:
    - Lưu user trong bộ nhớ.
    - **Ưu**: Nhanh, dễ cấu hình cho test/dev.
    - **Nhược**: Không lưu vĩnh viễn, không hỗ trợ nhiều user.
- **`JdbcUserDetailsManager`**:
    - Dùng DB với schema mặc định hoặc tùy chỉnh.
    - **Ưu**: Hỗ trợ CRUD user, tích hợp DB.
    - **Nhược**: Phụ thuộc schema, kém linh hoạt.
- **`UserDetailsService` tự viết (JPA)**:
    - Dùng JPA để truy vấn entity tùy chỉnh.
    - **Ưu**: Linh hoạt, tích hợp domain model.
    - **Nhược**: Phải viết code mapping.

---

### 5. Mapping từ **domain User** (JPA entity) sang `UserDetails`: nơi đặt logic & trách nhiệm của mỗi lớp?
- **Nơi đặt logic**:
    - Trong `UserDetailsService` hoặc class riêng (như `UserDetailsMapper`).
    - Ví dụ:
      ```java
      public class CustomUserDetailsService implements UserDetailsService {
          @Autowired
          private UserRepository repository;
          @Override
          public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
              UserEntity user = repository.findByUsername(username)
                  .orElseThrow(() -> new UsernameNotFoundException("User not found"));
              return new org.springframework.security.core.userdetails.User(
                  user.getUsername(),
                  user.getPassword(),
                  user.isEnabled(),
                  user.isAccountNonExpired(),
                  user.isCredentialsNonExpired(),
                  user.isAccountNonLocked(),
                  user.getRoles().stream()
                      .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))
                      .collect(Collectors.toList())
              );
          }
      }
      ```
- **Trách nhiệm**:
    - **Entity**: Lưu dữ liệu user (username, password, roles).
    - **UserDetailsService**: Mapping entity → `UserDetails`.
    - **UserDetails**: Cung cấp thông tin xác thực/phân quyền.

---

### 6. Tích hợp `UserDetailsService` với caching (ví dụ cache quyền) có rủi ro gì khi đổi role động?
- **Tích hợp caching**:
  ```java
  @Service
  public class CustomUserDetailsService implements UserDetailsService {
      @Autowired
      private UserRepository repository;
      @Cacheable("userDetails")
      @Override
      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
          // Logic như trên
      }
  }
  ```
- **Rủi ro**:
    - Cache không cập nhật khi role thay đổi (như thêm/xóa role).
    - Dẫn đến quyền không đồng bộ, gây lỗi phân quyền.
- **Giải pháp**:
    - Xóa cache khi cập nhật role:
      ```java
      @CacheEvict(value = "userDetails", key = "#user.username")
      public void updateUserRoles(UserEntity user) {
          repository.save(user);
      }
      ```

---

### 7. `AuthenticationProvider` tuỳ biến có thể **bỏ qua** `UserDetailsService` không? Tình huống nào cần (ví dụ, LDAP, SSO)?
- **Có thể bỏ qua**:
    - `AuthenticationProvider` tự xử lý logic xác thực, không cần `UserDetailsService`.
- **Tình huống**:
    - **LDAP**: Dùng `LdapAuthenticationProvider` để xác thực trực tiếp với LDAP server.
    - **SSO**: Dùng `OAuth2AuthenticationProvider` để xử lý token từ provider bên ngoài.
- **Ví dụ**:
  ```java
  public class CustomAuthenticationProvider implements AuthenticationProvider {
      @Override
      public Authentication authenticate(Authentication auth) throws AuthenticationException {
          String username = auth.getName();
          String password = auth.getCredentials().toString();
          // Custom logic (như gọi API bên ngoài)
          return new UsernamePasswordAuthenticationToken(username, password, Collections.emptyList());
      }
      @Override
      public boolean supports(Class<?> authentication) {
          return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
      }
  }
  ```

---

# 6) PasswordEncoder – Mã hoá mật khẩu an toàn

### 1. Tại sao **không** được lưu plain text? Khác biệt giữa hash một chiều vs mã hoá hai chiều.
- **Không lưu plain text**:
    - Nếu DB bị rò rỉ, hacker có thể dùng mật khẩu trực tiếp.
    - Plain text dễ bị lạm dụng bởi admin hoặc nhân viên.
- **Hash một chiều**:
    - Biến đổi mật khẩu thành chuỗi không thể đảo ngược (như BCrypt).
    - Dùng để xác thực bằng cách so khớp hash.
- **Mã hoá hai chiều**:
    - Có thể giải mã về plain text (như AES).
    - Không phù hợp cho mật khẩu vì cần lưu khóa giải mã.

---

### 2. `PasswordEncoder` phổ biến: `BCrypt`, `PBKDF2`, `scrypt`, `Argon2`. Chọn cái nào cho web app thông thường?
- **So sánh**:
    - **BCrypt**: Cân bằng hiệu năng và bảo mật, tích hợp salt, điều chỉnh cost factor.
    - **PBKDF2**: Nhanh, nhưng ít chống lại GPU attack hơn BCrypt.
    - **scrypt**: Chống GPU attack tốt, nhưng tốn bộ nhớ.
    - **Argon2**: Hiện đại nhất, chống GPU/ASIC, nhưng phức tạp hơn.
- **Lựa chọn**:
    - **BCrypt** cho web app thông thường (dễ dùng, bảo mật tốt, được Spring hỗ trợ mặc định).

---

### 3. `DelegatingPasswordEncoder` và cú pháp `{id}hash` hoạt động ra sao? Lợi ích khi **migrate** thuật toán.
- **Hoạt động**:
    - `DelegatingPasswordEncoder` chọn encoder dựa trên `id` trong `{id}hash`.
    - Ví dụ: `{bcrypt}$2a$10$...` dùng `BCryptPasswordEncoder`.
    - Hỗ trợ nhiều encoder trong cùng DB.
- **Lợi ích migrate**:
    - Cho phép chuyển từ thuật toán cũ (như MD5) sang mới (như BCrypt) mà không cần cập nhật toàn bộ mật khẩu.
    - Mật khẩu cũ vẫn hoạt động, mật khẩu mới dùng encoder mới.

---

### 4. ⚠️ Gài: App đang dùng `{noop}` trong dev, đẩy lên prod quên đổi — chỉ ra rủi ro và biện pháp **fail-fast**.
- **Rủi ro**:
    - Mật khẩu plain text trong DB, dễ bị lộ nếu DB bị tấn công.
    - Không an toàn khi triển khai production.
- **Biện pháp fail-fast**:
    - Thêm kiểm tra trong `@PostConstruct`:
      ```java
      @Bean
      public PasswordEncoder passwordEncoder() {
          return new BCryptPasswordEncoder();
      }
      @PostConstruct
      public void checkPasswordEncoder() {
          if (passwordEncoder instanceof NoOpPasswordEncoder) {
              throw new IllegalStateException("NoOpPasswordEncoder is not allowed in production");
          }
      }
      ```
    - Dùng profile:
      ```properties
      spring.profiles.active=prod
      spring.security.password-encoder=bcrypt
      ```

---

### 5. Thiết lập **strength/cost** cho BCrypt: tiêu chí chọn (hiệu năng vs an toàn), cách benchmark.
- **Strength/Cost**:
    - BCrypt dùng cost factor (mặc định 10, tăng gấp đôi thời gian mỗi +1).
- **Tiêu chí**:
    - **Hiệu năng**: Cost thấp (8–10) cho app có nhiều user đồng thời.
    - **An toàn**: Cost cao (12–14) cho hệ thống nhạy cảm.
- **Benchmark**:
  ```java
  @Test
  public void benchmarkBCrypt() {
      BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);
      long start = System.currentTimeMillis();
      encoder.encode("password");
      long duration = System.currentTimeMillis() - start;
      System.out.println("BCrypt encoding took: " + duration + "ms");
  }
  ```

---

### 6. Nâng cấp mật khẩu “nhẹ nhàng”: chiến lược **on-login rehash** là gì?
- **On-login rehash**:
    - Khi user đăng nhập, kiểm tra mật khẩu cũ, nếu khớp nhưng dùng encoder yếu, mã hóa lại bằng encoder mới.
    - Ví dụ:
      ```java
      public void authenticateAndRehash(String username, String rawPassword) {
          UserDetails user = userDetailsService.loadUserByUsername(username);
          if (passwordEncoder.matches(rawPassword, user.getPassword())) {
              String newHash = passwordEncoder.encode(rawPassword);
              userDetailsManager.updateUser(
                  User.withUsername(username)
                      .password(newHash)
                      .authorities(user.getAuthorities())
                      .build());
          }
      }
      ```

---

### 7. Kiểm tra trùng mật khẩu cũ mới (password reuse) nên làm ở đâu (service/validator)?
- **Nơi đặt**:
    - **Service**: Xử lý logic kiểm tra lịch sử mật khẩu.
    - **Validator**: Kiểm tra độ mạnh mật khẩu hoặc chính sách reuse.
- **Ví dụ**:
  ```java
  @Service
  public class PasswordService {
      @Autowired
      private PasswordHistoryRepository historyRepo;
      public void changePassword(String username, String newPassword) {
          List<PasswordHistory> history = historyRepo.findByUsername(username);
          for (PasswordHistory old : history) {
              if (passwordEncoder.matches(newPassword, old.getPassword())) {
                  throw new IllegalArgumentException("Cannot reuse old password");
              }
          }
          // Save new password
      }
  }
  ```

---

### 8. Lưu hash kèm salt như thế nào với BCrypt (salt embedded)? Có cần cột salt riêng?
- **BCrypt**:
    - Salt được tự động sinh và nhúng trong chuỗi hash (phần `$2a$10$salt.hash`).
    - Không cần cột salt riêng trong DB.
- **Ví dụ**:
    - Hash: `$2a$10$randomSaltHere...hash`.
    - Lưu trực tiếp vào cột `password`.

---

### 9. ⚠️ Gài: Vì sao `passwordEncoder.matches(raw, encoded)` luôn false? Liệt kê 2–3 nguyên nhân (id sai, double-encode, trim…).
- **Nguyên nhân**:
    1. **ID sai**: Chuỗi encoded không có `{id}` khớp với `PasswordEncoder` (như dùng `{noop}` nhưng encoder là BCrypt).
    2. **Double-encode**: Mật khẩu được mã hóa hai lần, làm hash không khớp.
    3. **Trim hoặc format sai**: Raw password có khoảng trắng hoặc ký tự thừa.
- **Giải pháp**:
    - Kiểm tra `{id}` trong DB khớp với encoder.
    - Đảm bảo chỉ encode một lần:
      ```java
      String encoded = passwordEncoder.encode(rawPassword);
      boolean matches = passwordEncoder.matches(rawPassword, encoded); // Phải true
      ```

---

# 7) Authorization cơ bản (URL & Method)

### 1. `authorizeHttpRequests()` với các matcher: thứ tự kiểm tra quan trọng thế nào?
- **Thứ tự**:
    - Spring Security kiểm tra rule từ trên xuống, dừng khi khớp.
    - Ví dụ:
      ```java
      http.authorizeHttpRequests(auth -> auth
          .requestMatchers("/public/**").permitAll()
          .requestMatchers("/admin/**").hasRole("ADMIN")
          .anyRequest().authenticated());
      ```
    - Nếu đặt `anyRequest().authenticated()` đầu tiên, `/public/**` bị chặn.
- **Chú ý**:
    - Rule cụ thể (như `/admin/**`) phải đặt trước rule chung (`anyRequest()`).

---

### 2. Khác nhau `hasRole("ADMIN")` vs `hasAuthority("ROLE_ADMIN")` trong URL authorization.
- **`hasRole("ADMIN")`**:
    - Kiểm tra `ROLE_ADMIN` (tự động thêm `ROLE_`).
- **`hasAuthority("ROLE_ADMIN")`**:
    - Kiểm tra chính xác chuỗi `ROLE_ADMIN`.
- **Ví dụ**:
  ```java
  http.authorizeHttpRequests(auth -> auth
      .requestMatchers("/admin/**").hasRole("ADMIN") // Tương đương hasAuthority("ROLE_ADMIN")
      .anyRequest().authenticated());
  ```

---

### 3. Method security (`@EnableMethodSecurity`) bật thế nào? `@PreAuthorize("hasRole('ADMIN')")` hoạt động khi nào?
- **Bật**:
  ```java
  @Configuration
  @EnableMethodSecurity
  public class SecurityConfig {
      // Config
  }
  ```
- **`@PreAuthorize`**:
    - Kiểm tra quyền trước khi gọi method.
    - Ví dụ:
      ```java
      @PreAuthorize("hasRole('ADMIN')")
      public void deleteUser(Long id) {}
      ```
    - Hoạt động khi method được gọi qua Spring proxy (như `@Service`).

---

### 4. ⚠️ Gài: Vì sao method security **không chạy** khi gọi method **trong cùng class**?
- **Nguyên nhân**:
    - Method security dựa trên AOP proxy (JDK/CGLIB).
    - Gọi method trong cùng class (self-invocation) không qua proxy, bỏ qua `@PreAuthorize`.
- **Giải pháp**:
    - Tách method sang service khác:
      ```java
      @Service
      public class AdminService {
          @Autowired
          private UserService userService;
          public void process() {
              userService.deleteUser(1L); // Qua proxy
          }
      }
      @Service
      public class UserService {
          @PreAuthorize("hasRole('ADMIN')")
          public void deleteUser(Long id) {}
      }
      ```

---

### 5. Thiết kế ma trận quyền **ROLE vs PERMISSION**: khi nào chỉ dùng role là đủ, khi nào cần authority chi tiết?
- **Chỉ dùng role**:
    - Hệ thống đơn giản, quyền phân theo nhóm (như `ADMIN`, `USER`).
    - Ví dụ: `/admin/**` → `ROLE_ADMIN`.
- **Cần authority chi tiết**:
    - Quyền chi tiết (như `READ_PROFILE`, `WRITE_PROFILE`).
    - Ví dụ:
      ```java
      @PreAuthorize("hasAuthority('WRITE_PROFILE')")
      public void updateProfile(ProfileDTO dto) {}
      ```
- **Ma trận quyền**:
    - Lưu `roles` và `permissions` trong DB:
      ```sql
      CREATE TABLE roles (
          role_name VARCHAR(50),
          permission VARCHAR(50)
      );
      ```

---

# 8) Mini case (thực chiến 2–5 phút mỗi câu)

### 1. Thiết kế đăng nhập form đơn giản: in-memory cho dev, JDBC cho staging/prod. Mô tả cấu hình chuyển **profile** và `PasswordEncoder`.
- **Cấu hình**:
  ```java
  @Configuration
  public class SecurityConfig {
      @Bean
      public PasswordEncoder passwordEncoder() {
          return new BCryptPasswordEncoder();
      }
      @Profile("dev")
      @Bean
      public UserDetailsService inMemoryUserDetailsService(PasswordEncoder encoder) {
          UserDetails user = User.withUsername("user")
              .password(encoder.encode("password"))
              .roles("USER")
              .build();
          return new InMemoryUserDetailsManager(user);
      }
      @Profile({"staging", "prod"})
      @Bean
      public UserDetailsService jdbcUserDetailsService(DataSource dataSource) {
          JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);
          manager.setUsersByUsernameQuery("SELECT username, password, enabled FROM users WHERE username = ?");
          manager.setAuthoritiesByUsernameQuery("SELECT username, authority FROM authorities WHERE username = ?");
          return manager;
      }
      @Bean
      public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
          http.authorizeHttpRequests(auth -> auth
              .requestMatchers("/login").permitAll()
              .anyRequest().authenticated())
              .formLogin(form -> form.loginPage("/login"));
          return http.build();
      }
  }
  ```
- **Profile**:
  ```properties
  # application-dev.properties
  spring.profiles.active=dev
  # application-prod.properties
  spring.profiles.active=prod
  spring.datasource.url=jdbc:mysql://...
  ```

---

### 2. DB hiện tại lưu MD5 không salt. Trình bày kế hoạch migration sang BCrypt mà **không bắt** toàn bộ user đổi mật khẩu ngay.
- **Kế hoạch**:
    1. Cập nhật `PasswordEncoder`:
       ```java
       @Bean
       public PasswordEncoder passwordEncoder() {
           Map<String, PasswordEncoder> encoders = new HashMap<>();
           encoders.put("md5", new MessageDigestPasswordEncoder("MD5"));
           encoders.put("bcrypt", new BCryptPasswordEncoder());
           return new DelegatingPasswordEncoder("bcrypt", encoders);
       }
       ```
    2. On-login rehash:
       ```java
       @Service
       public class LoginService {
           @Autowired
           private UserDetailsManager userDetailsManager;
           @Autowired
           private PasswordEncoder passwordEncoder;
           public void authenticateAndRehash(String username, String rawPassword) {
               UserDetails user = userDetailsManager.loadUserByUsername(username);
               if (passwordEncoder.matches(rawPassword, user.getPassword())) {
                   String newHash = passwordEncoder.encode(rawPassword);
                   userDetailsManager.updateUser(
                       User.withUsername(username)
                           .password(newHash)
                           .authorities(user.getAuthorities())
                           .build());
               }
           }
       }
       ```
    3. Cập nhật DB dần dần khi user đăng nhập.

---

### 3. API REST stateless: tắt session, bật CORS, tắt CSRF — chỉ rõ các bước cấu hình và nguy cơ nếu tắt sai.
- **Cấu hình**:
  ```java
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http
          .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
          .csrf(csrf -> csrf.disable())
          .cors(cors -> cors.configurationSource(corsConfigurationSource()))
          .authorizeHttpRequests(auth -> auth
              .requestMatchers("/api/**").authenticated()
              .anyRequest().permitAll());
      return http.build();
  }
  @Bean
  public CorsConfigurationSource corsConfigurationSource() {
      CorsConfiguration config = new CorsConfiguration();
      config.addAllowedOrigin("http://frontend.com");
      config.addAllowedMethod("*");
      config.addAllowedHeader("*");
      UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
      source.registerCorsConfiguration("/**", config);
      return source;
  }
  ```
- **Nguy cơ nếu tắt sai**:
    - Tắt CSRF nhưng vẫn dùng session: Dễ bị tấn công CSRF.
    - Bật CORS sai (như `allowedOrigin=*`): Cho phép domain không an toàn.

---

### 4. Viết `UserDetailsService` dựa JPA: mapping entity → `UserDetails`, xử lý user disabled/locked, và nơi đặt `@Transactional`.
- **Cấu hình**:
  ```java
  @Service
  public class JpaUserDetailsService implements UserDetailsService {
      @Autowired
      private UserRepository repository;
      @Transactional(readOnly = true)
      @Override
      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
          UserEntity user = repository.findByUsername(username)
              .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
          if (!user.isEnabled()) {
              throw new DisabledException("Account disabled");
          }
          if (!user.isAccountNonLocked()) {
              throw new LockedException("Account locked");
          }
          return new org.springframework.security.core.userdetails.User(
              user.getUsername(),
              user.getPassword(),
              user.isEnabled(),
              user.isAccountNonExpired(),
              user.isCredentialsNonExpired(),
              user.isAccountNonLocked(),
              user.getRoles().stream()
                  .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))
                  .collect(Collectors.toList())
          );
      }
  }
  ```
- **`@Transactional`**:
    - Đặt trên `loadUserByUsername` để đảm bảo truy vấn JPA trong transaction.

---

### 5. Tổ chức phân quyền: `/admin/**` chỉ ADMIN, `/user/**` cho USER & ADMIN, `/public/**` mở. Trình bày rule theo **thứ tự đúng** tránh bị “lọt”.
- **Cấu hình**:
  ```java
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http.authorizeHttpRequests(auth -> auth
          .requestMatchers("/public/**").permitAll()
          .requestMatchers("/admin/**").hasRole("ADMIN")
          .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
          .anyRequest().authenticated());
      return http.build();
  }
  ```
- **Thứ tự**:
    - `permitAll()` đầu tiên để mở `/public/**`.
    - `hasRole("ADMIN")` trước `hasAnyRole("USER", "ADMIN")` để ưu tiên quyền chặt chẽ.
    - `anyRequest().authenticated()` cuối cùng để yêu cầu xác thực.

---

### 6. Sự cố: nhập đúng user/pass nhưng luôn 403. Liệt kê checklist chẩn đoán (role prefix, matcher, method security, CSRF…).
- **Checklist**:
    1. **Role prefix**: Quyền lưu là `ADMIN` nhưng kiểm tra `ROLE_ADMIN`.
    2. **Matcher sai**: URL không khớp rule (như `/admin` thay vì `/admin/**`).
    3. **Method security**: `@PreAuthorize` yêu cầu quyền không có.
    4. **CSRF token**: POST request thiếu token.
    5. **Session timeout**: Session hết hạn, cần đăng nhập lại.
    6. **Filter chain**: Có filter chain khác chặn request.

---

### 7. Tạo 2 user in-memory: `user/USER`, `admin/ADMIN`. Chỉ ra khác biệt khi dùng `roles("ADMIN")` vs `authorities("ROLE_ADMIN")` trong cấu hình.
- **Cấu hình**:
  ```java
  @Bean
  public UserDetailsService userDetailsService(PasswordEncoder encoder) {
      UserDetails user = User.withUsername("user")
          .password(encoder.encode("password"))
          .roles("USER") // Tương đương authorities("ROLE_USER")
          .build();
      UserDetails admin = User.withUsername("admin")
          .password(encoder.encode("password"))
          .authorities("ROLE_ADMIN") // Không cần tiền tố ROLE_ trong roles()
          .build();
      return new InMemoryUserDetailsManager(user, admin);
  }
  ```
- **Khác biệt**:
    - `roles("ADMIN")`: Tự thêm `ROLE_` → `ROLE_ADMIN`.
    - `authorities("ROLE_ADMIN")`: Gán trực tiếp, không thêm tiền tố.
    - Kiểm tra:
        - `hasRole("ADMIN")` hoạt động với cả hai.
        - `hasAuthority("ROLE_ADMIN")` chỉ hoạt động với `authorities("ROLE_ADMIN")`.

---

### 8. Thiết lập chính sách **độ mạnh mật khẩu** và kiểm tra “pwned passwords” ở đâu trong luồng login/đổi mật khẩu?
- **Chính sách độ mạnh**:
    - Dùng validator:
      ```java
      @Component
      public class PasswordValidator implements ConstraintValidator<StrongPassword, String> {
          @Override
          public boolean isValid(String password, ConstraintValidatorContext context) {
              return password != null && password.length() >= 8 && password.matches(".*[A-Z].*");
          }
      }
      ```
- **Kiểm tra “pwned passwords”**:
    - Gọi API như Have I Been Pwned trong service đổi mật khẩu:
      ```java
      @Service
      public class PasswordService {
          public void changePassword(String username, String newPassword) {
              // Kiểm tra độ mạnh
              if (!passwordValidator.isValid(newPassword)) {
                  throw new IllegalArgumentException("Password too weak");
              }
              // Kiểm tra pwned
              if (pwnedApi.isPwned(newPassword)) {
                  throw new IllegalArgumentException("Password has been compromised");
              }
              // Lưu mật khẩu
          }
      }
      ```
- **Nơi đặt**:
    - Trong `PasswordService` khi xử lý đổi mật khẩu.
    - Trong `AuthenticationProvider` tùy chỉnh khi login.

---

