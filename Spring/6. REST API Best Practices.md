# 1) Thiết kế & cấu trúc REST API

1. Thế nào là **resource** trong REST? Cách đặt tên URI theo danh từ số nhiều (ví dụ `/users/{id}`) và khi nào nên có **sub-resource** (ví dụ `/orders/{id}/items`)?
2. So sánh hành vi **GET/POST/PUT/PATCH/DELETE** về tính **safe**, **idempotent**. Khi nào dùng PUT vs PATCH?
3. ⚠️ Gài: Tại sao `POST /users/{id}` thường là thiết kế tệ? Trình bày phương án đúng cho “tạo user có id do server cấp”.
4. Quy ước **versioning**: path (`/v1`), header, query — trade-off từng cách, khi nào nên “sunset” một version?
5. Thiết kế **quan hệ** giữa resources: trả **link** (HATEOAS nhẹ) vs trả **embedded**; khi nào chỉ nên trả `id`?
6. Phân trang/sắp xếp/lọc: đề xuất tham số chuẩn (`page`, `size`, `sort`, `q`), giới hạn tối đa `size`, chống DoS.
7. Quy tắc chuẩn hóa **định dạng ngày giờ, tiền tệ**: ISO 8601, số thập phân; tránh kiểu mơ hồ time zone.
8. Chuẩn **request-id / correlation-id** trong header để trace qua nhiều service — vì sao nên có?
9. ⚠️ Gài: Cần export **CSV**: bạn đặt endpoint và content negotiation như thế nào để vẫn tuân thủ REST?
10. Tài liệu hóa: yêu cầu tối thiểu của **OpenAPI** (định nghĩa schema, examples, error responses).

# 2) HTTP Status Codes (ánh xạ đúng & tinh gọn)

1. Khi **tạo** resource thành công, nên trả mã gì và kèm header nào? Khác biệt 200 vs **201**.
2. Khi **xóa** resource idempotent (xóa nhiều lần cũng như nhau) trả mã gì hợp lý?
3. ⚠️ Gài: Truy vấn rỗng (không có item nào) với **GET /resources** nên trả 200 với mảng rỗng hay 404? Vì sao?
4. Phân biệt **400** (bad request) vs **422** (unprocessable entity) trong validate dữ liệu.
5. Phân biệt **401** vs **403** với ví dụ cụ thể; khi nào dùng **407** (proxy auth)?
6. Tài nguyên di chuyển: khi nào trả **301/308** vs **302/307**? Ảnh hưởng tới idempotency.
7. **409 Conflict** dùng cho các tình huống nào (duplicate, state conflict, optimistic locking)?
8. **429 Too Many Requests**: nên trả thêm header gì (rate limit, retry-after)?
9. ⚠️ Gài: Khi upload thành công nhưng xử lý hậu kỳ vẫn chạy nền, nên trả status nào hợp lý? (gợi ý 202)
10. **5xx** khi nào được phép trả ra? Rủi ro lạm dụng 500 che lỗi 4xx hợp lệ.

# 3) Error Handling & Error Model

1. Tiêu chí của một **error response** tốt: trường tối thiểu nên có (code nội bộ, message, fields lỗi, correlationId, timestamp, docs link).
2. So sánh error model **tự thiết kế** với **RFC 7807 Problem Details** (`application/problem+json`). Khi nào nên dùng mỗi loại?
3. Chuẩn hóa **mã lỗi nội bộ** (domain-specific) tách biệt với HTTP status — lợi ích cho client.
4. ⚠️ Gài: Có nên trả **stack trace**/chi tiết SQL ra ngoài? Trình bày chính sách “leak-proof” nhưng vẫn hỗ trợ debug.
5. Trả lỗi **multi-field validation** (nhiều trường sai cùng lúc) cần cấu trúc payload ra sao?
6. Phân biệt **business error** (ví dụ “số dư không đủ”) với **validation error** (format email sai). Trả status & body khác nhau?
7. i18n thông điệp lỗi: server nên trả **message key** hay **message đã dịch**? Trade-off.
8. Idempotency & retries: cách thiết kế lỗi **transient** (503/504) vs **permanent** (4xx) để client biết chiến lược retry.
9. Logging & correlation: log gì ở server khi xảy ra lỗi để khớp với `X-Correlation-Id` client gửi lên?
10. ⚠️ Gài: Khi upstream timeout, bạn bọc lỗi thành 500 hay 504? Cách bảo toàn ngữ nghĩa HTTP.

# 4) Tối ưu response & caching

1. Khi nào dùng **ETag** vs `Last-Modified`? Trình bày flow với **If-None-Match** → **304 Not Modified**.
2. **Cache-Control** (public, private, no-store, max-age, s-maxage) áp dụng cho tài nguyên nào?
3. Compression (gzip/br) & pagination lớn: các **anti-pattern** thường gặp (nén hai lần, stream không đóng…).
4. ⚠️ Gài: Trả **206 Partial Content** cho tải tệp lớn — yêu cầu header nào từ client?
5. **Conditional requests** cho PUT/PATCH để chống overwrite (If-Match với ETag) — vì sao quan trọng?

# 5) Idempotency, concurrency & consistency

1. Idempotency key cho **POST** (tạo đơn hàng, thanh toán) — cơ chế, lưu ở đâu, timeout?
2. **Optimistic locking**: cách trình bày conflict cho client (409 và lỗi chi tiết).
3. ⚠️ Gài: Client gửi cùng một request hai lần, server đã tạo resource — server nên trả response gì lần thứ hai?
4. Đảm bảo **at-least-once** vs **exactly-once** trong bối cảnh API + hàng đợi — vai trò của idempotency key.
5. Hợp đồng **partial update** bằng PATCH + JSON Merge Patch/JSON Patch — tiêu chí lựa chọn, rủi ro.

# 6) Bảo mật (nhẹ) & giới hạn tốc độ

1. Các header bảo mật cơ bản cần có trong response (CORS, `X-Content-Type-Options`, `X-Frame-Options`/`CSP`).
2. **CORS**: chiến lược allow-list origin & phương thức; tránh `*` cho credentialed requests.
3. **Rate limiting** & **throttling**: vị trí thực thi (API gateway vs service), contract lỗi khi vượt ngưỡng.
4. ⚠️ Gài: API công khai nhưng có endpoint “admin-only” — bạn truyền thông chính sách rate/role thế nào trong OpenAPI?

# 7) ControllerAdvice & ExceptionHandler (xử lý exception toàn cục)

1. Sự khác nhau giữa `@ExceptionHandler` trong **controller cụ thể** và `@RestControllerAdvice`/`@ControllerAdvice` toàn cục.
2. Cơ chế chọn **handler phù hợp** khi có nhiều `@ExceptionHandler` bắt cùng kiểu. `@Order` ảnh hưởng ra sao?
3. Mapping exception → HTTP status: dùng `@ResponseStatus`, ném `ResponseStatusException`, hay trả `ResponseEntity` — khi nào chọn cách nào?
4. ⚠️ Gài: Vì sao handler **không chạy** khi exception bị **catch** ở dưới và không ném lên? Cách thiết kế để vẫn có error model chuẩn hóa.
5. Kết hợp **validation** (JSR 380) với advice: gom `MethodArgumentNotValidException` thành payload thống nhất.
6. Dòng chảy log lỗi: log ở advice hay ở filter/interceptor? Tránh double-logging.
7. Trả error response nhất quán cho **sync** và **async** (Callable/DeferredResult) — cần lưu ý gì?
8. Truyền `correlationId`/`traceId` vào error response từ advice như thế nào?
9. ⚠️ Gài: Vì sao `@ControllerAdvice` không bắt lỗi của **WebFlux** hoặc **filter** tự viết? Phạm vi tác dụng.
10. Test `@ControllerAdvice`: chiến lược viết **integration test** cho mapping lỗi chuẩn (MockMvc/WebTestClient).

# 8) Mini case (thực chiến 2–5 phút mỗi câu)

1. Thiết kế API **tạo đơn hàng** đảm bảo idempotent: nêu contract header, status 201/200, và error khi key trùng nhưng payload khác.
2. Xây error model theo **Problem Details** cho validate thất bại: body mẫu, cách nhét `invalid-params`.
3. Chuẩn hóa pagination cho toàn hệ thống: quyết định tên tham số, status khi trang vượt quá giới hạn, và links `first/prev/next/last`.
4. Thiết kế retry/backoff phía client với lỗi 503/504; server hỗ trợ header gì để client thông minh hơn.
5. Ánh xạ exception domain (ví dụ `InsufficientBalanceException`) sang HTTP code & body; đảm bảo **không lộ** thông tin nhạy cảm.
6. Sửa API cũ: trước trả 200 cho tạo mới, giờ muốn đúng chuẩn 201 + `Location`. Kế hoạch **backward compatible** và timeline deprecate.
7. Sự cố: client báo đôi lúc nhận 200 body rỗng khi conditional GET. Hãy nêu checklist kiểm tra ETag/If-None-Match/304.
