# 1) IoC & DI (Inversion of Control, Dependency Injection)

1. IoC là gì? So sánh IoC với Service Locator (ưu/nhược, khi nào chọn cái nào).
2. DI là gì? DI giúp giảm **coupling** như thế nào?
3. Các kiểu DI (constructor/setter/field) khác nhau ở điểm nào về: tính bất biến, testability, vòng đời phụ thuộc?
4. Khi một dependency là **bắt buộc** vs **tùy chọn**, bạn thiết kế constructor/setter như thế nào?
5. ⚠️ Gài: Vì sao field injection bị xem là “mùi” trong thiết kế? Hệ quả đối với unit test, bất biến, và refactor?
6. Khi có **nhiều bean cùng type**, Spring chọn bean nào để inject? Vai trò của `@Primary`, `@Qualifier`?
7. DI cho **collection** (List/Map/Set) hoạt động ra sao? Sắp xếp thứ tự các bean trong List như thế nào?
8. DI các bean **theo tên** vs **theo type**: khi nào bị xung đột?
9. DI với **generic type** (ví dụ `List<Foo>` vs `List<Bar>`) Spring phân giải như thế nào?
10. DI chu kỳ (circular dependency) là gì? Phát hiện & xử lý thế nào? Trường hợp nào setter injection giúp được?
11. ⚠️ Gài: `@Lazy` đặt ở đâu để phá vòng lặp A↔B? Đặt sai chỗ có tác dụng không?
12. Khác nhau giữa `@Autowired` và `@Inject` (JSR-330)? Ưu/nhược khi dùng mỗi cái?

# 2) IoC Container, Bean, BeanFactory, ApplicationContext

1. Bean là gì? “Bean definition” khác “bean instance” ở điểm nào?
2. BeanFactory vs ApplicationContext: điểm khác biệt chức năng (AOP, event, i18n, ResourceLoader…)?
3. Vòng đời ApplicationContext: `refresh()`, `close()`, đăng ký shutdown hook, khi nào nên gọi?
4. ⚠️ Gài: Vì sao **tự gọi** `new` để tạo đối tượng thay vì để container quản lý là anti-pattern trong Spring?
5. Parent/child context dùng khi nào? Tác động đến việc tìm và override bean?
6. `getBean()` theo tên vs theo type: rủi ro, khi nào ném `NoSuchBeanDefinitionException` hay `NoUniqueBeanDefinitionException`?
7. `FactoryBean` khác `BeanFactory` thế nào? Lấy **chính FactoryBean** thì dùng cú pháp gì?
8. Bean definition nguồn từ đâu: XML, Java Config, Component scan? Ưu/nhược mỗi cách?
9. Khi nào nên dùng `Environment`/`PropertySources` trong context? Ảnh hưởng tới tạo bean?
10. ⚠️ Gài: Vì sao gọi `ApplicationContext` như **global singleton** từ class tiện ích là code smell?
11. Resource loading (`classpath:` vs `file:` vs URL) qua context hoạt động thế nào?
12. Event trong ApplicationContext (publish/listen) áp dụng vào DI/khởi tạo như thế nào?

# 3) Các cách inject dependency: constructor, setter, field

1. Khi nào ưu tiên **constructor injection**? Liên hệ nguyên tắc bất biến và required dependencies.
2. Setter injection thích hợp cho kiểu phụ thuộc nào? Lợi/hại về trạng thái đối tượng?
3. Field injection: vì sao cộng đồng ít khuyến nghị? Ảnh hưởng tới DI framework khác, test, và mocking?
4. ⚠️ Gài: Class có **nhiều constructor**, Spring chọn cái nào? Có cần `@Autowired` ở constructor không? (Boot vs Core)
5. Bài tập: Viết class có dependency bắt buộc + optional. Bạn định nghĩa constructor/setter/`Optional<T>` sao cho rõ ràng?
6. Dùng Lombok `@RequiredArgsConstructor` + `final` fields có lợi gì so với setter injection?
7. Inject **primitive/value** bằng `@Value` có rủi ro gì (SpEL, default, conversion)?
8. Inject **bean theo điều kiện** (`@ConditionalOnProperty`, `@Profile`) phối hợp với constructor injection thế nào?
9. ⚠️ Gài: DI vòng tròn A↔B với **constructor injection** thường thất bại. Chiến lược thay thế?
10. `required=false` trong `@Autowired` trên setter/field: tác động gì tới NPE?
11. Inject **lazy** cho bean nặng tài nguyên: `ObjectProvider<T>`/`Provider<T>` dùng ra sao?
12. Khi viết **integration test**, bạn thay field injection bằng constructor injection có lợi gì?

# 4) @Component, @Service, @Repository, @Controller & Component Scan

1. Sự khác nhau thực chất giữa `@Component`, `@Service`, `@Repository`, `@Controller` là gì? (nghĩa ngữ nghĩa vs kỹ thuật).
2. ⚠️ Gài: `@Repository` kích hoạt **exception translation** như thế nào? Khi nào **không** hoạt động?
3. Component scan tìm bean theo **base package** ra sao? Mặc định của `@SpringBootApplication` là gì?
4. Tại sao các class nên đặt **cùng hoặc dưới** package của main application?
5. Include/Exclude filter trong `@ComponentScan` dùng khi nào? Ví dụ loại trừ bean test stub.
6. Custom stereotype: tạo annotation meta-annotated với `@Component` để gộp common annotations – khi nào hữu ích?
7. ⚠️ Gài: Vì sao class annotated đúng mà **không được scan**? (module khác, không nằm trong base package, không có `@ComponentScan`, cấu hình bị ghi đè…)
8. Ảnh hưởng của `proxyBeanMethods` trong `@Configuration` (full vs lite, gọi method @Bean lồng nhau).
9. `@Controller` vs `@RestController`: khác biệt và hậu quả khi gắn nhầm?
10. Khi có cả `@ComponentScan` và `@EnableJpaRepositories`/`@EntityScan`, phạm vi scan giao nhau thế nào?
11. Bean trùng tên khi scan & khai báo `@Bean` thủ công: Spring xử lý ưu tiên ra sao?
12. Bài tập: Cho sơ đồ packages, hãy chọn basePackages và filters để chỉ scan đúng các lớp cần thiết.

# 5) Bean Lifecycle (tạo, khởi tạo, hủy)

1. Liệt kê **các bước** lifecycle: instantiate → populate properties → \*Aware → BPP `postProcessBeforeInitialization` → init → BPP `postProcessAfterInitialization` → sử dụng → destroy.
2. Vai trò các `*Aware` interfaces (`BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware`…)? Khi nào dùng là hợp lý?
3. BeanPostProcessor là gì? Viết ví dụ use-case thực tế (logging, validation, proxy hóa).
4. ⚠️ Gài: Thứ tự thực thi nhiều BPP (`@Order`), ảnh hưởng nếu thứ tự sai?
5. `SmartInitializingSingleton` làm gì? Khác `InitializingBean` ra sao?
6. `@DependsOn` dùng khi nào? Có nên lạm dụng để “sửa” vấn đề thứ tự?
7. Khởi tạo **eager vs lazy** khác nhau thế nào? Ảnh hưởng tới time-to-first-request?
8. ⚠️ Gài: Prototype scope có được gọi destroy phase không? Vì sao nhiều người hiểu nhầm?
9. Interaction giữa lifecycle và AOP proxy: `@PostConstruct` chạy trên proxy hay target? Hệ quả là gì?
10. Truyền tham số cấu hình từ `Environment`/`PropertySources` vào lifecycle như thế nào?
11. Exception trong init/destroy dẫn tới điều gì? Context có **fail fast** không?
12. Bài tập: Hãy sắp xếp đúng thứ tự gọi khi có cả: `*Aware` → BPP → `@PostConstruct` → `afterPropertiesSet()` → `initMethod`.

# 6) @PostConstruct, @PreDestroy, InitializingBean, DisposableBean

1. So sánh `@PostConstruct` với `InitializingBean#afterPropertiesSet()` và `initMethod` cấu hình trong `@Bean`. Ưu/nhược từng cách.
2. Thứ tự **chính xác** lúc khởi tạo: constructor → DI → `@PostConstruct` → `afterPropertiesSet()` → custom initMethod.
3. Thứ tự **chính xác** lúc hủy: `@PreDestroy` → `DisposableBean#destroy()` → custom destroyMethod.
4. ⚠️ Gài: Khi bean là **prototype**, `@PreDestroy` có chạy không? Nếu không, muốn chạy thì làm sao?
5. `@PostConstruct` nên (hoặc không nên) làm gì? Ví dụ: mở connection nặng vs validate cấu hình.
6. Nếu `@PostConstruct` ném exception, chuyện gì xảy ra với context?
7. Sự khác nhau khi đặt `@PostConstruct` trên **proxy class** vs **target class**? (JDK dynamic proxy vs CGLIB)
8. Dùng `DisposableBean` khi nào thay vì `@PreDestroy`?
9. ⚠️ Gài: Annotate `@PostConstruct` vào **private method** có chạy không? Vào **static method** thì sao?
10. Có thể gọi thủ công `afterPropertiesSet()` không? Tác hại?
11. Ảnh hưởng của `@Lazy` lên thời điểm chạy `@PostConstruct`?
12. Bài tập: Cho code bean mở connection trong `@PostConstruct` và đóng trong `@PreDestroy`. Hãy nêu rủi ro khi deploy nhiều instance và đề xuất cải tiến.

# 7) Scope của Bean: singleton, prototype, request, session

1. Mặc định scope là gì? Vì sao **stateless singleton** là mẫu khuyến nghị?
2. Khi nào dùng prototype? Rủi ro nếu inject prototype vào singleton?
3. ⚠️ Gài: Inject prototype vào singleton **không** tạo instance mới mỗi lần dùng—tại sao? Giải pháp: `ObjectFactory<T>`/`Provider<T>`/scoped proxy?
4. Request/session scope hoạt động trong **web context** ra sao? Cần gì để hoạt động trong test hoặc non-web?
5. `@Scope(proxyMode=...)` làm gì? Ảnh hưởng tới equals/hashCode/toString?
6. Thread-safety của singleton: cách tránh state shared gây race?
7. ⚠️ Gài: Sử dụng bean request-scope trong service singleton (được gọi từ thread pool) có an toàn không?
8. Custom scope (ví dụ “tenant” scope): cách xây dựng và use-case.
9. Sự khác biệt lifecycle destroy giữa singleton vs request/session? Ai thu dọn tài nguyên khi session hết hạn?
10. Dùng scope kết hợp `@Async`/`@Scheduled`: tình huống “leak” hoặc context không hợp lệ?
11. Bài tập: Thiết kế dịch vụ upload sử dụng bean theo request để chứa metadata, đảm bảo không rò rỉ sang request khác.
12. Khi test với `@DirtiesContext`/`@TestConfiguration`, scope ảnh hưởng thế nào tới hiệu năng test?

---

## Mini case (thực chiến ngắn)

1. Bạn có 2 service A và B (constructor injection) phụ thuộc lẫn nhau. Hãy liệt kê 3 cách thiết kế để loại bỏ vòng lặp mà vẫn giữ bất biến tốt.
2. Một bean `ImageCache` rất nặng, cold start 3s. Nêu 3 cách giảm **TTS** (time to serve): lazy, pre-warm ở `SmartInitializingSingleton`, hay split module… Phân tích trade-off.
3. Bạn cần một bean `RequestContext` chỉ sống theo request nhưng service là singleton. Hãy cho 2 cách inject hợp lệ và rủi ro của mỗi cách.
4. Một `@Repository` không translate `SQLException` sang `DataAccessException`. Hãy liệt kê các nguyên nhân có thể và cách xác minh.
5. Prototype bean mở file handler trong `@PostConstruct`, không bao giờ đóng. Mô tả hậu quả và chiến lược đóng tài nguyên đúng chỗ.