## 1) AOP (Aspect-Oriented Programming)

1. AOP là gì? Vấn đề nào AOP giải quyết mà OOP thuần túy khó xử lý?
2. Các thành phần chính trong AOP: **Aspect**, **Join Point**, **Advice**, **Pointcut**, **Weaving** — mô tả ngắn gọn từng khái niệm.
3. ⚠️ Gài: `Join Point` trong Spring AOP có giới hạn ở đâu so với AspectJ đầy đủ?
4. Sự khác nhau giữa các loại Advice: `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`, `@Around`.
5. `@Around` khác gì so với kết hợp `@Before` + `@After`? Khi nào nên dùng `@Around` thay vì nhiều advice nhỏ?
6. ⚠️ Gài: Trong `@Around`, nếu không gọi `proceed()` thì chuyện gì xảy ra?
7. Cách định nghĩa Pointcut: biểu thức execution(), within(), this(), target(), annotation() — ví dụ cho từng loại.
8. ⚠️ Gài: Vì sao AOP trong Spring **mặc định** chỉ áp dụng cho method public? Làm sao để áp dụng cho method protected/private?
9. Proxy trong Spring AOP: **JDK Dynamic Proxy** vs **CGLIB** — điều kiện lựa chọn và ưu/nhược từng loại.
10. Self-invocation (method gọi method cùng class) có kích hoạt AOP không? Cách khắc phục?
11. Trường hợp điển hình sử dụng AOP trong Spring: logging, transaction, caching, security check.
12. Tác động của AOP tới performance và debugging — cách giảm thiểu overhead.

---

## 2) Validation (Hibernate Validator, custom annotation)

1. Bean Validation (JSR 380) là gì? Spring tích hợp nó như thế nào?
2. Các annotation chuẩn phổ biến: `@NotNull`, `@NotBlank`, `@Size`, `@Min`, `@Max`, `@Email`, `@Pattern`, `@Past`, `@Future`. Khác nhau giữa `@NotNull` và `@NotEmpty`/`@NotBlank`.
3. ⚠️ Gài: `@NotNull` trên primitive type có tác dụng không? Vì sao?
4. `@Valid` vs `@Validated`: khác biệt, use case, hỗ trợ validation group.
5. Validation group: dùng để tách validate theo bối cảnh (create/update). Cách khai báo và áp dụng.
6. Nested validation: validate object lồng nhau và collection bằng cách nào?
7. BindingResult: vai trò, yêu cầu về **vị trí** trong tham số method controller.
8. Tùy biến thông báo lỗi: sử dụng `messages.properties`, key, i18n.
9. ⚠️ Gài: Khi có cả `messages.properties` và `ValidationMessages.properties`, Spring ưu tiên file nào?
10. Tạo annotation validate tùy chỉnh: cấu trúc annotation, interface `ConstraintValidator`, generic type hỗ trợ.
11. Cách inject bean/service vào `ConstraintValidator` để validate logic phức tạp (ví dụ kiểm tra email unique).
12. Validation ở tầng service vs tầng controller: khác biệt và khi nào nên áp dụng ở mỗi tầng.
13. Kỹ thuật tránh over-posting/mass-assignment khi binding request → entity.

---

## 3) Logging (SLF4J, Logback, cấu hình log level)

1. SLF4J là gì? Tại sao Spring khuyến nghị dùng SLF4J thay vì gọi thẳng Logback/Log4j API?
2. Kiến trúc logging trong Spring Boot: SLF4J → binding (Logback mặc định).
3. Cấu hình log level (`TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`) và phạm vi (root logger vs package-specific).
4. ⚠️ Gài: Nếu set `logging.level.root=ERROR` nhưng vẫn thấy log INFO của Hibernate, nguyên nhân?
5. Cấu hình logging trong `application.properties`/`application.yml` và file `logback-spring.xml`.
6. Khác nhau giữa `logback.xml` và `logback-spring.xml`: vì sao nên dùng bản có `-spring`.
7. Thêm appender mới (console, file, rolling file, async appender) và cấu hình rotation (max size, max history).
8. ⚠️ Gài: Vì sao log file không tạo dù cấu hình đúng appender file? Kể ít nhất 2 nguyên nhân.
9. Thực hành logging tốt: log message template (`logger.info("User {} logged in", username)`) vs string concatenation.
10. Logging exception đúng cách: `logger.error("...", ex)` vs `logger.error("..."+ex.getMessage())` — khác biệt.
11. Mối quan hệ giữa logging và performance: lazy evaluation, avoid unnecessary logging khi level thấp.
12. Sử dụng `MDC` (Mapped Diagnostic Context) để gắn requestId/userId vào log, truyền qua nhiều thread.
13. ⚠️ Gài: Trong môi trường multi-thread, MDC có tự động truyền context không? Làm sao để giữ trace id khi dùng `@Async`?

---

## 4) Mini case (thực chiến 2–5 phút mỗi câu)

1. Dùng AOP để log thời gian thực thi method service, bao gồm cả input/output, nhưng không log password. Thiết kế Pointcut và Advice.
2. Viết annotation `@ValidPassword` kiểm tra mật khẩu >= 8 ký tự, có số, chữ hoa, chữ thường, ký tự đặc biệt.
3. Tùy biến Logback để tách log lỗi và log truy cập HTTP vào 2 file riêng biệt.
4. Xử lý case: log quá nhiều DEBUG trên prod gây đầy ổ đĩa — trình bày giải pháp ngắn hạn và dài hạn.
5. Sử dụng validation group cho API `/users` — group Create yêu cầu tất cả field, group Update chỉ yêu cầu id và field thay đổi.
6. Tích hợp MDC vào logging để trace một request qua nhiều microservice.
7. Viết AOP `@Around` advice để thực hiện retry logic khi method ném exception tạm thời.
8. Debug tình huống: annotation `@CustomValidator` không chạy khi gọi service từ service khác — chỉ ra nguyên nhân và cách fix.
