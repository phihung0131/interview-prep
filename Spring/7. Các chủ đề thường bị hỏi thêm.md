## 1) AOP (Aspect-Oriented Programming)

### 1. AOP là gì? Vấn đề nào AOP giải quyết mà OOP thuần túy khó xử lý?
- **AOP là gì**:
    - Aspect-Oriented Programming là một mô hình lập trình tách biệt các **cross-cutting concerns** (như logging, transaction, security) khỏi logic nghiệp vụ chính.
    - Sử dụng **aspects** để áp dụng logic bổ sung tại các điểm cụ thể trong mã nguồn mà không cần sửa đổi code chính.
- **Vấn đề giải quyết**:
    - OOP khó xử lý các chức năng lặp lại ở nhiều nơi (như logging mỗi method, kiểm tra quyền).
    - AOP giảm code lặp, tăng tính module hóa, dễ bảo trì.
    - Ví dụ: Thay vì thêm `logger.info()` vào từng method, AOP dùng `@Before` để log tự động.

---

### 2. Các thành phần chính trong AOP: **Aspect**, **Join Point**, **Advice**, **Pointcut**, **Weaving** — mô tả ngắn gọn từng khái niệm.
- **Aspect**: Class chứa logic cross-cutting (như logging, security). Được đánh dấu `@Aspect`.
- **Join Point**: Điểm trong chương trình nơi aspect có thể can thiệp (như gọi method, ném exception).
- **Advice**: Hành động mà aspect thực hiện tại join point (như `@Before`, `@After`).
- **Pointcut**: Biểu thức xác định join point nào sẽ áp dụng advice (như `execution(* com.example.*.*(..))`).
- **Weaving**: Quá trình tích hợp aspect vào mã nguồn, thực hiện tại compile-time, load-time, hoặc runtime.

---

### 3. ⚠️ Gài: `Join Point` trong Spring AOP có giới hạn ở đâu so với AspectJ đầy đủ?
- **Giới hạn trong Spring AOP**:
    - Chỉ hỗ trợ **method execution** (không hỗ trợ field access, constructor, hoặc exception như AspectJ).
    - Chỉ áp dụng trên **Spring-managed beans** (không áp dụng cho object thông thường).
    - Dùng proxy (JDK/CGLIB), không weave trực tiếp bytecode như AspectJ.
- **AspectJ**:
    - Hỗ trợ mọi join point (method, field, constructor).
    - Weave trực tiếp vào bytecode, không cần proxy.
- **Giải pháp**:
    - Dùng AspectJ với Spring qua `@EnableAspectJAutoProxy` hoặc Load-Time Weaving.

---

### 4. Sự khác nhau giữa các loại Advice: `@Before`, `@After`, `@AfterReturning`, `@AfterThrowing`, `@Around`.
- **`@Before`**: Chạy trước khi method được gọi.
    - Ví dụ: Log input trước khi xử lý.
- **`@After`**: Chạy sau khi method hoàn thành (bất kể thành công hay lỗi).
    - Ví dụ: Cleanup tài nguyên.
- **`@AfterReturning`**: Chạy khi method trả về thành công.
    - Ví dụ: Log kết quả.
- **`@AfterThrowing`**: Chạy khi method ném exception.
    - Ví dụ: Log lỗi.
- **`@Around`**: Bao quanh method, kiểm soát cả trước/sau, có thể thay đổi input/output.
    - Ví dụ: Đo thời gian thực thi.
- **Ví dụ**:
  ```java
  @Aspect
  public class LoggingAspect {
      @Before("execution(* com.example.*.*(..))")
      public void logBefore() { System.out.println("Before method"); }
      @After("execution(* com.example.*.*(..))")
      public void logAfter() { System.out.println("After method"); }
      @AfterReturning(pointcut = "execution(* com.example.*.*(..))", returning = "result")
      public void logAfterReturning(Object result) { System.out.println("Result: " + result); }
      @AfterThrowing(pointcut = "execution(* com.example.*.*(..))", throwing = "ex")
      public void logAfterThrowing(Exception ex) { System.out.println("Exception: " + ex); }
      @Around("execution(* com.example.*.*(..))")
      public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
          long start = System.currentTimeMillis();
          Object result = joinPoint.proceed();
          System.out.println("Execution time: " + (System.currentTimeMillis() - start));
          return result;
      }
  }
  ```

---

### 5. `@Around` khác gì so với kết hợp `@Before` + `@After`? Khi nào nên dùng `@Around` thay vì nhiều advice nhỏ?
- **Khác biệt**:
    - `@Around` kiểm soát toàn bộ flow (trước, sau, quyết định có gọi method không qua `proceed()`).
    - `@Before` + `@After` không kiểm soát được flow, không thể thay đổi kết quả hoặc bỏ qua method.
- **Khi dùng `@Around`**:
    - Cần thay đổi input/output.
    - Cần retry logic hoặc điều kiện bỏ qua method.
    - Đo thời gian thực thi hoặc transaction phức tạp.
- **Ví dụ**:
  ```java
  @Around("execution(* com.example.*.*(..))")
  public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
      // Trước
      System.out.println("Before: " + joinPoint.getSignature());
      Object result = joinPoint.proceed(); // Gọi method
      // Sau
      System.out.println("After: " + result);
      return result;
  }
  ```

---

### 6. ⚠️ Gài: Trong `@Around`, nếu không gọi `proceed()` thì chuyện gì xảy ra?
- **Hậu quả**:
    - Method gốc không được gọi, logic nghiệp vụ bị bỏ qua.
    - Trả về null hoặc giá trị do `@Around` cung cấp.
    - Có thể gây lỗi logic (như transaction không commit).
- **Ví dụ**:
  ```java
  @Around("execution(* com.example.*.*(..))")
  public Object aroundAdvice(ProceedingJoinPoint joinPoint) {
      // Không gọi proceed()
      return "Skipped"; // Method gốc không chạy
  }
  ```
- **Giải pháp**:
    - Luôn gọi `joinPoint.proceed()` trừ khi cố ý bỏ qua.

---

### 7. Cách định nghĩa Pointcut: biểu thức execution(), within(), this(), target(), annotation() — ví dụ cho từng loại.
- **`execution()`**: Khớp method theo chữ ký.
    - Ví dụ: `execution(public * com.example.service.*.*(..))` — tất cả method public trong package `service`.
- **`within()`**: Khớp tất cả method trong class/package.
    - Ví dụ: `within(com.example.service.*)` — tất cả method trong package `service`.
- **`this()`**: Khớp dựa trên type của proxy.
    - Ví dụ: `this(com.example.MyService)` — method trong bean implement `MyService`.
- **`target()`**: Khớp dựa trên type của object đích.
    - Ví dụ: `target(com.example.MyServiceImpl)` — method trong class `MyServiceImpl`.
- **`annotation()`**: Khớp method có annotation cụ thể.
    - Ví dụ: `@annotation(com.example.MyAnnotation)` — method có `@MyAnnotation`.

---

### 8. ⚠️ Gài: Vì sao AOP trong Spring **mặc định** chỉ áp dụng cho method public? Làm sao để áp dụng cho method protected/private?
- **Tại sao chỉ public**:
    - Spring AOP dùng proxy (JDK/CGLIB), chỉ proxy được method public.
    - JDK Dynamic Proxy yêu cầu interface, chỉ hỗ trợ public method.
    - CGLIB proxy class, nhưng Spring giới hạn public để đảm bảo an toàn.
- **Áp dụng protected/private**:
    - Dùng **AspectJ** với Load-Time Weaving hoặc Compile-Time Weaving:
      ```xml
      <dependency>
          <groupId>org.aspectj</groupId>
          <artifactId>aspectjweaver</artifactId>
      </dependency>
      ```
      ```java
      @Configuration
      @EnableAspectJAutoProxy
      public class AspectJConfig {}
      ```
    - Lưu ý: AspectJ phức tạp hơn, cần cấu hình thêm.

---

### 9. Proxy trong Spring AOP: **JDK Dynamic Proxy** vs **CGLIB** — điều kiện lựa chọn và ưu/nhược từng loại.
- **JDK Dynamic Proxy**:
    - **Điều kiện**: Bean implement interface.
    - **Ưu**: Nhẹ, chỉ proxy method trong interface.
    - **Nhược**: Không proxy được method ngoài interface hoặc class không có interface.
- **CGLIB**:
    - **Điều kiện**: Bean không implement interface hoặc cần proxy toàn bộ class.
    - **Ưu**: Proxy cả class, hỗ trợ method non-public (với AspectJ).
    - **Nhược**: Nặng hơn, có thể gây xung đột với class final.
- **Lựa chọn**:
    - Spring mặc định dùng JDK Dynamic Proxy nếu bean có interface, ngược lại dùng CGLIB.
    - Bật CGLIB: `@EnableAspectJAutoProxy(proxyTargetClass = true)`.

---

### 10. Self-invocation (method gọi method cùng class) có kích hoạt AOP không? Cách khắc phục?
- **Không kích hoạt**:
    - AOP dựa trên proxy, self-invocation (gọi method trong cùng class) không qua proxy.
    - Ví dụ:
      ```java
      @Service
      public class MyService {
          @Transactional
          public void methodA() { methodB(); }
          @Transactional
          public void methodB() {}
      }
      ```
        - `methodB()` không kích hoạt `@Transactional` nếu gọi từ `methodA`.
- **Khắc phục**:
    - Tách method sang service khác:
      ```java
      @Service
      public class MyService {
          @Autowired
          private OtherService otherService;
          @Transactional
          public void methodA() { otherService.methodB(); }
      }
      @Service
      public class OtherService {
          @Transactional
          public void methodB() {}
      }
      ```
    - Dùng `AopContext.currentProxy()`:
      ```java
      ((MyService) AopContext.currentProxy()).methodB();
      ```
        - Cần bật `@EnableAspectJAutoProxy(exposeProxy = true)`.

---

### 11. Trường hợp điển hình sử dụng AOP trong Spring: logging, transaction, caching, security check.
- **Logging**:
    - Log input/output hoặc thời gian thực thi.
    - Ví dụ: `@Around` để đo thời gian.
- **Transaction**:
    - Dùng `@Transactional` để quản lý transaction tự động.
    - Ví dụ: `@Transactional` trên method service.
- **Caching**:
    - Dùng `@Cacheable`, `@CachePut`, `@CacheEvict` để cache kết quả.
    - Ví dụ: `@Cacheable("users")` trên method `findById`.
- **Security Check**:
    - Dùng `@PreAuthorize`, `@PostAuthorize` để kiểm tra quyền.
    - Ví dụ: `@PreAuthorize("hasRole('ADMIN')")` trên method admin.

---

### 12. Tác động của AOP tới performance và debugging — cách giảm thiểu overhead.
- **Tác động**:
    - **Performance**: Proxy thêm overhead, đặc biệt với `@Around` hoặc nhiều aspect.
    - **Debugging**: Stack trace phức tạp, khó tìm nguồn gốc lỗi.
- **Giảm thiểu**:
    - **Performance**:
        - Hạn chế pointcut quá rộng (như `execution(* *.*(..))`).
        - Dùng `@Around` chỉ khi cần kiểm soát flow.
        - Tắt proxy khi không cần: `@EnableAspectJAutoProxy(proxyTargetClass = false)`.
    - **Debugging**:
        - Log chi tiết trong advice với `JoinPoint.getSignature()`.
        - Dùng `MDC` để trace.

---

## 2) Validation (Hibernate Validator, Custom Annotation)

### 1. Bean Validation (JSR 380) là gì? Spring tích hợp nó như thế nào?
- **Bean Validation (JSR 380)**:
    - Tiêu chuẩn Java để validate dữ liệu (như `@NotNull`, `@Size`).
    - Hibernate Validator là triển khai phổ biến.
- **Spring tích hợp**:
    - Spring Boot auto-configures `LocalValidatorFactoryBean`.
    - Dùng `@Valid` hoặc `@Validated` trong controller/service.
    - Ví dụ:
      ```java
      @RestController
      public class UserController {
          @PostMapping("/users")
          public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO dto) {
              return ResponseEntity.ok(userService.create(dto));
          }
      }
      ```

---

### 2. Các annotation chuẩn phổ biến: `@NotNull`, `@NotBlank`, `@Size`, `@Min`, `@Max`, `@Email`, `@Pattern`, `@Past`, `@Future`. Khác nhau giữa `@NotNull` và `@NotEmpty`/`@NotBlank`.
- **Annotation**:
    - **`@NotNull`**: Không được null.
    - **`@NotBlank`**: Không null, không rỗng, không chỉ chứa khoảng trắng (cho String).
    - **`@NotEmpty`**: Không null, không rỗng (cho String, Collection, Map, Array).
    - **`@Size`**: Độ dài trong khoảng (min, max).
    - **`@Min`/`@Max`**: Giá trị số trong khoảng.
    - **`@Email`**: Chuỗi đúng định dạng email.
    - **`@Pattern`**: Chuỗi khớp regex.
    - **`@Past`/`@Future`**: Ngày giờ trước/sau hiện tại.
- **Khác biệt**:
    - **`@NotNull`**: Chỉ kiểm tra null (như `String name = null`).
    - **`@NotEmpty`**: Không null, không rỗng (như `""` hoặc `[]`).
    - **`@NotBlank`**: Không null, không rỗng, không chỉ chứa khoảng trắng (như `" "`).

---

### 3. ⚠️ Gài: `@NotNull` trên primitive type có tác dụng không? Vì sao?
- **Không tác dụng**:
    - Primitive type (như `int`, `long`) không thể null, nên `@NotNull` vô nghĩa.
    - `@NotNull` chỉ áp dụng cho reference type (như `Integer`, `String`).
- **Giải pháp**:
    - Dùng wrapper class (như `Integer` thay `int`).
    - Ví dụ:
      ```java
      public class UserDTO {
          @NotNull
          private Integer age; // OK
          @NotNull
          private int id; // Vô nghĩa
      }
      ```

---

### 4. `@Valid` vs `@Validated`: khác biệt, use case, hỗ trợ validation group.
- **`@Valid`**:
    - Kích hoạt validation JSR 380, không hỗ trợ group.
    - Dùng trong: Controller để validate DTO.
    - Ví dụ:
      ```java
      @PostMapping("/users")
      public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO dto) {}
      ```
- **`@Validated`**:
    - Hỗ trợ validation group, dùng trong service hoặc controller.
    - Ví dụ:
      ```java
      @Service
      @Validated
      public class UserService {
          @Validated(OnCreate.class)
          public void createUser(@Valid UserDTO dto) {}
      }
      ```
- **Use case**:
    - `@Valid`: Validate DTO trong controller.
    - `@Validated`: Validate với group hoặc trong service.

---

### 5. Validation group: dùng để tách validate theo bối cảnh (create/update). Cách khai báo và áp dụng.
- **Khai báo**:
  ```java
  public interface OnCreate {}
  public interface OnUpdate {}
  public class UserDTO {
      @NotNull(groups = OnUpdate.class)
      private Long id;
      @NotBlank(groups = {OnCreate.class, OnUpdate.class})
      private String name;
  }
  ```
- **Áp dụng**:
  ```java
  @RestController
  public class UserController {
      @PostMapping("/users")
      public ResponseEntity<User> createUser(@Validated(OnCreate.class) @RequestBody UserDTO dto) {
          return ResponseEntity.ok(userService.create(dto));
      }
      @PutMapping("/users/{id}")
      public ResponseEntity<User> updateUser(@Validated(OnUpdate.class) @RequestBody UserDTO dto) {
          return ResponseEntity.ok(userService.update(dto));
      }
  }
  ```

---

### 6. Nested validation: validate object lồng nhau và collection bằng cách nào?
- **Validate object lồng nhau**:
    - Dùng `@Valid` trên field:
      ```java
      public class OrderDTO {
          @Valid
          private UserDTO user;
          @Valid
          private List<ItemDTO> items;
      }
      ```
- **Validate collection**:
    - `@Valid` áp dụng cho từng phần tử trong collection.
    - Ví dụ:
      ```java
      public class ItemDTO {
          @NotNull
          private Long productId;
      }
      ```

---

### 7. BindingResult: vai trò, yêu cầu về **vị trí** trong tham số method controller.
- **Vai trò**:
    - Lưu kết quả validation (lỗi, field lỗi).
    - Dùng để trả response tùy chỉnh thay vì ném exception.
- **Vị trí**:
    - Phải đặt **ngay sau** tham số `@Valid`/`@Validated`.
    - Ví dụ:
      ```java
      @PostMapping("/users")
      public ResponseEntity<?> createUser(@Valid @RequestBody UserDTO dto, BindingResult result) {
          if (result.hasErrors()) {
              Map<String, String> errors = result.getFieldErrors().stream()
                  .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));
              return ResponseEntity.badRequest().body(errors);
          }
          return ResponseEntity.ok(userService.create(dto));
      }
      ```

---

### 8. Tùy biến thông báo lỗi: sử dụng `messages.properties`, key, i18n.
- **Cấu hình**:
    - Tạo `messages.properties`:
      ```properties
      NotNull.userDTO.name=Name cannot be null
      Size.userDTO.email=Email must be between {min} and {max} characters
      ```
    - Cấu hình i18n:
      ```java
      @Bean
      public MessageSource messageSource() {
          ReloadableResourceBundleMessageSource source = new ReloadableResourceBundleMessageSource();
          source.setBasename("classpath:messages");
          source.setDefaultEncoding("UTF-8");
          return source;
      }
      ```
- **Sử dụng**:
    - Annotation dùng key:
      ```java
      public class UserDTO {
          @NotNull(message = "{NotNull.userDTO.name}")
          private String name;
      }
      ```

---

### 9. ⚠️ Gài: Khi có cả `messages.properties` và `ValidationMessages.properties`, Spring ưu tiên file nào?
- **Ưu tiên**:
    - `messages.properties` được ưu tiên nếu được cấu hình trong `MessageSource`.
    - `ValidationMessages.properties` là fallback của Hibernate Validator.
- **Giải pháp**:
    - Cấu hình `MessageSource` để dùng `messages.properties`:
      ```java
      @Bean
      public MessageSource messageSource() {
          ReloadableResourceBundleMessageSource source = new ReloadableResourceBundleMessageSource();
          source.setBasename("classpath:messages");
          return source;
      }
      ```

---

### 10. Tạo annotation validate tùy chỉnh: cấu trúc annotation, interface `ConstraintValidator`, generic type hỗ trợ.
- **Annotation**:
  ```java
  @Target({ElementType.FIELD, ElementType.PARAMETER})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = ValidPasswordValidator.class)
  public @interface ValidPassword {
      String message() default "Invalid password format";
      Class<?>[] groups() default {};
      Class<? extends Payload>[] payload() default {};
  }
  ```
- **ConstraintValidator**:
  ```java
  public class ValidPasswordValidator implements ConstraintValidator<ValidPassword, String> {
      @Override
      public boolean isValid(String password, ConstraintValidatorContext context) {
          return password != null && password.matches("^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@#$]).{8,}$");
      }
  }
  ```

---

### 11. Cách inject bean/service vào `ConstraintValidator` để validate logic phức tạp (ví dụ kiểm tra email unique).
- **Cơ chế**:
    - Inject qua `@Autowired` trong `ConstraintValidator`.
    - Ví dụ:
      ```java
      public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
          @Autowired
          private UserRepository userRepository;
          @Override
          public boolean isValid(String email, ConstraintValidatorContext context) {
              return email != null && !userRepository.existsByEmail(email);
          }
      }
      ```
- **Cấu hình**:
    - Đảm bảo `ConstraintValidator` là Spring bean:
      ```java
      @Component
      public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {...}
      ```

---

### 12. Validation ở tầng service vs tầng controller: khác biệt và khi nào nên áp dụng ở mỗi tầng.
- **Tầng controller**:
    - Validate DTO từ request.
    - Dùng `@Valid`/`@Validated` để kiểm tra format, cú pháp.
    - Ví dụ: Kiểm tra `@NotNull`, `@Email` trên `UserDTO`.
- **Tầng service**:
    - Validate logic nghiệp vụ (như kiểm tra email unique).
    - Dùng `@Validated` hoặc logic tùy chỉnh.
    - Ví dụ: Kiểm tra số dư trước khi thanh toán.
- **Lựa chọn**:
    - Controller: Lỗi cú pháp, định dạng.
    - Service: Lỗi logic nghiệp vụ.

---

### 13. Kỹ thuật tránh over-posting/mass-assignment khi binding request → entity.
- **Over-posting**:
    - Client gửi field không mong muốn (như `isAdmin=true` trong `POST /users`).
- **Kỹ thuật tránh**:
    - Dùng DTO riêng biệt thay vì bind trực tiếp vào entity:
      ```java
      public class UserDTO {
          @NotBlank
          private String name;
          @Email
          private String email;
          // Không có field isAdmin
      }
      ```
    - Dùng `@JsonIgnoreProperties` hoặc `@JsonProperty(access = Access.READ_ONLY)`:
      ```java
      @JsonIgnoreProperties({"isAdmin"})
      public class UserEntity {
          private String name;
          private String email;
          private boolean isAdmin;
      }
      ```
    - Validate DTO với `@Valid`.

---

## 3) Logging (SLF4J, Logback, Cấu hình Log Level)

### 1. SLF4J là gì? Tại sao Spring khuyến nghị dùng SLF4J thay vì gọi thẳng Logback/Log4j API?
- **SLF4J**:
    - Simple Logging Facade for Java, là facade cung cấp API chung cho logging.
    - Không triển khai logging, chỉ chuyển hướng đến backend (như Logback, Log4j).
- **Tại sao dùng SLF4J**:
    - Linh hoạt: Dễ đổi backend (như từ Logback sang Log4j) mà không đổi code.
    - Tính tương thích: Spring Boot tích hợp SLF4J với Logback mặc định.
    - Tránh lock-in vào một logging framework.

---

### 2. Kiến trúc logging trong Spring Boot: SLF4J → binding (Logback mặc định).
- **Kiến trúc**:
    - **SLF4J**: API facade, gọi từ code ứng dụng.
    - **Binding**: SLF4J chuyển hướng đến Logback (mặc định trong Spring Boot).
    - **Logback**: Xử lý log (console, file, rotation).
- **Ví dụ**:
  ```java
  private static final Logger log = LoggerFactory.getLogger(MyService.class);
  log.info("Processing user: {}", userId);
  ```

---

### 3. Cấu hình log level (`TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`) và phạm vi (root logger vs package-specific).
- **Log level**:
    - `TRACE`: Chi tiết nhất (debug sâu).
    - `DEBUG`: Thông tin debug.
    - `INFO`: Thông tin thông thường.
    - `WARN`: Cảnh báo.
    - `ERROR`: Lỗi nghiêm trọng.
- **Cấu hình**:
    - **Root logger**:
      ```properties
      logging.level.root=INFO
      ```
    - **Package-specific**:
      ```properties
      logging.level.com.example.service=DEBUG
      logging.level.org.hibernate=ERROR
      ```

---

### 4. ⚠️ Gài: Nếu set `logging.level.root=ERROR` nhưng vẫn thấy log INFO của Hibernate, nguyên nhân?
- **Nguyên nhân**:
    - Hibernate dùng logger riêng (như `org.hibernate`), không bị ảnh hưởng bởi `root`.
    - Cấu hình cụ thể cho `org.hibernate` ghi đè `root`.
- **Giải pháp**:
    - Đặt level cho Hibernate:
      ```properties
      logging.level.org.hibernate=ERROR
      ```

---

### 5. Cấu hình logging trong `application.properties`/`application.yml` và file `logback-spring.xml`.
- **application.properties**:
  ```properties
  logging.level.root=INFO
  logging.level.com.example=DEBUG
  logging.file.name=logs/app.log
  ```
- **application.yml**:
  ```yaml
  logging:
    level:
      root: INFO
      com.example: DEBUG
    file:
      name: logs/app.log
  ```
- **logback-spring.xml**:
  ```xml
  <configuration>
      <appender name="FILE" class="ch.qos.logback.core.FileAppender">
          <file>logs/app.log</file>
          <encoder>
              <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
          </encoder>
      </appender>
      <root level="INFO">
          <appender-ref ref="FILE"/>
      </root>
  </configuration>
  ```

---

### 6. Khác nhau giữa `logback.xml` và `logback-spring.xml`: vì sao nên dùng bản có `-spring`.
- **Khác biệt**:
    - **`logback.xml`**: File cấu hình chuẩn của Logback, tải trước Spring context.
    - **`logback-spring.xml`**: Tích hợp Spring, hỗ trợ profile, property substitution.
- **Tại sao dùng `logback-spring.xml`**:
    - Hỗ trợ Spring profile:
      ```xml
      <springProfile name="dev">
          <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"/>
      </springProfile>
      ```
    - Dùng Spring properties: `${spring.application.name}`.

---

### 7. Thêm appender mới (console, file, rolling file, async appender) và cấu hình rotation (max size, max history).
- **Cấu hình**:
  ```xml
  <configuration>
      <!-- Console Appender -->
      <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
          <encoder>
              <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %msg%n</pattern>
          </encoder>
      </appender>
      <!-- Rolling File Appender -->
      <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
          <file>logs/app.log</file>
          <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
              <fileNamePattern>logs/app.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
              <maxFileSize>10MB</maxFileSize>
              <maxHistory>30</maxHistory>
          </rollingPolicy>
          <encoder>
              <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %msg%n</pattern>
          </encoder>
      </appender>
      <!-- Async Appender -->
      <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
          <appender-ref ref="FILE"/>
      </appender>
      <root level="INFO">
          <appender-ref ref="CONSOLE"/>
          <appender-ref ref="ASYNC"/>
      </root>
  </configuration>
  ```

---

### 8. ⚠️ Gài: Vì sao log file không tạo dù cấu hình đúng appender file? Kể ít nhất 2 nguyên nhân.
- **Nguyên nhân**:
    1. **Quyền thư mục**: Server không có quyền ghi vào thư mục `logs/`.
    2. **File cấu hình sai**: Spring Boot không tìm thấy `logback-spring.xml` (như đặt sai tên hoặc classpath).
- **Giải pháp**:
    - Kiểm tra quyền: `chmod -R 755 logs/`.
    - Đảm bảo file nằm trong `src/main/resources/logback-spring.xml`.

---

### 9. Thực hành logging tốt: log message template (`logger.info("User {} logged in", username)`) vs string concatenation.
- **Template**:
  ```java
  logger.info("User {} logged in", username);
  ```
    - **Ưu**: Lazy evaluation, chỉ format nếu level đủ (như `INFO`).
    - **Nhược**: Cần chú ý số lượng tham số khớp.
- **Concatenation**:
  ```java
  logger.info("User " + username + " logged in");
  ```
    - **Nhược**: Luôn thực hiện concatenation, kể cả khi level thấp (như `DEBUG` khi root là `INFO`).

---

### 10. Logging exception đúng cách: `logger.error("...", ex)` vs `logger.error("..."+ex.getMessage())` — khác biệt.
- **`logger.error("...", ex)`**:
    - Ghi cả stack trace, giúp debug.
    - Ví dụ:
      ```java
      logger.error("Failed to process user: {}", userId, ex);
      ```
- **`logger.error("..."+ex.getMessage())`**:
    - Chỉ ghi message, mất stack trace.
    - Nhược: Khó debug nguyên nhân gốc.
- **Khuyến nghị**: Dùng `logger.error("...", ex)`.

---

### 11. Mối quan hệ giữa logging và performance: lazy evaluation, avoid unnecessary logging khi level thấp.
- **Tác động performance**:
    - Logging tốn CPU/IO, đặc biệt với `DEBUG`/`TRACE`.
    - String concatenation gây overhead nếu level không đủ.
- **Giải pháp**:
    - Dùng template để lazy evaluation:
      ```java
      logger.debug("Data: {}", expensiveOperation());
      ```
    - Kiểm tra level trước:
      ```java
      if (logger.isDebugEnabled()) {
          logger.debug("Data: {}", expensiveOperation());
      }
      ```

---

### 12. Sử dụng `MDC` (Mapped Diagnostic Context) để gắn requestId/userId vào log, truyền qua nhiều thread.
- **Cơ chế**:
    - Gắn `MDC` trong filter:
      ```java
      @Component
      public class MDCFilter implements Filter {
          @Override
          public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
              MDC.put("requestId", UUID.randomUUID().toString());
              try {
                  chain.doFilter(request, response);
              } finally {
                  MDC.clear();
              }
          }
      }
      ```
- **Logback pattern**:
  ```xml
  <encoder>
      <pattern>%d{yyyy-MM-dd HH:mm:ss} %X{requestId} %-5level %msg%n</pattern>
  </encoder>
  ```

---

### 13. ⚠️ Gài: Trong môi trường multi-thread, MDC có tự động truyền context không? Làm sao để giữ trace id khi dùng `@Async`?
- **Không truyền tự động**:
    - `MDC` dùng `ThreadLocal`, không truyền sang thread mới (như `@Async`).
- **Giải pháp**:
    - Dùng `DelegatingSecurityContextExecutor` hoặc wrapper:
      ```java
      @Bean
      public TaskExecutor taskExecutor() {
          ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
          executor.setTaskDecorator(new MDCTaskDecorator());
          return executor;
      }
      public class MDCTaskDecorator implements TaskDecorator {
          @Override
          public Runnable decorate(Runnable runnable) {
              Map<String, String> context = MDC.getCopyOfContextMap();
              return () -> {
                  MDC.setContextMap(context != null ? context : new HashMap<>());
                  try {
                      runnable.run();
                  } finally {
                      MDC.clear();
                  }
              };
          }
      }
      ```

---

## 4) Mini Case (Thực chiến 2–5 phút mỗi câu)

### 1. Dùng AOP để log thời gian thực thi method service, bao gồm cả input/output, nhưng không log password. Thiết kế Pointcut và Advice.
- **Cấu hình**:
  ```java
  @Aspect
  @Component
  public class PerformanceLoggingAspect {
      private static final Logger log = LoggerFactory.getLogger(PerformanceLoggingAspect.class);
      @Pointcut("execution(* com.example.service.*.*(..))")
      public void serviceMethods() {}
      @Around("serviceMethods()")
      public Object logPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
          long start = System.currentTimeMillis();
          String methodName = joinPoint.getSignature().toShortString();
          Object[] args = Arrays.stream(joinPoint.getArgs())
              .map(arg -> arg instanceof PasswordDTO ? "[REDACTED]" : arg)
              .toArray();
          log.info("Entering {} with args: {}", methodName, args);
          try {
              Object result = joinPoint.proceed();
              log.info("Exiting {} with result: {}", methodName, result);
              log.info("Execution time: {} ms", System.currentTimeMillis() - start);
              return result;
          } catch (Throwable t) {
              log.error("Exception in {}: {}", methodName, t.getMessage(), t);
              throw t;
          }
      }
  }
  ```

---

### 2. Viết annotation `@ValidPassword` kiểm tra mật khẩu >= 8 ký tự, có số, chữ hoa, chữ thường, ký tự đặc biệt.
- **Annotation**:
  ```java
  @Target({ElementType.FIELD, ElementType.PARAMETER})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = ValidPasswordValidator.class)
  public @interface ValidPassword {
      String message() default "Password must be at least 8 characters, include uppercase, lowercase, digit, and special character";
      Class<?>[] groups() default {};
      Class<? extends Payload>[] payload() default {};
  }
  ```
- **Validator**:
  ```java
  public class ValidPasswordValidator implements ConstraintValidator<ValidPassword, String> {
      @Override
      public boolean isValid(String password, ConstraintValidatorContext context) {
          return password != null && password.matches("^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@#$]).{8,}$");
      }
  }
  ```

---

### 3. Tùy biến Logback để tách log lỗi và log truy cập HTTP vào 2 file riêng biệt.
- **logback-spring.xml**:
  ```xml
  <configuration>
      <!-- Access Log -->
      <appender name="ACCESS" class="ch.qos.logback.core.rolling.RollingFileAppender">
          <file>logs/access.log</file>
          <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
              <fileNamePattern>logs/access.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
              <maxFileSize>10MB</maxFileSize>
              <maxHistory>30</maxHistory>
          </rollingPolicy>
          <encoder>
              <pattern>%d{yyyy-MM-dd HH:mm:ss} %X{requestId} %msg%n</pattern>
          </encoder>
      </appender>
      <!-- Error Log -->
      <appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
          <file>logs/error.log</file>
          <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
              <level>ERROR</level>
          </filter>
          <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
              <fileNamePattern>logs/error.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
              <maxFileSize>10MB</maxFileSize>
              <maxHistory>30</maxHistory>
          </rollingPolicy>
          <encoder>
              <pattern>%d{yyyy-MM-dd HH:mm:ss} %X{requestId} %-5level %msg%n</pattern>
          </encoder>
      </appender>
      <logger name="com.example.access" level="INFO" additivity="false">
          <appender-ref ref="ACCESS"/>
      </logger>
      <root level="INFO">
          <appender-ref ref="ERROR"/>
      </root>
  </configuration>
  ```
- **Sử dụng**:
  ```java
  private static final Logger accessLog = LoggerFactory.getLogger("com.example.access");
  accessLog.info("Request: {}", request.getRequestURI());
  ```

---

### 4. Xử lý case: log quá nhiều DEBUG trên prod gây đầy ổ đĩa — trình bày giải pháp ngắn hạn và dài hạn.
- **Ngắn hạn**:
    - Đặt `logging.level.root=INFO` trong `application.properties`.
    - Xóa log cũ: `rm logs/*.log`.
- **Dài hạn**:
    - Cấu hình rolling file:
      ```xml
      <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
          <file>logs/app.log</file>
          <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
              <fileNamePattern>logs/app.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
              <maxFileSize>10MB</maxFileSize>
              <maxHistory>7</maxHistory>
          </rollingPolicy>
      </appender>
      ```
    - Tắt `DEBUG` cho package không cần:
      ```properties
      logging.level.org.hibernate=ERROR
      ```

---

### 5. Sử dụng validation group cho API `/users` — group Create yêu cầu tất cả field, group Update chỉ yêu cầu id và field thay đổi.
- **Khai báo**:
  ```java
  public interface OnCreate {}
  public interface OnUpdate {}
  public class UserDTO {
      @NotNull(groups = OnUpdate.class)
      private Long id;
      @NotBlank(groups = {OnCreate.class, OnUpdate.class})
      private String name;
      @Email(groups = OnCreate.class)
      private String email;
  }
  ```
- **Controller**:
  ```java
  @RestController
  public class UserController {
      @PostMapping("/users")
      public ResponseEntity<User> createUser(@Validated(OnCreate.class) @RequestBody UserDTO dto) {
          return ResponseEntity.ok(userService.create(dto));
      }
      @PutMapping("/users/{id}")
      public ResponseEntity<User> updateUser(@Validated(OnUpdate.class) @RequestBody UserDTO dto) {
          return ResponseEntity.ok(userService.update(dto));
      }
  }
  ```

---

### 6. Tích hợp MDC vào logging để trace một request qua nhiều microservice.
- **Cấu hình**:
  ```java
  @Component
  public class MDCFilter implements Filter {
      @Override
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
          String requestId = request.getHeader("X-Request-Id");
          if (requestId == null) requestId = UUID.randomUUID().toString();
          MDC.put("requestId", requestId);
          ((HttpServletResponse) response).setHeader("X-Request-Id", requestId);
          try {
              chain.doFilter(request, response);
          } finally {
              MDC.clear();
          }
      }
  }
  ```
- **Logback**:
  ```xml
  <encoder>
      <pattern>%d{yyyy-MM-dd HH:mm:ss} %X{requestId} %-5level %msg%n</pattern>
  </encoder>
  ```

---

### 7. Viết AOP `@Around` advice để thực hiện retry logic khi method ném exception tạm thời.
- **Cấu hình**:
  ```java
  @Aspect
  @Component
  public class RetryAspect {
      private static final Logger log = LoggerFactory.getLogger(RetryAspect.class);
      @Around("@annotation(com.example.Retry)")
      public Object retry(ProceedingJoinPoint joinPoint) throws Throwable {
          Retry retry = joinPoint.getTarget().getClass().getAnnotation(Retry.class);
          int maxAttempts = retry.value();
          for (int attempt = 1; attempt <= maxAttempts; attempt++) {
              try {
                  return joinPoint.proceed();
              } catch (TransientException ex) {
                  if (attempt == maxAttempts) throw ex;
                  log.warn("Retry attempt {}/{}", attempt, maxAttempts);
                  Thread.sleep(1000 * attempt); // Exponential backoff
              }
          }
          throw new IllegalStateException("Retry logic failed");
      }
  }
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.METHOD)
  public @interface Retry {
      int value() default 3;
  }
  ```

---

### 8. Debug tình huống: annotation `@CustomValidator` không chạy khi gọi service từ service khác — chỉ ra nguyên nhân và cách fix.
- **Nguyên nhân**:
    - `@Validated` dựa trên AOP proxy, không hoạt động với self-invocation.
    - Ví dụ:
      ```java
      @Service
      @Validated
      public class UserService {
          public void createUser(@Valid UserDTO dto) {
              validate(dto); // Không chạy @Valid
          }
          private void validate(@Valid UserDTO dto) {}
      }
      ```
- **Cách fix**:
    - Tách validate sang service khác:
      ```java
      @Service
      public class ValidationService {
          @Validated
          public void validate(@Valid UserDTO dto) {}
      }
      @Service
      public class UserService {
          @Autowired
          private ValidationService validationService;
          public void createUser(@Valid UserDTO dto) {
              validationService.validate(dto);
          }
      }
      ```
    - Hoặc dùng `AopContext.currentProxy()`:
      ```java
      ((UserService) AopContext.currentProxy()).validate(dto);
      ```

---

