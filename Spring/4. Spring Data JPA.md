# 1) ORM & Entity Mapping

### 1. `@Entity` yêu cầu tối thiểu những gì? Sự khác nhau giữa **entity** và **value object** trong JPA?
- **Yêu cầu tối thiểu của `@Entity`**:
    - Class phải được đánh dấu `@Entity`.
    - Có ít nhất một field được đánh dấu `@Id` (hoặc `@EmbeddedId`).
    - Có constructor không tham số (public hoặc protected).
    - Không phải `final` class, không có `final` field/method liên quan đến JPA.
- **Entity vs Value Object**:
    - **Entity**:
        - Đại diện cho một thực thể trong DB, có danh tính (identity) qua `@Id`.
        - Có lifecycle (transient, managed, detached, removed).
        - Ví dụ: `User` với `id`, `name`.
    - **Value Object**:
        - Không có danh tính, chỉ chứa dữ liệu.
        - Thường dùng để nhúng vào entity qua `@Embeddable`.
        - Ví dụ: `Address` (street, city) trong `User`.
    - **Khác biệt**:
        - Entity được quản lý bởi `EntityManager`, có khóa chính.
        - Value Object không độc lập, không có bảng riêng, được nhúng vào entity.

---

### 2. `@Table` dùng để làm gì? Khai báo `schema`, `uniqueConstraints`, `indexes` ở đâu và khi nào cần?
- **Tác dụng của `@Table`**:
    - Chỉ định bảng DB mà entity ánh xạ tới.
    - Thuộc tính:
        - `name`: Tên bảng (mặc định là tên class).
        - `schema`: Schema của bảng.
        - `uniqueConstraints`: Ràng buộc duy nhất trên cột.
        - `indexes`: Chỉ mục cho tối ưu truy vấn.
- **Khai báo**:
  ```java
  @Entity
  @Table(
      name = "users",
      schema = "public",
      uniqueConstraints = @UniqueConstraint(columnNames = {"email"}),
      indexes = @Index(name = "idx_user_name", columnList = "name")
  )
  public class User { ... }
  ```
- **Khi cần**:
    - Tên bảng khác tên class.
    - DB dùng schema cụ thể.
    - Cần unique constraint hoặc index không có trong DB schema.

---

### 3. `@Id` dùng **natural key** vs **surrogate key**: ưu/nhược từng cách?
- **Natural Key**:
    - Là giá trị có ý nghĩa nghiệp vụ (như `email`, `phone`).
    - **Ưu**:
        - Dễ hiểu, có ý nghĩa thực tế.
        - Tiết kiệm cột nếu đã tồn tại trong dữ liệu.
    - **Nhược**:
        - Có thể thay đổi (như email người dùng).
        - Khó đảm bảo tính duy nhất nếu nghiệp vụ phức tạp.
- **Surrogate Key**:
    - Là khóa nhân tạo (như `id` tự tăng).
    - **Ưu**:
        - Đảm bảo duy nhất, không thay đổi.
        - Hiệu quả khi làm khóa chính (index nhỏ gọn).
    - **Nhược**:
        - Thêm cột không có ý nghĩa nghiệp vụ.
        - Cần cơ chế sinh (sequence, identity).
- **Lựa chọn**:
    - Surrogate key thường được ưu tiên vì tính ổn định và hiệu năng.

---

### 4. `@GeneratedValue(strategy=…)`: so sánh `AUTO`, `IDENTITY`, `SEQUENCE`, `TABLE`; ảnh hưởng đến **batch insert** và `flush`.
- **Các chiến lược**:
    - **`AUTO`**: Hibernate tự chọn (thường là `SEQUENCE` cho Oracle/PostgreSQL, `IDENTITY` cho MySQL).
    - **`IDENTITY`**: DB tự tăng (như `AUTO_INCREMENT` trong MySQL).
    - **`SEQUENCE`**: Dùng sequence của DB (như PostgreSQL, Oracle).
    - **`TABLE`**: Dùng bảng riêng để lưu giá trị khóa chính.
- **So sánh**:
    - **AUTO**: Linh hoạt, nhưng phụ thuộc DB, khó dự đoán chiến lược.
    - **IDENTITY**: Đơn giản, nhưng không hỗ trợ batch insert tốt (Hibernate phải gọi DB ngay để lấy ID).
    - **SEQUENCE**: Hiệu quả cho batch insert (lấy ID trước), nhưng DB phải hỗ trợ sequence.
    - **TABLE**: Linh hoạt, nhưng chậm (truy cập bảng phụ), ít dùng.
- **Ảnh hưởng batch insert/flush**:
    - **IDENTITY**: Phải flush mỗi lần insert để lấy ID, phá vỡ batch.
    - **SEQUENCE**: Lấy nhiều ID trước, hỗ trợ batch tốt.
    - **TABLE**: Tương tự sequence, nhưng chậm hơn.
    - **AUTO**: Phụ thuộc vào DB, thường giống `IDENTITY` hoặc `SEQUENCE`.

---

### 5. ⚠️ Gài: Vì sao dùng `IDENTITY` trên MySQL thường làm **khó** batch insert của Hibernate?
- **Nguyên nhân**:
    - `IDENTITY` yêu cầu DB sinh ID (như `AUTO_INCREMENT`).
    - Hibernate phải insert từng record và flush ngay để lấy ID, không thể gom thành batch.
    - Điều này làm tăng số lần gọi DB, giảm hiệu năng.
- **Giải pháp**:
    - Dùng `SEQUENCE` nếu DB hỗ trợ (như PostgreSQL).
    - Tối ưu batch:
      ```java
      @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
      @SequenceGenerator(name = "user_seq", sequenceName = "user_seq", allocationSize = 50)
      ```
    - Hoặc dùng `TABLE` cho DB không hỗ trợ sequence.

---

### 6. Khóa tổng hợp: `@EmbeddedId` vs `@IdClass` khác gì, khi nào dùng mỗi cái?
- **`@EmbeddedId`**:
    - Dùng class nhúng (`@Embeddable`) để định nghĩa khóa chính:
      ```java
      @Embeddable
      public class OrderItemId implements Serializable {
          private Long orderId;
          private Long productId;
      }
      @Entity
      public class OrderItem {
          @EmbeddedId
          private OrderItemId id;
      }
      ```
    - **Ưu**: Rõ ràng, gộp khóa trong một object.
    - **Nhược**: Phức tạp khi truy vấn hoặc map.
- **`@IdClass`**:
    - Dùng class riêng để định nghĩa khóa:
      ```java
      public class OrderItemId implements Serializable {
          private Long orderId;
          private Long productId;
      }
      @Entity
      @IdClass(OrderItemId.class)
      public class OrderItem {
          @Id
          private Long orderId;
          @Id
          private Long productId;
      }
      ```
    - **Ưu**: Dễ truy vấn (dùng trực tiếp field).
    - **Nhược**: Lặp code, dễ nhầm lẫn.
- **Khi dùng**:
    - `@EmbeddedId`: Khi muốn nhóm khóa thành một object.
    - `@IdClass`: Khi cần truy vấn field riêng lẻ hoặc legacy code.

---

### 7. Quy tắc đặt `equals()`/`hashCode()` cho entity: rủi ro nếu dựa vào `id` chưa được gán? (trạng thái transient)
- **Quy tắc**:
    - Cả `equals()` và `hashCode()` phải dựa trên trường cố định (thường là `@Id`).
    - Phải nhất quán trong suốt lifecycle của entity.
    - Ví dụ:
      ```java
      @Override
      public boolean equals(Object o) {
          if (this == o) return true;
          if (!(o instanceof User)) return false;
          User user = (User) o;
          return Objects.equals(id, user.id);
      }
      @Override
      public int hashCode() {
          return Objects.hash(id);
      }
      ```
- **Rủi ro nếu dựa vào ID chưa gán**:
    - Trong trạng thái transient (entity mới, chưa persist), `id` thường là `null`.
    - Gây lỗi khi so sánh hoặc thêm vào collection (như `Set`), vì `hashCode` thay đổi sau khi persist.
- **Giải pháp**:
    - Dùng natural key (nếu có) hoặc UUID (sinh trước khi persist).
    - Hoặc không dựa vào `id`, mà dùng tất cả field bất biến.

---

### 8. `@Column` (nullable, length, precision/scale) và **khác biệt** giữa ràng buộc ở **DB** vs **validation** ở ứng dụng.
- **`@Column`**:
    - **nullable**: Chỉ định cột có thể null (mặc định `true`).
    - **length**: Độ dài tối đa cho `String` (mặc định 255).
    - **precision/scale**: Cho số thập phân (như `BigDecimal`).
    - Ví dụ:
      ```java
      @Column(nullable = false, length = 100, precision = 10, scale = 2)
      private String name;
      private BigDecimal price;
      ```
- **DB vs Validation**:
    - **DB (ràng buộc schema)**:
        - Áp dụng bởi `@Column`, `@Table`, hoặc DDL script.
        - Đảm bảo tính toàn vẹn dữ liệu ở tầng DB.
        - Ví dụ: `NOT NULL` constraint.
    - **Validation (ứng dụng)**:
        - Dùng Jakarta Validation (`@NotNull`, `@Size`, `@DecimalMin`).
        - Kiểm tra trước khi lưu vào DB, trả lỗi sớm.
        - Ví dụ:
          ```java
          @NotNull
          @Size(max = 100)
          private String name;
          ```
    - **Khác biệt**:
        - DB: Ràng buộc cứng, không thể bypass.
        - Validation: Linh hoạt, có thể tùy chỉnh logic, nhưng cần trigger (như `@Valid`).

---

### 9. Ánh xạ enum: `@Enumerated(STRING|ORDINAL)` — rủi ro khi đổi thứ tự enum?
- **`@Enumerated`**:
    - **STRING**: Lưu tên enum (như `ACTIVE`).
    - **ORDINAL**: Lưu vị trí enum (0, 1, …).
    - Ví dụ:
      ```java
      @Enumerated(EnumType.STRING)
      private Status status;
      public enum Status { ACTIVE, INACTIVE }
      ```
- **Rủi ro khi đổi thứ tự**:
    - **ORDINAL**:
        - Thay đổi thứ tự enum (thêm/xóa giá trị) làm sai dữ liệu DB.
        - Ví dụ: `ACTIVE=0`, `INACTIVE=1` → thêm `PENDING=0` khiến `ACTIVE` thành `1`.
    - **STRING**: Không bị ảnh hưởng bởi thứ tự, nhưng tốn bộ nhớ hơn.
- **Lựa chọn**:
    - Dùng `STRING` để an toàn, trừ khi cần tối ưu lưu trữ.

---

### 10. `@Converter` (AttributeConverter) dùng khi nào? Ví dụ mã hóa/giải mã, booleans đặc biệt, kiểu tiền tệ.
- **Dùng khi**:
    - Ánh xạ kiểu Java không được JPA hỗ trợ trực tiếp sang cột DB.
    - Tùy biến logic ánh xạ (như mã hóa, format).
- **Ví dụ** (mã hóa JSON):
  ```java
  @Converter
  public class JsonConverter implements AttributeConverter<Map<String, Object>, String> {
      private final ObjectMapper mapper = new ObjectMapper();
      @Override
      public String convertToDatabaseColumn(Map<String, Object> attribute) {
          return mapper.writeValueAsString(attribute);
      }
      @Override
      public Map<String, Object> convertToEntityAttribute(String dbData) {
          return mapper.readValue(dbData, Map.class);
      }
  }
  @Entity
  public class User {
      @Convert(converter = JsonConverter.class)
      private Map<String, Object> metadata;
  }
  ```
- **Use case**:
    - Booleans đặc biệt (Y/N → true/false).
    - Tiền tệ (Money → DECIMAL với format cụ thể).
    - Mã hóa (encrypt/decrypt dữ liệu nhạy cảm).

---

### 11. `@Lob`, `@Basic(fetch=LAZY)` với BLOB/CLOB: khi nào LAZY **không thực sự lazy** (bytecode enhancement/proxy)?
- **`@Lob`**:
    - Lưu dữ liệu lớn (BLOB: binary, CLOB: text).
    - Ví dụ:
      ```java
      @Lob
      private byte[] image;
      ```
- **`@Basic(fetch=LAZY)`**:
    - Chỉ định lazy loading cho field cơ bản.
- **Khi LAZY không thực sự lazy**:
    - Hibernate không bật **bytecode enhancement**:
        - Cần cấu hình plugin `hibernate-enhance-maven-plugin`.
    - DB không hỗ trợ lazy loading cho BLOB/CLOB (như MySQL).
    - Proxy bị truy cập trong transaction, gây load dữ liệu.
- **Giải pháp**:
    - Bật bytecode enhancement.
    - Tách BLOB/CLOB thành entity riêng với `@OneToOne(fetch=LAZY)`.

---

### 12. One-to-One: `@OneToOne` với `mappedBy` và `@JoinColumn` — bên nào là **owning side**? Khi cần `@MapsId`?
- **Owning side**:
    - Bên có `@JoinColumn` là owning side, chứa khóa ngoại trong DB.
    - Bên có `mappedBy` là inverse side, không quản lý quan hệ.
    - Ví dụ:
      ```java
      @Entity
      public class User {
          @OneToOne
          @JoinColumn(name = "profile_id")
          private Profile profile;
      }
      @Entity
      public class Profile {
          @OneToOne(mappedBy = "profile")
          private User user;
      }
      ```
- **`@MapsId`**:
    - Dùng khi khóa chính của entity con trùng với khóa ngoại của entity cha.
    - Ví dụ:
      ```java
      @Entity
      public class UserProfile {
          @Id
          private Long id;
          @OneToOne
          @MapsId
          @JoinColumn(name = "id")
          private User user;
      }
      ```
    - Dùng khi muốn đồng bộ ID giữa hai bảng.

---

### 13. Many-to-One và One-to-Many hai chiều: xác định **owning side** ở đâu? Hậu quả nếu đặt sai `mappedBy`?
- **Owning side**:
    - **Many-to-One**: Luôn là owning side, chứa `@JoinColumn`.
    - **One-to-Many**: Là inverse side, có `mappedBy`.
    - Ví dụ:
      ```java
      @Entity
      public class Order {
          @OneToMany(mappedBy = "order")
          private List<OrderItem> items;
      }
      @Entity
      public class OrderItem {
          @ManyToOne
          @JoinColumn(name = "order_id")
          private Order order;
      }
      ```
- **Hậu quả sai `mappedBy`**:
    - Hibernate không biết bên nào quản lý quan hệ, gây lỗi khi lưu.
    - Dữ liệu không đồng bộ (như khóa ngoại null).

---

### 14. ⚠️ Gài: Vì sao `List` trong `@OneToMany` mặc định **không giữ thứ tự**? Dùng `@OrderBy` vs `@OrderColumn` khác nhau thế nào?
- **Vì sao không giữ thứ tự**:
    - JPA không đảm bảo thứ tự của `List` trong `@OneToMany` vì nó ánh xạ sang bảng liên kết, không lưu thông tin thứ tự.
- **`@OrderBy`**:
    - Sắp xếp dựa trên cột của entity con (như `orderBy="createdAt DESC"`).
    - Không lưu thứ tự vào DB, chỉ áp dụng khi load.
    - Ví dụ:
      ```java
      @OneToMany(mappedBy = "order")
      @OrderBy("createdAt DESC")
      private List<OrderItem> items;
      ```
- **`@OrderColumn`**:
    - Thêm cột trong bảng con để lưu thứ tự (như `index`).
    - Lưu thứ tự vào DB, đảm bảo cố định.
    - Ví dụ:
      ```java
      @OneToMany(mappedBy = "order")
      @OrderColumn(name = "item_index")
      private List<OrderItem> items;
      ```
- **Khác biệt**:
    - `@OrderBy`: Dựa trên thuộc tính, không thay đổi DB.
    - `@OrderColumn`: Lưu thứ tự vào DB, cần cột phụ.

---

### 15. Many-to-Many: khi nào **không** nên dùng trực tiếp và nên thay bằng **entity trung gian** (association entity) để chứa metadata?
- **Không nên dùng trực tiếp**:
    - Quan hệ `@ManyToMany` chỉ lưu khóa chính, không chứa metadata (như ngày tạo, trạng thái).
    - Khó mở rộng nếu cần thêm thuộc tính.
- **Dùng entity trung gian**:
    - Tạo entity riêng cho bảng liên kết:
      ```java
      @Entity
      public class UserRole {
          @EmbeddedId
          private UserRoleId id;
          @ManyToOne
          @MapsId("userId")
          private User user;
          @ManyToOne
          @MapsId("roleId")
          private Role role;
          private LocalDateTime assignedAt;
      }
      ```
- **Khi dùng**:
    - Cần metadata (như thời gian, trạng thái).
    - Quan hệ phức tạp, cần validation hoặc logic.

---

### 16. Cascade: `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, `DETACH`, `ALL` — ý nghĩa từng loại; **không** nên gắn `REMOVE` ở đâu?
- **Ý nghĩa**:
    - **`PERSIST`**: Lưu entity con khi lưu entity cha.
    - **`MERGE`**: Cập nhật entity con khi cập nhật entity cha.
    - **`REMOVE`**: Xóa entity con khi xóa entity cha.
    - **`REFRESH`**: Làm mới entity con từ DB.
    - **`DETACH`**: Detach entity con khỏi persistence context.
    - **`ALL`**: Áp dụng tất cả cascade.
- **Không nên gắn `REMOVE`**:
    - Trên `@ManyToMany` hoặc `@OneToMany` khi entity con có thể được tham chiếu bởi entity khác.
    - Ví dụ: Xóa `User` không nên tự động xóa `Role` (dùng chung).

---

### 17. `orphanRemoval=true` khác `cascade=REMOVE` thế nào? Ví dụ xóa phần tử khỏi collection.
- **Khác biệt**:
    - **`cascade=REMOVE`**: Xóa entity con khi entity cha bị xóa.
    - **`orphanRemoval=true`**: Xóa entity con khi nó bị xóa khỏi collection của entity cha.
- **Ví dụ**:
  ```java
  @Entity
  public class Order {
      @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
      private List<OrderItem> items;
  }
  ```
    - Xóa `Order` → xóa tất cả `OrderItem` (`cascade=REMOVE`).
    - Xóa `OrderItem` khỏi `items` → xóa khỏi DB (`orphanRemoval=true`).

---

### 18. Fetch type: mặc định của `@ManyToOne` và `@OneToMany` là gì? Khi nào EAGER gây **N+1** và cách tránh?
- **Mặc định**:
    - **`@ManyToOne`**: `EAGER` (load ngay lập tức).
    - **`@OneToMany`**: `LAZY` (load khi truy cập).
- **EAGER gây N+1**:
    - Khi load nhiều entity, mỗi entity thực hiện truy vấn riêng cho quan hệ `@ManyToOne`.
    - Ví dụ: Load 100 `Order`, mỗi `Order` load `Customer` → 1 + 100 queries.
- **Cách tránh**:
    1. Đổi thành `LAZY`:
       ```java
       @ManyToOne(fetch = FetchType.LAZY)
       private Customer customer;
       ```
    2. Dùng `JOIN FETCH` trong JPQL:
       ```java
       @Query("SELECT o FROM Order o JOIN FETCH o.customer")
       List<Order> findAllOrders();
       ```
    3. Dùng `@EntityGraph`:
       ```java
       @EntityGraph(attributePaths = "customer")
       List<Order> findAll();
       ```

---

### 19. ⚠️ Gài: Nguyên nhân và 3 cách xử lý `LazyInitializationException` **không** dùng Open Session In View.
- **Nguyên nhân**:
    - Truy cập thuộc tính `LAZY` ngoài transaction (entity detached).
- **Cách xử lý**:
    1. **Fetch trong transaction**:
       ```java
       @Transactional
       public Order getOrder(Long id) {
           Order order = repository.findById(id).orElseThrow();
           order.getItems().size(); // Load LAZY
           return order;
       }
       ```
    2. **JOIN FETCH**:
       ```java
       @Query("SELECT o FROM Order o JOIN FETCH o.items WHERE o.id = :id")
       Order findOrderWithItems(@Param("id") Long id);
       ```
    3. **@EntityGraph**:
       ```java
       @EntityGraph(attributePaths = "items")
       Optional<Order> findById(Long id);
       ```

---

### 20. Kế thừa: `@Inheritance(SINGLE_TABLE|JOINED|TABLE_PER_CLASS)` — ưu/nhược về hiệu năng, normal hóa, tính linh hoạt.
- **`SINGLE_TABLE`**:
    - Lưu tất cả vào một bảng, dùng cột phân biệt (discriminator).
    - **Ưu**: Hiệu năng cao (ít join), đơn giản.
    - **Nhược**: Không normalize, cột không dùng để null.
- **`JOINED`**:
    - Bảng riêng cho class cha và con, join bằng khóa chính.
    - **Ưu**: Normalize tốt, tiết kiệm không gian.
    - **Nhược**: Hiệu năng kém do join nhiều bảng.
- **`TABLE_PER_CLASS`**:
    - Mỗi class một bảng, lặp lại cột của class cha.
    - **Ưu**: Truy vấn đơn giản, không cần join.
    - **Nhược**: Không normalize, khó maintain.
- **Lựa chọn**:
    - `SINGLE_TABLE`: Dự án nhỏ, ít class con.
    - `JOINED`: Cần normalize, quan hệ phức tạp.
    - `TABLE_PER_CLASS`: Hiếm dùng, phù hợp khi class con độc lập.

---

### 21. **Lifecycle state**: transient, managed, detached, removed — hành vi của `persist`, `merge`, `remove`, `flush`.
- **State**:
    - **Transient**: Entity mới, chưa liên kết với DB.
    - **Managed**: Đã được persist, thuộc persistence context.
    - **Detached**: Từng managed, nhưng context đóng.
    - **Removed**: Đánh dấu để xóa, chưa commit.
- **Hành vi**:
    - **`persist`**: Chuyển transient → managed, lưu vào DB khi flush.
    - **`merge`**: Cập nhật detached → managed, đồng bộ với DB.
    - **`remove`**: Chuyển managed → removed, xóa khi flush.
    - **`flush`**: Đồng bộ persistence context với DB.

---

### 22. `@Version` (optimistic locking): khi nào ném `OptimisticLockException`, xử lý/retry ra sao?
- **`@Version`**:
    - Dùng để kiểm soát đồng thời (optimistic locking).
    - Ví dụ:
      ```java
      @Entity
      public class Product {
          @Id
          private Long id;
          @Version
          private int version;
      }
      ```
- **Khi ném `OptimisticLockException`**:
    - Hai transaction cập nhật cùng record, version không khớp.
- **Xử lý/retry**:
    - Dùng `@Transactional` với retry logic:
      ```java
      @Transactional
      public void updateProduct(Long id, ProductDTO dto) {
          for (int i = 0; i < 3; i++) {
              try {
                  Product product = repository.findById(id).orElseThrow();
                  product.setName(dto.getName());
                  repository.save(product);
                  return;
              } catch (OptimisticLockException e) {
                  // Retry with backoff
                  Thread.sleep(100 * i);
              }
          }
          throw new RuntimeException("Retry failed");
      }
      ```

---

### 23. `@SecondaryTable`, `@ElementCollection`: khi nào hợp lý hơn tách thành entity riêng?
- **`@SecondaryTable`**:
    - Lưu dữ liệu vào bảng phụ, ánh xạ vào cùng entity.
    - Ví dụ:
      ```java
      @Entity
      @SecondaryTable(name = "user_details", pkJoinColumns = @PrimaryKeyJoinColumn(name = "user_id"))
      public class User {
          @Id
          private Long id;
          @Column(table = "user_details")
          private String bio;
      }
      ```
    - Dùng khi dữ liệu phụ thuộc chặt chẽ, không cần quan hệ riêng.
- **`@ElementCollection`**:
    - Lưu collection đơn giản (như `List<String>`).
    - Ví dụ:
      ```java
      @ElementCollection
      private List<String> tags;
      ```
    - Dùng cho dữ liệu đơn giản, không cần lifecycle riêng.
- **So với entity riêng**:
    - `@SecondaryTable`/`@ElementCollection`: Đơn giản, nhưng ít linh hoạt.
    - Entity riêng: Phù hợp khi cần quan hệ, validation, hoặc lifecycle độc lập.

---

### 24. Tương thích timezone: map `OffsetDateTime/Instant/LocalDateTime` — cần chú ý gì để tránh drift?
- **Ánh xạ**:
    - **`OffsetDateTime`**: Lưu thời gian với offset (như `2025-08-15T10:00:00+07:00`).
    - **`Instant`**: Lưu timestamp UTC, không chứa timezone.
    - **`LocalDateTime`**: Lưu thời gian không offset, cần context timezone.
- **Chú ý**:
    - **DB**: Đảm bảo cột là `TIMESTAMP WITH TIME ZONE` (PostgreSQL) hoặc tương đương.
    - **JDBC**: Sử dụng `spring.jpa.properties.hibernate.jdbc.time_zone=UTC` để đồng bộ.
    - **Jackson**: Cấu hình `spring.jackson.time-zone=UTC`.
    - **Drift**: Tránh `LocalDateTime` nếu cần timezone chính xác, ưu tiên `OffsetDateTime` hoặc `Instant`.

---

# 2) Repository (JpaRepository, CrudRepository, query tùy biến)

### 1. So sánh `CrudRepository`, `PagingAndSortingRepository`, `JpaRepository`: khác nhau về API, paging/sorting, `flush`.
- **`CrudRepository`**:
    - API cơ bản: `save`, `findById`, `findAll`, `delete`.
    - Không hỗ trợ paging/sorting.
- **`PagingAndSortingRepository`**:
    - Kế thừa `CrudRepository`, thêm `findAll(Pageable)`, `findAll(Sort)`.
    - Hỗ trợ phân trang và sắp xếp.
- **`JpaRepository`**:
    - Kế thừa `PagingAndSortingRepository`, thêm `flush`, `saveAndFlush`, `deleteAllInBatch`.
    - Hỗ trợ flush tức thì và batch operations.
- **Flush**:
    - `JpaRepository` có `saveAndFlush`, `flush` để đồng bộ ngay với DB.
    - `CrudRepository` và `PagingAndSortingRepository` không có flush chủ động.

---

### 2. Lợi ích của **Page** vs **Slice** khi phân trang? Khi nào dùng mỗi loại?
- **`Page`**:
    - Trả về `Page<T>` với tổng số bản ghi (`totalElements`), số trang (`totalPages`).
    - Yêu cầu chạy `countQuery` → tốn hiệu năng.
    - Dùng khi cần biết chính xác số trang (như hiển thị pagination UI).
- **`Slice`**:
    - Chỉ biết có trang tiếp theo hay không (`hasNext()`).
    - Không chạy `countQuery`, hiệu năng tốt hơn.
    - Dùng cho infinite scroll hoặc khi không cần tổng số trang.
- **Lựa chọn**:
    - `Page`: UI phân trang cố định.
    - `Slice`: Dữ liệu lớn, chỉ cần load từng phần.

---

### 3. Mặc định `save()` là `persist` hay `merge`? Ảnh hưởng khi cập nhật entity **detached**?
- **Mặc định**:
    - `save()` gọi `persist` nếu entity là transient (mới).
    - `save()` gọi `merge` nếu entity là detached (đã tồn tại).
- **Ảnh hưởng với detached**:
    - `merge` copy trạng thái từ entity detached sang entity managed, gây overhead.
    - Nếu không trong transaction, có thể gây lỗi `LazyInitializationException`.
- **Giải pháp**:
    - Dùng `findById` trước khi cập nhật để đảm bảo managed state:
      ```java
      @Transactional
      public void updateUser(Long id, UserDTO dto) {
          User user = repository.findById(id).orElseThrow();
          user.setName(dto.getName());
          repository.save(user);
      }
      ```

---

### 4. ⚠️ Gài: Vì sao `saveAll()` có thể **không** hiệu quả với `IDENTITY`? Cách cải thiện?
- **Nguyên nhân**:
    - Với `IDENTITY`, Hibernate phải insert từng entity và flush để lấy ID, phá vỡ batch.
    - Gây nhiều truy vấn DB, giảm hiệu năng.
- **Cải thiện**:
    1. Chuyển sang `SEQUENCE`:
       ```java
       @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq")
       @SequenceGenerator(name = "seq", sequenceName = "user_seq", allocationSize = 50)
       ```
    2. Tối ưu batch size:
       ```properties
       spring.jpa.properties.hibernate.jdbc.batch_size=50
       spring.jpa.properties.hibernate.order_inserts=true
       ```
    3. Dùng native query cho batch insert nếu cần.

---

### 5. `@Query` với **JPQL** vs `nativeQuery=true`: khi nào nên/không nên dùng native?
- **JPQL**:
    - Dùng ngôn ngữ entity (như `SELECT u FROM User u`).
    - **Ưu**: Platform-independent, type-safe.
    - **Nhược**: Giới hạn với truy vấn phức tạp.
- **Native Query**:
    - Dùng SQL trực tiếp (`SELECT * FROM users`).
    - **Ưu**: Linh hoạt, hỗ trợ truy vấn phức tạp, tối ưu DB-specific.
    - **Nhược**: Phụ thuộc DB, không type-safe.
- **Khi dùng**:
    - JPQL: Truy vấn đơn giản, cần portability.
    - Native: Truy vấn phức tạp, dùng feature DB-specific (như CTE, window functions).
- **Không nên dùng native**:
    - Khi cần tương thích nhiều DB.
    - Khi truy vấn đơn giản, dễ viết bằng JPQL.

---

### 6. Ràng buộc tham số trong `@Query`: **named** vs **positional**; rủi ro đổi thứ tự.
- **Named**:
  ```java
  @Query("SELECT u FROM User u WHERE u.name = :name")
  List<User> findByName(@Param("name") String name);
  ```
    - **Ưu**: Rõ ràng, dễ bảo trì.
    - **Nhược**: Cần khai báo `@Param`.
- **Positional**:
  ```java
  @Query("SELECT u FROM User u WHERE u.name = ?1")
  List<User> findByName(String name);
  ```
    - **Ưu**: Ngắn gọn.
    - **Nhược**: Dễ lỗi nếu đổi thứ tự tham số.
- **Rủi ro đổi thứ tự**:
    - Với positional, đổi thứ tự tham số gây lỗi runtime (như `?1` trỏ sai).
    - **Giải pháp**: Ưu tiên named params hoặc derived query.

---

### 7. `@Modifying` cho UPDATE/DELETE: tác dụng của `clearAutomatically`, `flushAutomatically`. Khi nào dữ liệu trong **persistence context** bị **stale**?
- **`@Modifying`**:
    - Dùng cho query UPDATE/DELETE:
      ```java
      @Modifying
      @Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
      void updateStatus(@Param("id") Long id, @Param("status") String status);
      ```
- **Tác dụng**:
    - **`clearAutomatically`**: Xóa persistence context sau query, tránh stale data.
    - **`flushAutomatically`**: Flush thay đổi trước khi chạy query.
- **Stale data**:
    - Xảy ra khi persistence context không đồng bộ với DB sau query `@Modifying`.
    - Ví dụ: Update qua `@Query` nhưng entity trong context vẫn giữ giá trị cũ.
- **Giải pháp**:
    - Bật `clearAutomatically=true` để làm mới context.
    - Gọi `entityManager.refresh(entity)` nếu cần.

---

### 8. `countQuery` trong `@Query` dùng để làm gì với phân trang? Khi nào tự viết `countQuery`?
- **Tác dụng**:
    - Dùng để tính tổng số bản ghi cho phân trang (`Page`).
    - Ví dụ:
      ```java
      @Query(value = "SELECT u FROM User u WHERE u.status = :status",
             countQuery = "SELECT COUNT(u) FROM User u WHERE u.status = :status")
      Page<User> findByStatus(@Param("status") String status, Pageable pageable);
      ```
- **Khi tự viết `countQuery`**:
    - Truy vấn chính phức tạp (như join, group by) gây `countQuery` tự động sai.
    - Cần tối ưu hiệu năng (tránh join không cần thiết trong `countQuery`).

---

### 9. **Projection**: interface vs class-based; **closed vs open** projections; ưu/nhược về performance và an toàn.
- **Interface-based**:
  ```java
  public interface UserProjection {
      String getName();
      String getEmail();
  }
  @Query("SELECT u FROM User u")
  List<UserProjection> findAllProjected();
  ```
    - **Ưu**: Type-safe, nhẹ, dễ dùng.
    - **Nhược**: Giới hạn ở getter đơn giản.
- **Class-based**:
  ```java
  public class UserDTO {
      private String name;
      private String email;
      public UserDTO(String name, String email) { ... }
  }
  @Query("SELECT new com.example.UserDTO(u.name, u.email) FROM User u")
  List<UserDTO> findAllDTO();
  ```
    - **Ưu**: Linh hoạt, hỗ trợ logic trong constructor.
    - **Nhược**: Cần khai báo constructor rõ ràng.
- **Closed vs Open**:
    - **Closed**: Chỉ định rõ field trong interface/class, hiệu năng tốt.
    - **Open**: Dùng `Map` hoặc dynamic proxy, linh hoạt nhưng chậm.
- **Performance/An toàn**:
    - Closed: Nhanh, an toàn, ít overhead.
    - Open: Chậm hơn, dễ lỗi nếu field không tồn tại.

---

### 10. `@EntityGraph` trên method repository: khác gì với **fetch join** trong JPQL? Trường hợp nào `EntityGraph` hữu ích hơn?
- **`@EntityGraph`**:
  ```java
  @EntityGraph(attributePaths = {"items"})
  List<Order> findAll();
  ```
    - Chỉ định quan hệ cần fetch (EAGER hoặc LAZY).
- **Khác với fetch join**:
    - `fetch join`: Viết trong JPQL, kiểm soát chi tiết:
      ```java
      @Query("SELECT o FROM Order o JOIN FETCH o.items")
      List<Order> findAllWithItems();
      ```
    - `@EntityGraph`: Declarative, không cần viết JPQL, tái sử dụng dễ.
- **Khi dùng `@EntityGraph`**:
    - Truy vấn đơn giản, cần fetch quan hệ linh hoạt.
    - Muốn áp dụng cho nhiều method repository mà không lặp code.

---

### 11. **Specification** (`JpaSpecificationExecutor`) vs **Criteria API** vs **Query by Example** — khi nào chọn mỗi cái?
- **Specification**:
    - Dùng với `JpaSpecificationExecutor`:
      ```java
      Specification<User> spec = (root, query, cb) -> cb.equal(root.get("status"), "ACTIVE");
      List<User> users = repository.findAll(spec);
      ```
    - **Khi dùng**: Truy vấn động, kết hợp nhiều điều kiện.
- **Criteria API**:
    - Viết truy vấn bằng code:
      ```java
      CriteriaBuilder cb = entityManager.getCriteriaBuilder();
      CriteriaQuery<User> query = cb.createQuery(User.class);
      Root<User> root = query.from(User.class);
      query.where(cb.equal(root.get("status"), "ACTIVE"));
      ```
    - **Khi dùng**: Truy vấn phức tạp, cần kiểm soát chi tiết.
- **Query by Example**:
  ```java
  User probe = new User();
  probe.setStatus("ACTIVE");
  Example<User> example = Example.of(probe);
  List<User> users = repository.findAll(example);
  ```
    - **Khi dùng**: Truy vấn đơn giản, dựa trên giá trị mẫu.
- **Lựa chọn**:
    - Specification: Truy vấn động, dễ tái sử dụng.
    - Criteria API: Truy vấn rất phức tạp, cần logic đặc biệt.
    - Query by Example: Truy vấn đơn giản, ít điều kiện.

---

### 12. ⚠️ Gài: Vì sao `fetch join` nhiều collection có thể gây **Cartesian explosion** hoặc bị Hibernate từ chối?
- **Nguyên nhân**:
    - Fetch join nhiều collection (như `@OneToMany`) tạo ra tích Descartes (Cartesian product).
    - Ví dụ: `Order` join `OrderItem` và `OrderHistory` → số record = số `OrderItem` × số `OrderHistory`.
    - Hibernate có thể từ chối nếu truy vấn quá phức tạp.
- **Giải pháp**:
    - Chia nhỏ truy vấn, fetch từng collection riêng.
    - Dùng `@EntityGraph` để kiểm soát fetch.
    - Dùng batch fetching:
      ```properties
      spring.jpa.properties.hibernate.default_batch_fetch_size=10
      ```

---

### 13. Auditing (`@CreatedDate`, `@LastModifiedDate`, `@CreatedBy`, `@LastModifiedBy`): cần bật những gì? Phạm vi hoạt động.
- **Bật auditing**:
    - Thêm dependency `spring-boot-starter-data-jpa`.
    - Bật `@EnableJpaAuditing`:
      ```java
      @SpringBootApplication
      @EnableJpaAuditing
      public class Application { ... }
      ```
    - Entity:
      ```java
      @Entity
      @EntityListeners(AuditingEntityListener.class)
      public class User {
          @CreatedDate
          private LocalDateTime createdDate;
          @LastModifiedDate
          private LocalDateTime lastModifiedDate;
          @CreatedBy
          private String createdBy;
          @LastModifiedBy
          private String lastModifiedBy;
      }
      ```
    - Cung cấp `AuditorAware`:
      ```java
      @Bean
      public AuditorAware<String> auditorProvider() {
          return () -> Optional.of("system");
      }
      ```
- **Phạm vi**:
    - Chỉ hoạt động trong transaction.
    - Áp dụng cho entity được persist/merge.

---

### 14. Tùy biến repository: **Custom repository implementation** (naming `Impl`), **fragment** — khi nào cần vượt ra ngoài derived query.
- **Custom repository**:
  ```java
  public interface UserRepositoryCustom {
      List<User> customQuery();
  }
  public class UserRepositoryImpl implements UserRepositoryCustom {
      @PersistenceContext
      private EntityManager entityManager;
      public List<User> customQuery() {
          return entityManager.createQuery("SELECT u FROM User u", User.class).getResultList();
      }
  }
  public interface UserRepository extends JpaRepository<User, Long>, UserRepositoryCustom {}
  ```
    - **Khi cần**: Truy vấn phức tạp, không thể dùng derived query.
- **Fragment**:
    - Tách interface tùy biến, tái sử dụng:
      ```java
      public interface AuditableRepository<T> {
          List<T> findAudited();
      }
      ```
    - **Khi cần**: Cần tái sử dụng logic repository cho nhiều entity.

---

### 15. Streaming result (return `Stream<T>`): cần quản lý tài nguyên (transaction) như thế nào để tránh leak?
- **Streaming**:
  ```java
  @Query("SELECT u FROM User u")
  Stream<User> findAllStream();
  ```
- **Quản lý tài nguyên**:
    - Mở transaction khi dùng stream:
      ```java
      @Transactional(readOnly = true)
      public void processUsers() {
          try (Stream<User> stream = repository.findAllStream()) {
              stream.forEach(System.out::println);
          }
      }
      ```
    - Dùng `try-with-resources` để đóng stream, tránh leak.
    - Đảm bảo transaction bao quanh để tránh `LazyInitializationException`.

---

### 16. **Optimistic/Pessimistic locking** trong repository (`@Lock`): use case và rủi ro deadlock.
- **Optimistic**:
    - Dùng `@Version`:
      ```java
      @Entity
      public class Product {
          @Version
          private int version;
      }
      ```
    - **Use case**: Cập nhật ít xung đột, như chỉnh sửa thông tin người dùng.
    - **Rủi ro**: `OptimisticLockException` nếu xung đột.
- **Pessimistic**:
    - Dùng `@Lock`:
      ```java
      @Query("SELECT p FROM Product p WHERE p.id = :id")
      @Lock(LockModeType.PESSIMISTIC_WRITE)
      Optional<Product> findByIdForUpdate(@Param("id") Long id);
      ```
    - **Use case**: Cập nhật nhạy cảm, như trừ tồn kho.
    - **Rủi ro**: Deadlock nếu nhiều transaction khóa cùng record.
- **Giải pháp tránh deadlock**:
    - Sắp xếp thứ tự khóa.
    - Giảm thời gian giữ khóa.

---

### 17. **DTO projection** với `record`/constructor expression trong JPQL: khi nào nên tránh trả entity thô ra ngoài.
- **DTO projection**:
  ```java
  public record UserDTO(String name, String email) {}
  @Query("SELECT new com.example.UserDTO(u.name, u.email) FROM User u")
  List<UserDTO> findAllDTO();
  ```
- **Khi tránh trả entity thô**:
    - Entity chứa dữ liệu nhạy cảm (như password).
    - Entity có quan hệ LAZY, dễ gây `LazyInitializationException`.
    - Chỉ cần subset của dữ liệu để giảm overhead.

---

### 18. Repository per aggregate vs generic repository: cách tổ chức theo **Domain-Driven Design** cho rõ ràng.
- **Repository per aggregate**:
    - Mỗi aggregate root có repository riêng:
      ```java
      public interface OrderRepository extends JpaRepository<Order, Long> {}
      ```
    - **Ưu**: Rõ ràng, tuân theo DDD, giới hạn phạm vi.
    - **Nhược**: Nhiều repository, cần quản lý.
- **Generic repository**:
    - Một repository chung cho nhiều entity.
    - **Ưu**: Ít code, tái sử dụng.
    - **Nhược**: Vi phạm DDD, khó kiểm soát logic.
- **DDD**:
    - Dùng repository per aggregate.
    - Đặt trong package của domain:
      ```
      com.example.order.OrderRepository
      ```

---

# 3) Derived Query Methods (findBy…, countBy…)

### 1. Quy tắc đặt tên: `findBy`, `readBy`, `getBy`, `countBy`, `existsBy`, `deleteBy` — khi nào trả `Optional`, `List`, `Page`?
- **Quy tắc**:
    - **`findBy`, `readBy`, `getBy`**: Truy vấn entity, trả `T`, `List<T>`, `Optional<T>`, `Page<T>`.
    - **`countBy`**: Đếm số bản ghi, trả `long`.
    - **`existsBy`**: Kiểm tra tồn tại, trả `boolean`.
    - **`deleteBy`**: Xóa theo điều kiện, trả `void` hoặc số bản ghi.
- **Trả về**:
    - `Optional<T>`: Khi tìm một bản ghi (như `findById`).
    - `List<T>`: Khi tìm nhiều bản ghi.
    - `Page<T>`: Khi cần phân trang (dùng `Pageable`).

---

### 2. Toán tử: `And`, `Or`, `Between`, `LessThan`, `GreaterThanEqual`, `In`, `NotIn`, `Like`, `Containing`, `StartingWith`, `EndingWith`, `IsNull`, `IsNotNull`, `True`, `False`. Phân biệt `Like` vs `Containing`.
- **Toán tử**:
    - `And`, `Or`: Kết hợp điều kiện.
    - `Between`, `LessThan`, `GreaterThanEqual`: So sánh số/ngày.
    - `In`, `NotIn`: Kiểm tra trong danh sách.
    - `Like`, `Containing`, `StartingWith`, `EndingWith`: So sánh chuỗi.
    - `IsNull`, `IsNotNull`: Kiểm tra null.
    - `True`, `False`: Kiểm tra boolean.
- **Like vs Containing**:
    - `Like`: Tự định nghĩa pattern (như `findByNameLike("%test%")`).
    - `Containing`: Tự động thêm `%` (như `findByNameContaining("test")` = `%test%`).
- **Ví dụ**:
  ```java
  List<User> findByNameContainingAndStatus(String name, String status);
  ```

---

### 3. ⚠️ Gài: `IgnoreCase` áp dụng cho trường kiểu gì? Ảnh hưởng đến index?
- **Áp dụng**:
    - `IgnoreCase` chỉ dùng cho `String`:
      ```java
      List<User> findByNameIgnoreCase(String name);
      ```
    - Hibernate thêm `LOWER()` trong query, như `LOWER(name) = LOWER(?)`.
- **Ảnh hưởng index**:
    - DB không dùng index trên cột `name` vì `LOWER(name)` không khớp.
    - **Giải pháp**:
        - Tạo functional index:
          ```sql
          CREATE INDEX idx_user_name_lower ON users (LOWER(name));
          ```
        - Hoặc lưu cột phụ (như `name_lower`) để tìm kiếm.

---

### 4. Điều kiện lồng: truy cập thuộc tính liên kết (ví dụ `findByAddress_City`) — rủi ro N+1 và cách kiểm soát fetch.
- **Ví dụ**:
  ```java
  List<User> findByAddress_City(String city);
  ```
- **Rủi ro N+1**:
    - Hibernate load `User`, sau đó load `Address` cho mỗi `User`.
- **Kiểm soát fetch**:
    - Dùng `@EntityGraph`:
      ```java
      @EntityGraph(attributePaths = "address")
      List<User> findByAddress_City(String city);
      ```
    - Dùng `JOIN FETCH`:
      ```java
      @Query("SELECT u FROM User u JOIN FETCH u.address WHERE u.address.city = :city")
      List<User> findByCity(@Param("city") String city);
      ```

---

### 5. Sắp xếp trong tên method (ví dụ `OrderByCreatedAtDesc`) vs truyền `Sort` tham số — ưu/nhược?
- **Trong tên method**:
  ```java
  List<User> findByStatusOrderByCreatedAtDesc(String status);
  ```
    - **Ưu**: Rõ ràng, cố định logic sắp xếp.
    - **Nhược**: Không linh hoạt, cần thêm method cho mỗi cách sắp xếp.
- **Truyền `Sort`**:
  ```java
  List<User> findByStatus(String status, Sort sort);
  ```
    - **Ưu**: Linh hoạt, client quyết định cách sắp xếp.
    - **Nhược**: Cần truyền tham số đúng.
- **Lựa chọn**:
    - Method name: Truy vấn cố định.
    - `Sort`: Truy vấn động, cần tùy chỉnh.

---

### 6. Giới hạn `Top`, `First` — khác biệt và khi nào cần `Distinct`.
- **Top/First**:
    - `Top`: Lấy số bản ghi cố định (như `findTop5ByStatus`).
    - `First`: Lấy bản ghi đầu tiên (như `findFirstByStatus`).
- **Khi cần `Distinct`**:
    - Tránh trùng lặp khi truy vấn có join:
      ```java
      @Query("SELECT DISTINCT u FROM User u JOIN u.roles r WHERE r.name = :role")
      List<User> findDistinctByRole(@Param("role") String role);
      ```
    - Dùng khi dữ liệu có thể trùng do quan hệ.

---

### 7. Kết hợp phân trang: `findByStatus(Status s, Pageable p)` — cần chú ý gì về `countQuery` tự sinh?
- **Cấu hình**:
  ```java
  Page<User> findByStatus(String status, Pageable pageable);
  ```
- **Chú ý `countQuery`**:
    - Hibernate tự sinh `SELECT COUNT(*) FROM User WHERE status = ?`.
    - Có thể chậm nếu có join hoặc điều kiện phức tạp.
    - **Giải pháp**:
        - Tự viết `countQuery`:
          ```java
          @Query(value = "SELECT u FROM User u WHERE u.status = :status",
                 countQuery = "SELECT COUNT(u) FROM User u WHERE u.status = :status")
          Page<User> findByStatus(@Param("status") String status, Pageable pageable);
          ```

---

### 8. Tối ưu derived methods quá dài: tiêu chí chuyển sang `@Query`/Specification.
- **Tiêu chí**:
    - Method name quá dài (>3 điều kiện, như `findByNameAndStatusAndCreatedAtBetweenOrderByCreatedAtDesc`).
    - Cần logic phức tạp (như `OR`, subquery).
    - Cần tối ưu hiệu năng (như custom `countQuery`).
- **Chuyển sang**:
    - `@Query`:
      ```java
      @Query("SELECT u FROM User u WHERE u.name = :name AND u.status = :status")
      List<User> findUsers(@Param("name") String name, @Param("status") String status);
      ```
    - **Specification**:
      ```java
      Specification<User> spec = (root, query, cb) -> cb.and(
          cb.equal(root.get("name"), name),
          cb.equal(root.get("status"), status)
      );
      ```

---

### 9. ⚠️ Gài: Vì sao `findByEmail` có thể trả nhiều hơn 1 record dù email là unique ở DB? Cách đảm bảo nhất quán?
- **Nguyên nhân**:
    - Dữ liệu trong persistence context không đồng bộ với DB.
    - Ví dụ: Entity được lưu trong transaction khác, nhưng context chưa refresh.
- **Giải pháp**:
    1. Thêm `@Query` với `LIMIT 1`:
       ```java
       @Query("SELECT u FROM User u WHERE u.email = :email")
       Optional<User> findByEmail(@Param("email") String email);
       ```
    2. Dùng `findFirstByEmail`:
       ```java
       Optional<User> findFirstByEmail(String email);
       ```
    3. Refresh context:
       ```java
       entityManager.refresh(user);
       ```

---

### 10. Derived update/delete (`deleteBy…`) — khi nào **không** nên dùng vì ảnh hưởng cascade/orphanRemoval?
- **Không nên dùng**:
    - Khi `cascade=REMOVE` hoặc `orphanRemoval=true` gây xóa ngoài ý muốn:
      ```java
      @OneToMany(mappedBy = "order", cascade = CascadeType.REMOVE)
      private List<OrderItem> items;
      ```
        - `deleteByOrderId` sẽ xóa cả `OrderItem`.
    - Khi cần logic phức tạp trước khi xóa (như audit).
- **Giải pháp**:
    - Dùng `@Query` với logic rõ ràng:
      ```java
      @Modifying
      @Query("DELETE FROM Order o WHERE o.id = :id")
      void deleteById(@Param("id") Long id);
      ```

---

# 4) Transaction Management với JPA/Hibernate

### 1. `@Transactional` đặt ở **service** hay **repository**? Lý do kiến trúc cho việc chọn tầng.
- **Đặt ở service**:
    - **Lý do**:
        - Service là tầng logic nghiệp vụ, cần transaction bao quanh nhiều repository.
        - Đảm bảo tính toàn vẹn nghiệp vụ (như chuyển tiền: trừ + cộng).
        - Repository chỉ nên xử lý truy vấn, không quản lý transaction.
    - **Ví dụ**:
      ```java
      @Service
      public class UserService {
          @Transactional
          public void createUser(UserDTO dto) {
              userRepository.save(new User(dto.getName()));
          }
      }
      ```
- **Ngoại lệ**:
    - Đặt `@Transactional` ở repository nếu truy vấn đơn giản, read-only.

---

### 2. **Proxy-based** transaction: tại sao **self-invocation** trong cùng class khiến `@Transactional` **không** có tác dụng? Cách khắc phục?
- **Nguyên nhân**:
    - `@Transactional` dựa trên AOP proxy (JDK hoặc CGLIB).
    - Gọi method trong cùng class (self-invocation) không qua proxy, bỏ qua `@Transactional`.
    - Ví dụ:
      ```java
      @Service
      public class UserService {
          @Transactional
          public void createUser() {
              saveUser(); // Không qua proxy
          }
          @Transactional
          private void saveUser() { ... }
      }
      ```
- **Khắc phục**:
    1. Tách method sang service khác:
       ```java
       @Service
       public class UserService {
           @Autowired
           private UserRepository repository;
           @Transactional
           public void createUser() {
               repository.saveUser();
           }
       }
       ```
    2. Dùng `TransactionTemplate`:
       ```java
       @Autowired
       private TransactionTemplate txTemplate;
       public void createUser() {
           txTemplate.execute(status -> {
               saveUser();
               return null;
           });
       }
       ```

---

### 3. Propagation: `REQUIRED`, `REQUIRES_NEW`, `SUPPORTS`, `MANDATORY`, `NEVER`, `NOT_SUPPORTED`, `NESTED` — ví dụ thực tế cho mỗi loại.
- **`REQUIRED`**: Dùng transaction hiện tại, tạo mới nếu không có.
    - Ví dụ: Lưu user và profile trong cùng transaction.
- **`REQUIRES_NEW`**: Tạo transaction mới, tạm dừng transaction hiện tại.
    - Ví dụ: Ghi log audit độc lập với transaction chính.
- **`SUPPORTS`**: Dùng transaction hiện tại nếu có, không thì chạy non-transactional.
    - Ví dụ: Truy vấn read-only.
- **`MANDATORY`**: Yêu cầu transaction hiện tại, lỗi nếu không có.
    - Ví dụ: Cập nhật dữ liệu nhạy cảm.
- **`NEVER`**: Không chạy trong transaction, lỗi nếu có transaction.
    - Ví dụ: Truy vấn báo cáo không cần transaction.
- **`NOT_SUPPORTED`**: Tạm dừng transaction hiện tại, chạy non-transactional.
    - Ví dụ: Gọi API bên ngoài trong transaction.
- **`NESTED`**: Tạo savepoint trong transaction hiện tại.
    - Ví dụ: Cập nhật một phần dữ liệu, rollback riêng nếu lỗi.

---

### 4. ⚠️ Gài: `NESTED` yêu cầu gì ở DB? Khác gì với `REQUIRES_NEW` về savepoint/commit độc lập?
- **Yêu cầu DB**:
    - `NESTED` cần DB hỗ trợ savepoint (như PostgreSQL, không phải tất cả DB hỗ trợ).
- **Khác với `REQUIRES_NEW`**:
    - **`NESTED`**: Tạo savepoint trong transaction hiện tại, rollback chỉ ảnh hưởng savepoint.
    - **`REQUIRES_NEW`**: Tạo transaction độc lập, commit/rollback riêng biệt.
- **Ví dụ**:
    - `NESTED`: Thử lưu `OrderItem` trong `Order`, rollback chỉ `OrderItem` nếu lỗi.
    - `REQUIRES_NEW`: Ghi log audit, commit ngay cả khi transaction chính rollback.

---

### 5. Isolation: `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE` — mô tả **dirty/non-repeatable/phantom reads**; khác biệt MySQL vs PostgreSQL (MVCC).
- **Isolation levels**:
    - **`READ_COMMITTED`**: Chỉ đọc dữ liệu đã commit, tránh dirty reads.
    - **`REPEATABLE_READ`**: Đảm bảo dữ liệu không thay đổi trong transaction, tránh non-repeatable reads.
    - **`SERIALIZABLE`**: Tránh tất cả vấn đề, chạy tuần tự.
- **Vấn đề**:
    - **Dirty reads**: Đọc dữ liệu chưa commit (rollback sau đó).
    - **Non-repeatable reads**: Dữ liệu thay đổi giữa các lần đọc trong transaction.
    - **Phantom reads**: Thêm/xóa bản ghi giữa các lần đọc.
- **MySQL vs PostgreSQL**:
    - **MySQL**: `REPEATABLE_READ` là mặc định (InnoDB), dùng MVCC để tránh dirty reads.
    - **PostgreSQL**: Hỗ trợ MVCC tốt hơn, `READ_COMMITTED` mặc định, `SERIALIZABLE` mạnh hơn.

---

### 6. `@Transactional(readOnly=true)` trong Hibernate làm gì (flush mode, hints)? Có chặn **update** không?
- **Tác dụng**:
    - Đặt `FlushMode.MANUAL` hoặc `FlushMode.COMMIT`, không tự động flush thay đổi.
    - Thêm query hint `READ_ONLY` (tối ưu với DB hỗ trợ).
- **Chặn update**:
    - Không chặn update, chỉ tối ưu đọc.
    - Hibernate vẫn cho phép thay đổi entity, nhưng không flush trừ khi gọi `flush()`.
- **Ví dụ**:
  ```java
  @Transactional(readOnly = true)
  public List<User> findAllUsers() {
      return repository.findAll();
  }
  ```

---

### 7. Quy tắc rollback: unchecked vs checked exception; `rollbackFor`/`noRollbackFor` dùng khi nào?
- **Quy tắc**:
    - **Unchecked exceptions** (`RuntimeException`): Tự động rollback.
    - **Checked exceptions** (`Exception`): Không rollback mặc định.
- **`rollbackFor`/`noRollbackFor`**:
    - **`rollbackFor`**: Chỉ định exception gây rollback:
      ```java
      @Transactional(rollbackFor = IOException.class)
      public void saveUser() throws IOException { ... }
      ```
    - **`noRollbackFor`**: Ngăn rollback cho exception:
      ```java
      @Transactional(noRollbackFor = CustomException.class)
      public void process() { ... }
      ```

---

### 8. Transaction boundaries & LAZY: vì sao cần transaction **bao quanh** truy cập thuộc tính lazy?
- **Lý do**:
    - Thuộc tính `LAZY` chỉ load được trong persistence context (cần transaction).
    - Ngoài transaction, truy cập gây `LazyInitializationException`.
- **Giải pháp**:
  ```java
  @Transactional
  public Order getOrder(Long id) {
      Order order = repository.findById(id).orElseThrow();
      order.getItems().size(); // Load LAZY
      return order;
  }
  ```

---

### 9. ⚠️ Gài: Vì sao bắt `Exception` chung chung trong service có thể **vô hiệu hóa** rollback như mong muốn?
- **Nguyên nhân**:
    - Bắt `Exception` (bao gồm `RuntimeException`) và không rethrow:
      ```java
      @Transactional
      public void saveUser() {
          try {
              repository.save(new User());
          } catch (Exception e) {
              // Swallow exception
          }
      }
      ```
    - Spring không thấy exception, nên không rollback.
- **Giải pháp**:
    - Chỉ bắt exception cụ thể:
      ```java
      try {
          repository.save(new User());
      } catch (DataAccessException e) {
          throw e;
      }
      ```
    - Hoặc rethrow:
      ```java
      catch (Exception e) {
          throw new RuntimeException(e);
      }
      ```

---

### 10. **Flush**: khi nào Hibernate tự flush? Ảnh hưởng của `FlushMode` và gọi `flush()` thủ công.
- **Khi tự flush**:
    - Trước commit transaction.
    - Trước chạy query nếu cần đồng bộ (như `SELECT`).
    - Khi gọi `saveAndFlush`.
- **FlushMode**:
    - `AUTO`: Flush trước query hoặc commit (mặc định).
    - `COMMIT`: Chỉ flush khi commit.
    - `MANUAL`: Không tự flush, cần gọi `flush()`.
- **Gọi `flush()` thủ công**:
    - Đảm bảo dữ liệu được lưu ngay:
      ```java
      entityManager.flush();
      ```
    - Ảnh hưởng: Tăng số truy vấn, cần cẩn thận với batch.

---

### 11. Kết hợp **locking** với transaction: dùng `@Version` (optimistic) vs `PESSIMISTIC_WRITE`. Tình huống chọn cái nào?
- **`@Version`** (optimistic):
    - Dùng khi ít xung đột, như cập nhật profile người dùng.
    - Ví dụ:
      ```java
      @Entity
      public class User {
          @Version
          private int version;
      }
      ```
- **`PESSIMISTIC_WRITE`**:
    - Dùng khi cần đảm bảo không xung đột, như trừ tồn kho:
      ```java
      @Query("SELECT p FROM Product p WHERE p.id = :id")
      @Lock(LockModeType.PESSIMISTIC_WRITE)
      Product findByIdForUpdate(@Param("id") Long id);
      ```
- **Lựa chọn**:
    - Optimistic: Hiệu năng cao, ít khóa.
    - Pessimistic: Đảm bảo toàn vẹn, nhưng dễ deadlock.

---

### 12. Giao dịch trong jobs async/scheduler: `@Async`, `@Scheduled` tương tác với `@Transactional` ra sao (thread khác)?
- **Tương tác**:
    - `@Async` và `@Scheduled` chạy ở thread khác, không kế thừa transaction.
    - Cần `@Transactional` trong method được gọi:
      ```java
      @Async
      public void processAsync() {
          transactionalService.process();
      }
      @Service
      public class TransactionalService {
          @Transactional
          public void process() {
              repository.save(new User());
          }
      }
      ```
- **Lưu ý**:
    - Dùng `TransactionTemplate` nếu cần kiểm soát chi tiết.

---

### 13. Transactional events: `@TransactionalEventListener` (BEFORE_COMMIT/AFTER_COMMIT/AFTER_ROLLBACK) — use case audit/outbox.
- **Cấu hình**:
  ```java
  @Component
  public class AuditListener {
      @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
      public void onUserCreated(UserCreatedEvent event) {
          auditRepository.save(new AuditLog(event.getUserId()));
      }
  }
  ```
- **Use case**:
    - **Audit**: Ghi log sau khi transaction commit.
    - **Outbox**: Gửi message (như Kafka) sau commit.

---

### 14. Nhiều datasource: cấu hình **transaction manager** nào? Khi nào cần **JTA**/**XA** vs **outbox pattern**?
- **Cấu hình**:
  ```java
  @Configuration
  public class DataSourceConfig {
      @Bean
      @Primary
      public DataSource primaryDataSource() { ... }
      @Bean
      public DataSource secondaryDataSource() { ... }
      @Bean
      public PlatformTransactionManager primaryTxManager(@Qualifier("primaryDataSource") DataSource ds) {
          return new JpaTransactionManager(ds);
      }
  }
  ```
- **JTA/XA**:
    - Dùng khi cần transaction phân tán (nhiều datasource).
    - Cấu hình:
      ```xml
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-jta-atomikos</artifactId>
      </dependency>
      ```
- **Outbox pattern**:
    - Lưu event vào bảng trong transaction, gửi message sau.
    - Dùng khi không muốn JTA phức tạp.

---

### 15. Test: `@DataJpaTest` mặc định rollback? Cách **commit thật** trong test khi cần kiểm tra migration/trigger.
- **Mặc định**:
    - `@DataJpaTest` tự động rollback sau mỗi test.
- **Commit thật**:
  ```java
  @DataJpaTest
  @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
  @Transactional(propagation = Propagation.NOT_SUPPORTED)
  public class MigrationTest {
      @Test
      public void testMigration() {
          // Test trigger/migration
      }
  }
  ```
- **Lưu ý**:
    - Dùng DB thật hoặc H2 với schema giống production.

---

### 16. ⚠️ Gài: Tại sao đặt `@Transactional` trên **private method** không hoạt động? Ảnh hưởng của AOP proxy kiểu JDK/CGLIB.
- **Nguyên nhân**:
    - `@Transactional` dựa trên AOP proxy:
        - **JDK proxy**: Chỉ proxy public method của interface.
        - **CGLIB proxy**: Proxy public/protected method của class.
    - Private method không được proxy, nên `@Transactional` bị bỏ qua.
- **Giải pháp**:
    - Đặt `@Transactional` trên public method.
    - Dùng `TransactionTemplate` cho private method.

---

# 5) Mini case (thực chiến 2–5 phút mỗi câu)

### 1. Bảng `orders`–`order_items`–`products`: thiết kế mapping, cân nhắc **cascade**, **orphanRemoval**, **fetch**, và chiến lược tránh N+1 khi tải order kèm items.
- **Mapping**:
  ```java
  @Entity
  public class Order {
      @Id
      @GeneratedValue(strategy = GenerationType.SEQUENCE)
      private Long id;
      @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
      private List<OrderItem> items;
  }
  @Entity
  public class OrderItem {
      @Id
      @GeneratedValue(strategy = GenerationType.SEQUENCE)
      private Long id;
      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "order_id")
      private Order order;
      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "product_id")
      private Product product;
  }
  @Entity
  public class Product {
      @Id
      @GeneratedValue(strategy = GenerationType.SEQUENCE)
      private Long id;
  }
  ```
- **Cascade**: `CascadeType.ALL` trên `Order.items` để lưu/xóa `OrderItem` cùng `Order`.
- **OrphanRemoval**: `true` để xóa `OrderItem` khi bị xóa khỏi `items`.
- **Fetch**: `LAZY` để tránh load không cần thiết.
- **Tránh N+1**:
  ```java
  @EntityGraph(attributePaths = "items.product")
  Optional<Order> findById(Long id);
  ```

---

### 2. Bạn cần **soft delete**: đề xuất 2–3 cách (cột `deleted`, `@SQLDelete`+`@Where`, filter) và hệ quả với unique/index/reporting.
- **Cách 1: Cột `deleted`**:
  ```java
  @Entity
  public class User {
      @Column(name = "deleted")
      private boolean deleted;
  }
  @Query("SELECT u FROM User u WHERE u.deleted = false")
  List<User> findAllActive();
  ```
    - **Hệ quả**: Cần thêm điều kiện `deleted=false` trong query, ảnh hưởng unique constraint.
- **Cách 2: `@SQLDelete` + `@Where`**:
  ```java
  @Entity
  @SQLDelete(sql = "UPDATE users SET deleted = true WHERE id = ?")
  @Where(clause = "deleted = false")
  public class User {
      private boolean deleted;
  }
  ```
    - **Hệ quả**: Tự động lọc, nhưng cần đảm bảo index trên `deleted`.
- **Cách 3: Hibernate Filter**:
  ```java
  @Entity
  @FilterDef(name = "activeUsers", parameters = @ParamDef(name = "active", type = "boolean"))
  @Filter(name = "activeUsers", condition = "deleted = :active")
  public class User {
      private boolean deleted;
  }
  @PersistenceContext
  private EntityManager entityManager;
  public List<User> findAllActive() {
      entityManager.unwrap(Session.class).enableFilter("activeUsers").setParameter("active", false);
      return repository.findAll();
  }
  ```
    - **Hệ quả**: Linh hoạt, nhưng phức tạp hơn.

---

### 3. Endpoint **search users** nhiều tiêu chí (tên, email, role, trạng thái, khoảng ngày tạo): chọn **derived**, `@Query`, hay **Specification**? Vì sao?
- **Lựa chọn: Specification**:
    - **Lý do**:
        - Tiêu chí động, có thể kết hợp AND/OR.
        - Dễ mở rộng, tái sử dụng.
  ```java
  public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {}
  public class UserService {
      public List<User> searchUsers(String name, String email, String role, String status, LocalDateTime start, LocalDateTime end) {
          Specification<User> spec = Specification.where((root, query, cb) -> {
              List<Predicate> predicates = new ArrayList<>();
              if (name != null) predicates.add(cb.like(root.get("name"), "%" + name + "%"));
              if (email != null) predicates.add(cb.equal(root.get("email"), email));
              if (role != null) predicates.add(cb.equal(root.get("role"), role));
              if (status != null) predicates.add(cb.equal(root.get("status"), status));
              if (start != null && end != null) predicates.add(cb.between(root.get("createdAt"), start, end));
              return cb.and(predicates.toArray(new Predicate[0]));
          });
          return repository.findAll(spec);
      }
  }
  ```
- **Tại sao không**:
    - Derived: Tên method quá dài, khó bảo trì.
    - `@Query`: Không linh hoạt với tiêu chí động.

---

### 4. Quy trình ghi log audit sau khi giao dịch **commit** thành công: thiết kế với `@TransactionalEventListener`.
- **Thiết kế**:
  ```java
  public class UserCreatedEvent {
      private final Long userId;
      public UserCreatedEvent(Long userId) {
          this.userId = userId;
      }
  }
  @Component
  public class AuditListener {
      @Autowired
      private AuditRepository auditRepository;
      @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
      public void onUserCreated(UserCreatedEvent event) {
          auditRepository.save(new AuditLog("User created: " + event.getUserId()));
      }
  }
  @Service
  public class UserService {
      @Autowired
      private ApplicationEventPublisher publisher;
      @Transactional
      public void createUser(UserDTO dto) {
          User user = repository.save(new User(dto.getName()));
          publisher.publishEvent(new UserCreatedEvent(user.getId()));
      }
  }
  ```
- **Lưu ý**:
    - `AFTER_COMMIT` đảm bảo log chỉ ghi khi transaction thành công.

---

### 5. Sự cố **OptimisticLockException** khi update tồn kho “giỏ hàng”: trình bày chiến lược retry/backoff và khi nào chuyển sang khóa bi quan.
- **Retry/backoff**:
  ```java
  @Service
  public class CartService {
      @Transactional
      public void updateStock(Long productId, int quantity) {
          for (int i = 0; i < 3; i++) {
              try {
                  Product product = repository.findById(productId).orElseThrow();
                  product.setStock(product.getStock() - quantity);
                  repository.save(product);
                  return;
              } catch (OptimisticLockException e) {
                  Thread.sleep(100 * (i + 1)); // Backoff
              }
          }
          throw new RuntimeException("Retry failed");
      }
  }
  ```
- **Khi dùng khóa bi quan**:
    - Xung đột cao (như flash sale).
    - Cần đảm bảo toàn vẹn ngay lập tức.
  ```java
  @Query("SELECT p FROM Product p WHERE p.id = :id")
  @Lock(LockModeType.PESSIMISTIC_WRITE)
  Product findByIdForUpdate(@Param("id") Long id);
  ```

---

