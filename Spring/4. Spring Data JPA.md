# 1) ORM & Entity Mapping

1. `@Entity` yêu cầu tối thiểu những gì? Sự khác nhau giữa **entity** và **value object** trong JPA?
2. `@Table` dùng để làm gì? Khai báo `schema`, `uniqueConstraints`, `indexes` ở đâu và khi nào cần?
3. `@Id` dùng **natural key** vs **surrogate key**: ưu/nhược từng cách?
4. `@GeneratedValue(strategy=…)`: so sánh `AUTO`, `IDENTITY`, `SEQUENCE`, `TABLE`; ảnh hưởng đến **batch insert** và `flush`.
5. ⚠️ Gài: Vì sao dùng `IDENTITY` trên MySQL thường làm **khó** batch insert của Hibernate?
6. Khóa tổng hợp: `@EmbeddedId` vs `@IdClass` khác gì, khi nào dùng mỗi cái?
7. Quy tắc đặt `equals()`/`hashCode()` cho entity: rủi ro nếu dựa vào `id` chưa được gán? (trạng thái transient)
8. `@Column` (nullable, length, precision/scale) và **khác biệt** giữa ràng buộc ở **DB** vs **validation** ở ứng dụng.
9. Ánh xạ enum: `@Enumerated(STRING|ORDINAL)` — rủi ro khi đổi thứ tự enum?
10. `@Converter` (AttributeConverter) dùng khi nào? Ví dụ mã hóa/giải mã, booleans đặc biệt, kiểu tiền tệ.
11. `@Lob`, `@Basic(fetch=LAZY)` với BLOB/CLOB: khi nào LAZY **không thực sự lazy** (bytecode enhancement/proxy)?
12. One-to-One: `@OneToOne` với `mappedBy` và `@JoinColumn` — bên nào là **owning side**? Khi cần `@MapsId`?
13. Many-to-One và One-to-Many hai chiều: xác định **owning side** ở đâu? Hậu quả nếu đặt sai `mappedBy`?
14. ⚠️ Gài: Vì sao `List` trong `@OneToMany` mặc định **không giữ thứ tự**? Dùng `@OrderBy` vs `@OrderColumn` khác nhau thế nào?
15. Many-to-Many: khi nào **không** nên dùng trực tiếp và nên thay bằng **entity trung gian** (association entity) để chứa metadata?
16. Cascade: `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, `DETACH`, `ALL` — ý nghĩa từng loại; **không** nên gắn `REMOVE` ở đâu?
17. `orphanRemoval=true` khác `cascade=REMOVE` thế nào? Ví dụ xóa phần tử khỏi collection.
18. Fetch type: mặc định của `@ManyToOne` và `@OneToMany` là gì? Khi nào EAGER gây **N+1** và cách tránh?
19. ⚠️ Gài: Nguyên nhân và 3 cách xử lý `LazyInitializationException` **không** dùng Open Session In View.
20. Kế thừa: `@Inheritance(SINGLE_TABLE|JOINED|TABLE_PER_CLASS)` — ưu/nhược về hiệu năng, normal hóa, tính linh hoạt.
21. **Lifecycle state**: transient, managed, detached, removed — hành vi của `persist`, `merge`, `remove`, `flush`.
22. `@Version` (optimistic locking): khi nào ném `OptimisticLockException`, xử lý/retry ra sao?
23. `@SecondaryTable`, `@ElementCollection`: khi nào hợp lý hơn tách thành entity riêng?
24. Tương thích timezone: map `OffsetDateTime/Instant/LocalDateTime` — cần chú ý gì để tránh drift?

# 2) Repository (JpaRepository, CrudRepository, query tuỳ biến)

1. So sánh `CrudRepository`, `PagingAndSortingRepository`, `JpaRepository`: khác nhau về API, paging/sorting, `flush`.
2. Lợi ích của **Page** vs **Slice** khi phân trang? Khi nào dùng mỗi loại?
3. Mặc định `save()` là `persist` hay `merge`? Ảnh hưởng khi cập nhật entity **detached**?
4. ⚠️ Gài: Vì sao `saveAll()` có thể **không** hiệu quả với `IDENTITY`? Cách cải thiện?
5. `@Query` với **JPQL** vs `nativeQuery=true`: khi nào nên/không nên dùng native?
6. Ràng buộc tham số trong `@Query`: **named** vs **positional**; rủi ro đổi thứ tự.
7. `@Modifying` cho UPDATE/DELETE: tác dụng của `clearAutomatically`, `flushAutomatically`. Khi nào dữ liệu trong **persistence context** bị **stale**?
8. `countQuery` trong `@Query` dùng để làm gì với phân trang? Khi nào tự viết `countQuery`?
9. **Projection**: interface vs class-based; **closed vs open** projections; ưu/nhược về performance và an toàn.
10. `@EntityGraph` trên method repository: khác gì với **fetch join** trong JPQL? Trường hợp nào `EntityGraph` hữu ích hơn?
11. **Specification** (`JpaSpecificationExecutor`) vs **Criteria API** vs **Query by Example** — khi nào chọn mỗi cái?
12. ⚠️ Gài: Vì sao `fetch join` nhiều collection có thể gây **Cartesian explosion** hoặc bị Hibernate từ chối?
13. Auditing (`@CreatedDate`, `@LastModifiedDate`, `@CreatedBy`, `@LastModifiedBy`): cần bật những gì? Phạm vi hoạt động.
14. Tùy biến repository: **Custom repository implementation** (naming `Impl`), **fragment** — khi nào cần vượt ra ngoài derived query.
15. Streaming result (return `Stream<T>`): cần quản lý tài nguyên (transaction) như thế nào để tránh leak?
16. **Optimistic/Pessimistic locking** trong repository (`@Lock`): use case và rủi ro deadlock.
17. **DTO projection** với `record`/constructor expression trong JPQL: khi nào nên tránh trả entity thô ra ngoài.
18. Repository per aggregate vs generic repository: cách tổ chức theo **Domain-Driven Design** cho rõ ràng.

# 3) Derived Query Methods (findBy…, countBy…)

1. Quy tắc đặt tên: `findBy`, `readBy`, `getBy`, `countBy`, `existsBy`, `deleteBy` — khi nào trả `Optional`, `List`, `Page`?
2. Toán tử: `And`, `Or`, `Between`, `LessThan`, `GreaterThanEqual`, `In`, `NotIn`, `Like`, `Containing`, `StartingWith`, `EndingWith`, `IsNull`, `IsNotNull`, `True`, `False`. Phân biệt `Like` vs `Containing`.
3. ⚠️ Gài: `IgnoreCase` áp dụng cho trường kiểu gì? Ảnh hưởng đến index?
4. Điều kiện lồng: truy cập thuộc tính liên kết (ví dụ `findByAddress_City`) — rủi ro N+1 và cách kiểm soát fetch.
5. Sắp xếp trong tên method (ví dụ `OrderByCreatedAtDesc`) vs truyền `Sort` tham số — ưu/nhược?
6. Giới hạn `Top`, `First` — khác biệt và khi nào cần `Distinct`.
7. Kết hợp phân trang: `findByStatus(Status s, Pageable p)` — cần chú ý gì về `countQuery` tự sinh?
8. Tối ưu derived methods quá dài: tiêu chí chuyển sang `@Query`/Specification.
9. ⚠️ Gài: Vì sao `findByEmail` có thể trả nhiều hơn 1 record dù email là unique ở DB? Cách đảm bảo nhất quán?
10. Derived update/delete (`deleteBy…`) — khi nào **không** nên dùng vì ảnh hưởng cascade/orphanRemoval?

# 4) Transaction Management với JPA/Hibernate

1. `@Transactional` đặt ở **service** hay **repository**? Lý do kiến trúc cho việc chọn tầng.
2. **Proxy-based** transaction: tại sao **self-invocation** trong cùng class khiến `@Transactional` **không** có tác dụng? Cách khắc phục?
3. Propagation: `REQUIRED`, `REQUIRES_NEW`, `SUPPORTS`, `MANDATORY`, `NEVER`, `NOT_SUPPORTED`, `NESTED` — ví dụ thực tế cho mỗi loại.
4. ⚠️ Gài: `NESTED` yêu cầu gì ở DB? Khác gì với `REQUIRES_NEW` về savepoint/commit độc lập?
5. Isolation: `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE` — mô tả **dirty/non-repeatable/phantom reads**; khác biệt MySQL vs PostgreSQL (MVCC).
6. `@Transactional(readOnly=true)` trong Hibernate làm gì (flush mode, hints)? Có chặn **update** không?
7. Quy tắc rollback: unchecked vs checked exception; `rollbackFor`/`noRollbackFor` dùng khi nào?
8. Transaction boundaries & LAZY: vì sao cần transaction **bao quanh** truy cập thuộc tính lazy?
9. ⚠️ Gài: Vì sao bắt `Exception` chung chung trong service có thể **vô hiệu hóa** rollback như mong muốn?
10. **Flush**: khi nào Hibernate tự flush? Ảnh hưởng của `FlushMode` và gọi `flush()` thủ công.
11. Kết hợp **locking** với transaction: dùng `@Version` (optimistic) vs `PESSIMISTIC_WRITE`. Tình huống chọn cái nào?
12. Giao dịch trong jobs async/scheduler: `@Async`, `@Scheduled` tương tác với `@Transactional` ra sao (thread khác)?
13. Transactional events: `@TransactionalEventListener` (BEFORE\_COMMIT/AFTER\_COMMIT/AFTER\_ROLLBACK) — use case audit/outbox.
14. Nhiều datasource: cấu hình **transaction manager** nào? Khi nào cần **JTA**/**XA** vs **outbox pattern**?
15. Test: `@DataJpaTest` mặc định rollback? Cách **commit thật** trong test khi cần kiểm tra migration/trigger.
16. ⚠️ Gài: Tại sao đặt `@Transactional` trên **private method** không hoạt động? Ảnh hưởng của AOP proxy kiểu JDK/CGLIB.

# 5) Mini case (thực chiến 2–5 phút mỗi câu)

1. Bảng `orders`–`order_items`–`products`: thiết kế mapping, cân nhắc **cascade**, **orphanRemoval**, **fetch**, và chiến lược tránh N+1 khi tải order kèm items.
2. Bạn cần **soft delete**: đề xuất 2–3 cách (cột `deleted`, `@SQLDelete`+`@Where`, filter) và hệ quả với unique/index/reporting.
3. Endpoint **search users** nhiều tiêu chí (tên, email, role, trạng thái, khoảng ngày tạo): chọn **derived**, `@Query`, hay **Specification**? Vì sao?
4. Quy trình ghi log audit sau khi giao dịch **commit** thành công: thiết kế với `@TransactionalEventListener`.
5. Sự cố **OptimisticLockException** khi update tồn kho “giỏ hàng”: trình bày chiến lược retry/backoff và khi nào chuyển sang khóa bi quan.

