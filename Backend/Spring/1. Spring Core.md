# 1) IoC & DI (Inversion of Control, Dependency Injection)

### 1. IoC là gì? So sánh IoC với Service Locator (ưu/nhược, khi nào chọn cái nào).
- **IoC (Inversion of Control)**: Là một nguyên tắc thiết kế trong đó quyền điều khiển việc tạo và quản lý dependency được chuyển từ class sang một container (như Spring IoC container). Class không tự tạo đối tượng mà nhận dependency từ bên ngoài.
    - **Ví dụ**: Spring injects beans vào class qua DI (Dependency Injection).
- **Service Locator**: Là một pattern nơi class chủ động tìm kiếm dependency từ một registry (locator) thay vì nhận qua injection.
    - **Ví dụ**: Class gọi `ServiceLocator.getService("beanName")`.

**So sánh**:
- **Ưu điểm IoC**:
    - Giảm coupling: Class không biết cách tạo dependency, dễ thay đổi implementation.
    - Dễ test: Dependency được inject, dễ mock/stub.
    - Quản lý tập trung: Container xử lý lifecycle, scope, và cấu hình.
- **Nhược điểm IoC**:
    - Phức tạp hơn khi cấu hình container (XML, Java Config).
    - Khó debug nếu container cấu hình sai.
- **Ưu điểm Service Locator**:
    - Đơn giản hơn cho ứng dụng nhỏ, không cần container phức tạp.
    - Kiểm soát rõ ràng: Class tự quyết định khi nào lấy dependency.
- **Nhược điểm Service Locator**:
    - Tăng coupling: Class phụ thuộc vào Service Locator.
    - Khó test: Phải mock cả Service Locator.
    - Dễ gây lỗi runtime nếu service không tồn tại.

**Khi nào chọn**:
- **IoC**: Dùng trong ứng dụng lớn, cần decoupling, dễ test, và quản lý lifecycle tập trung (như Spring-based apps).
- **Service Locator**: Dùng trong ứng dụng nhỏ hoặc legacy code, khi không muốn dùng container phức tạp.

---

### 2. DI là gì? DI giúp giảm **coupling** như thế nào?
- **DI (Dependency Injection)**: Là một cách triển khai IoC, trong đó dependency được cung cấp (injected) vào class thông qua constructor, setter, hoặc field, thay vì class tự tạo.
- **Giảm coupling**:
    - **Loose coupling**: Class không biết cách tạo dependency (chỉ biết interface/contract), giảm phụ thuộc vào implementation cụ thể.
    - **Tính module hóa**: Dễ thay đổi dependency (như đổi từ `MySQLRepo` sang `PostgresRepo`) mà không sửa code class.
    - **Ví dụ**:
      ```java
      public class UserService {
          private final UserRepository repo; // Chỉ biết interface
          public UserService(UserRepository repo) { // DI qua constructor
              this.repo = repo;
          }
      }
      ```
    - Spring container injects `UserRepository` implementation, class không cần gọi `new`.

---

### 3. Các kiểu DI (constructor/setter/field) khác nhau ở điểm nào về: tính bất biến, testability, vòng đời phụ thuộc?
- **Constructor Injection**:
    - **Tính bất biến**: Đảm bảo dependency không đổi sau khi tạo (nếu field `final`), tăng thread-safety.
    - **Testability**: Dễ mock/stub dependency trong unit test, không cần framework.
    - **Vòng đời phụ thuộc**: Dependency phải có sẵn khi tạo object, phù hợp cho required dependencies.
- **Setter Injection**:
    - **Tính bất biến**: Không đảm bảo (dependency có thể đổi qua setter), dễ gây lỗi nếu setter gọi sai thời điểm.
    - **Testability**: Vẫn dễ test, nhưng cần gọi setter trong test, tăng boilerplate.
    - **Vòng đời phụ thuộc**: Phù hợp cho optional dependencies, hoặc khi dependency thay đổi trong runtime.
- **Field Injection**:
    - **Tính bất biến**: Không đảm bảo (field có thể đổi trực tiếp nếu không `final`).
    - **Testability**: Khó test, cần reflection hoặc framework (như Spring) để inject trong test.
    - **Vòng đời phụ thuộc**: Dependency được inject sau khi tạo object, dễ gây NPE nếu không kiểm soát.

**So sánh**:
- Constructor injection ưu tiên cho tính bất biến và testability.
- Setter injection dùng cho optional dependencies.
- Field injection nên tránh do khó test và kiểm soát.

---

### 4. Khi một dependency là **bắt buộc** vs **tùy chọn**, bạn thiết kế constructor/setter như thế nào?
- **Bắt buộc (Required)**:
    - Dùng **constructor injection** với field `final`:
      ```java
      public class UserService {
          private final UserRepository repo;
          public UserService(UserRepository repo) {
              this.repo = Objects.requireNonNull(repo);
          }
      }
      ```
    - Đảm bảo dependency luôn được inject, tránh NPE.
- **Tùy chọn (Optional)**:
    - Dùng **setter injection** hoặc `Optional<T>` trong constructor:
      ```java
      public class UserService {
          private Logger logger; // Optional
          public void setLogger(Logger logger) {
              this.logger = logger;
          }
      }
      // Hoặc
      public class UserService {
          private final Optional<Logger> logger;
          public UserService(Optional<Logger> logger) {
              this.logger = logger;
          }
      }
      ```
    - Kiểm tra null/`Optional` khi sử dụng để tránh lỗi runtime.

---

### 5. ⚠️ Gài: Vì sao field injection bị xem là “mùi” trong thiết kế? Hệ quả đối với unit test, bất biến, và refactor?
- **Vì sao field injection là code smell**:
    - **Ẩn dependency**: Không thấy rõ dependency từ constructor hoặc setter, khó hiểu class cần gì.
    - **Khó test**: Cần reflection hoặc Spring context để inject trong unit test, làm test phức tạp.
    - **Không bất biến**: Field không `final` có thể bị đổi, gây lỗi thread-safety hoặc trạng thái không mong muốn.
    - **Khó refactor**: Khi thêm/xóa dependency, phải sửa trực tiếp field, dễ bỏ sót.
- **Hệ quả**:
    - **Unit test**: Phải khởi tạo Spring context hoặc dùng reflection để inject, tăng boilerplate.
    - **Bất biến**: Không đảm bảo dependency không đổi, dễ gây lỗi nếu field bị set null.
    - **Refactor**: Thay đổi dependency khó vì không có contract rõ ràng (như constructor).

**Giải pháp**: Dùng constructor injection để đảm bảo bất biến và dễ test.

---

### 6. Khi có **nhiều bean cùng type**, Spring chọn bean nào để inject? Vai trò của `@Primary`, `@Qualifier`?
- **Spring chọn bean**:
    - Nếu có nhiều bean cùng type (như nhiều `UserRepository`), Spring ném `NoUniqueBeanDefinitionException` trừ khi có cách phân giải.
- **Vai trò `@Primary`**:
    - Chỉ định bean ưu tiên khi có nhiều bean cùng type.
  ```java
  @Bean
  @Primary
  UserRepository mysqlRepo() { return new MySQLRepo(); }
  ```
    - Spring chọn bean `@Primary` nếu không có `@Qualifier`.
- **Vai trò `@Qualifier`**:
    - Chỉ định bean cụ thể theo tên:
  ```java
  @Autowired
  @Qualifier("mysqlRepo")
  private UserRepository repo;
  ```
    - Có độ ưu tiên cao hơn `@Primary`.
- **Thứ tự ưu tiên**: `@Qualifier` > `@Primary` > default (ném exception nếu không phân giải được).

---

### 7. DI cho **collection** (List/Map/Set) hoạt động ra sao? Sắp xếp thứ tự các bean trong List như thế nào?
- **DI cho collection**:
    - Spring có thể inject `List`, `Set`, hoặc `Map` chứa các bean cùng type.
    - **List/Set**: Chứa tất cả bean của type (hoặc interface).
      ```java
      @Autowired
      private List<UserRepository> repos; // Tất cả UserRepository beans
      ```
    - **Map**: Key là tên bean, value là bean instance.
      ```java
      @Autowired
      private Map<String, UserRepository> repoMap; // Key = bean name
      ```
- **Sắp xếp thứ tự trong List**:
    - Dùng `@Order(n)` hoặc implement `Ordered` trên bean:
      ```java
      @Bean
      @Order(1)
      UserRepository mysqlRepo() { return new MySQLRepo(); }
      ```
    - Thấp hơn `n` được xếp trước. Nếu không có `@Order`, thứ tự không đảm bảo.

---

### 8. DI các bean **theo tên** vs **theo type**: khi nào bị xung đột?
- **Theo tên**:
    - Dùng `@Qualifier("beanName")` để chọn bean cụ thể.
    - Xung đột: Nếu tên bean không tồn tại, ném `NoSuchBeanDefinitionException`.
- **Theo type**:
    - Spring tìm bean theo interface/class, ném `NoUniqueBeanDefinitionException` nếu có nhiều bean cùng type.
- **Xung đột xảy ra**:
    - Nhiều bean cùng type mà không có `@Primary` hoặc `@Qualifier`.
    - Tên trong `@Qualifier` không khớp với tên bean.
- **Giải pháp**: Dùng `@Primary`, `@Qualifier`, hoặc chỉ định tên bean rõ ràng.

---

### 9. DI với **generic type** (ví dụ `List<Foo>` vs `List<Bar>`) Spring phân giải như thế nào?
- Spring hỗ trợ **generic type resolution** thông qua `ResolvableType`:
    - Khi inject `List<Foo>` hoặc `List<Bar>`, Spring kiểm tra generic type của field/constructor.
    - Chỉ inject bean khớp với generic type:
      ```java
      @Autowired
      private List<Foo> fooList; // Chỉ chứa Foo beans
      ```
- **Cơ chế**:
    - Spring dùng reflection để lấy generic type (`List<Foo>`).
    - Tìm tất cả bean thuộc type `Foo` (hoặc subtype).
- **Lưu ý**: Nếu generic type không rõ ràng (như `List<?>`), Spring inject tất cả bean của type cơ bản, có thể gây lỗi nếu không kiểm soát.

---

### 10. DI chu kỳ (circular dependency) là gì? Phát hiện & xử lý thế nào? Trường hợp nào setter injection giúp được?
- **Circular dependency**: Hai hoặc nhiều bean phụ thuộc lẫn nhau, như A cần B và B cần A.
    - Ví dụ: `UserService` cần `OrderService`, `OrderService` cần `UserService`.
- **Phát hiện**:
    - Spring ném `BeanCurrentlyInCreationException` khi tạo bean nếu phát hiện vòng lặp.
    - Dùng log hoặc IDE (như IntelliJ) để phát hiện qua dependency graph.
- **Xử lý**:
    1. **Tái cấu trúc**:
        - Loại bỏ vòng lặp bằng cách dùng interface hoặc tách logic.
        - Ví dụ: Tạo `UserOrderFacade` để gộp logic.
    2. **Setter injection**:
        - Phá vòng lặp bằng cách inject một bean qua setter thay vì constructor.
        - Spring tạo object trước, inject dependency sau.
       ```java
       public class UserService {
           private OrderService orderService;
           @Autowired
           public void setOrderService(OrderService orderService) {
               this.orderService = orderService;
           }
       }
       ```
    3. **Lazy initialization**:
        - Dùng `@Lazy` để trì hoãn tạo bean.
- **Khi setter injection giúp**: Khi dependency không bắt buộc hoặc có thể inject sau khi tạo object.

---

### 11. ⚠️ Gài: `@Lazy` đặt ở đâu để phá vòng lặp A↔B? Đặt sai chỗ có tác dụng không?
- **Đặt `@Lazy`**:
    - Đặt `@Lazy` trên một trong hai dependency trong vòng lặp:
      ```java
      public class A {
          private final B b;
          public A(@Lazy B b) {
              this.b = b;
          }
      }
      ```
    - Spring tạo proxy cho `B`, trì hoãn khởi tạo thực sự đến khi gọi method trên `B`.
- **Đặt sai chỗ**:
    - Nếu đặt `@Lazy` trên cả hai bean hoặc trên bean không nằm trong vòng lặp, không phá được vòng lặp.
    - Nếu đặt trên `@Bean` method mà không phải injection point, không có tác dụng:
      ```java
      @Bean
      @Lazy
      A a(B b) { return new A(b); } // Không phá vòng lặp
      ```
- **Lưu ý**: `@Lazy` chỉ hiệu quả khi dùng với constructor/setter injection, không hiệu quả với field injection.

---

### 12. Khác nhau giữa `@Autowired` và `@Inject` (JSR-330)? Ưu/nhược khi dùng mỗi cái?
- **Khác nhau**:
    - **`@Autowired`**:
        - Thuộc Spring, tích hợp chặt với Spring container.
        - Hỗ trợ `required=false` để bỏ qua nếu không tìm thấy bean.
        - Có thể dùng với `@Qualifier` hoặc `@Primary`.
    - **`@Inject`**:
        - Thuộc JSR-330 (Java EE), framework-agnostic (có thể dùng với CDI, Guice).
        - Không hỗ trợ `required=false`, ném exception nếu bean không tồn tại.
        - Dùng `@Named` thay cho `@Qualifier`.
- **Ưu điểm**:
    - `@Autowired`: Linh hoạt hơn, tích hợp tốt với Spring features (`@Lazy`, `required=false`).
    - `@Inject`: Portable, dùng được trong nhiều framework, giảm phụ thuộc vào Spring.
- **Nhược điểm**:
    - `@Autowired`: Phụ thuộc vào Spring, khó di chuyển sang framework khác.
    - `@Inject`: Ít tính năng hơn, không hỗ trợ một số Spring-specific case.

**Lựa chọn**: Dùng `@Autowired` trong dự án Spring, `@Inject` nếu cần portability.

---

# 2) IoC Container, Bean, BeanFactory, ApplicationContext

### 1. Bean là gì? “Bean definition” khác “bean instance” ở điểm nào?
- **Bean**: Là một object được Spring IoC container quản lý (tạo, cấu hình, và destroy).
- **Bean definition**: Là metadata mô tả cách tạo bean (class, scope, dependencies, init/destroy method).
    - Lưu trong `BeanDefinition` object, lấy từ XML, Java Config, hoặc component scan.
- **Bean instance**: Là object thực tế được tạo từ bean definition.
- **Khác biệt**:
    - Definition là cấu hình (class, scope, v.v.), instance là object runtime.
    - Một definition có thể tạo một instance (singleton) hoặc nhiều instance (prototype).

---

### 2. BeanFactory vs ApplicationContext: điểm khác biệt chức năng (AOP, event, i18n, ResourceLoader…)?
- **BeanFactory**:
    - Core interface của Spring container, quản lý bean lifecycle (tạo, inject, destroy).
    - Hỗ trợ cơ bản: DI, scope, lazy initialization.
    - Nhẹ hơn, phù hợp cho ứng dụng đơn giản.
- **ApplicationContext**:
    - Mở rộng `BeanFactory`, thêm các tính năng:
        - **AOP**: Tích hợp proxy cho aspect-oriented programming.
        - **Event**: Hỗ trợ publish/listen event (`ApplicationEventPublisher`).
        - **i18n**: Hỗ trợ internationalization (`MessageSource`).
        - **ResourceLoader**: Load resources (`classpath:`, `file:`, URL).
        - **Environment**: Quản lý properties và profiles.
- **Khác biệt**:
    - `BeanFactory` chỉ tập trung vào DI, `ApplicationContext` là full-featured container.
    - `ApplicationContext` tự động register `BeanPostProcessor`, `BeanFactoryPostProcessor`.

---

### 3. Vòng đời ApplicationContext: `refresh()`, `close()`, đăng ký shutdown hook, khi nào nên gọi?
- **Vòng đời ApplicationContext**:
    - **refresh()**: Khởi tạo context, bao gồm:
        1. Tạo `BeanFactory` và load bean definitions.
        2. Áp dụng `BeanFactoryPostProcessor`.
        3. Tạo và inject beans.
        4. Gọi `BeanPostProcessor` và init methods.
    - **close()**: Đóng context, gọi destroy methods, giải phóng tài nguyên.
    - **Shutdown hook**: Đăng ký để gọi `close()` khi JVM shutdown:
      ```java
      ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
      context.registerShutdownHook();
      ```
- **Khi nào gọi**:
    - `refresh()`: Khi khởi động ứng dụng (thường tự động trong Spring Boot).
    - `close()`: Khi dừng ứng dụng hoặc trong test để giải phóng tài nguyên.
    - Shutdown hook: Trong ứng dụng standalone để đảm bảo cleanup khi JVM exit.

---

### 4. ⚠️ Gài: Vì sao **tự gọi** `new` để tạo đối tượng thay vì để container quản lý là anti-pattern trong Spring?
- **Vì sao là anti-pattern**:
    - **Mất DI**: Tự gọi `new` làm class phụ thuộc vào implementation cụ thể, tăng coupling.
    - **Không quản lý lifecycle**: Object không được Spring quản lý (no init/destroy, no AOP, no scope).
    - **Khó test**: Không thể mock/stub object do hard-coded constructor.
    - **Không tận dụng container**: Mất lợi ích của `@Autowired`, `@Lazy`, hoặc `@Profile`.
- **Ví dụ**:
  ```java
  // Anti-pattern
  public class UserService {
      private UserRepository repo = new MySQLRepo(); // Hard-coded
  }
  // Đúng
  public class UserService {
      private final UserRepository repo;
      @Autowired
      public UserService(UserRepository repo) {
          this.repo = repo;
      }
  }
  ```

---

### 5. Parent/child context dùng khi nào? Tác động đến việc tìm và override bean?
- **Parent/child context**:
    - **Parent context**: Chứa bean chung (như `DataSource`, `Service`).
    - **Child context**: Chứa bean cụ thể cho một module hoặc request (như `Controller`).
    - **Use-case**: Tách biệt cấu hình (như web context và service context) hoặc microservices.
- **Tác động tìm bean**:
    - Child context tìm bean trong nó trước, nếu không có thì tìm ở parent.
    - Parent không thấy bean trong child.
- **Override bean**:
    - Bean trong child context có cùng tên/type sẽ override bean trong parent.
- **Ví dụ**: Spring MVC dùng child context cho controllers, parent context cho services.

---

### 6. `getBean()` theo tên vs theo type: rủi ro, khi nào ném `NoSuchBeanDefinitionException` hay `NoUniqueBeanDefinitionException`?
- **`getBean()` theo tên**:
    - `context.getBean("beanName")`: Trả về bean theo tên, ném `NoSuchBeanDefinitionException` nếu không tìm thấy.
    - Rủi ro: Sai tên bean hoặc tên không duy nhất.
- **`getBean()` theo type**:
    - `context.getBean(Class)`: Trả về bean theo type, ném:
        - `NoSuchBeanDefinitionException`: Không có bean nào khớp type.
        - `NoUniqueBeanDefinitionException`: Nhiều bean cùng type, không có `@Primary` hoặc `@Qualifier`.
- **Giải pháp**: Dùng `@Qualifier` hoặc tên cụ thể để tránh ambiguity.

---

### 7. `FactoryBean` khác `BeanFactory` thế nào? Lấy **chính FactoryBean** thì dùng cú pháp gì?
- **`FactoryBean`**:
    - Là interface để tạo bean phức tạp (như proxy hoặc object cần cấu hình đặc biệt).
    - Triển khai `getObject()` để trả về bean instance.
    - Ví dụ: `MyBatis` dùng `SqlSessionFactoryBean` để tạo `SqlSession`.
- **`BeanFactory`**:
    - Là core interface của Spring container, quản lý bean lifecycle.
    - Không liên quan trực tiếp đến tạo bean phức tạp.
- **Lấy chính FactoryBean**:
    - Dùng `&` trước tên bean:
      ```java
      FactoryBean<?> factory = context.getBean("&myFactoryBean");
      Object bean = context.getBean("myFactoryBean"); // Lấy getObject()
      ```

---

### 8. Bean definition nguồn từ đâu: XML, Java Config, Component scan? Ưu/nhược mỗi cách?
- **XML**:
    - **Ưu**: Cấu hình tập trung, dễ thay đổi mà không sửa code, hỗ trợ legacy.
    - **Nhược**: Dài dòng, khó đọc, không type-safe.
- **Java Config** (`@Configuration`):
    - **Ưu**: Type-safe, tích hợp với IDE, dễ debug, hỗ trợ logic phức tạp.
    - **Nhược**: Phải recompile khi thay đổi cấu hình.
- **Component Scan** (`@Component`, `@Service`, v.v.):
    - **Ưu**: Tự động tìm bean, giảm cấu hình thủ công.
    - **Nhược**: Có thể scan nhầm class, khó kiểm soát nếu package lớn.

**Lựa chọn**: Java Config + Component Scan phổ biến nhất, XML dùng cho legacy.

---

### 9. Khi nào nên dùng `Environment`/`PropertySources` trong context? Ảnh hưởng tới tạo bean?
- **Khi nào dùng**:
    - Load cấu hình từ file (`application.properties`), environment variables, hoặc command-line arguments.
    - Ví dụ: Cấu hình DB URL, port, hoặc feature toggle.
  ```java
  @Autowired
  private Environment env;
  String url = env.getProperty("db.url");
  ```
- **Ảnh hưởng tới tạo bean**:
    - Dùng `@Value("${property}")` hoặc `@ConditionalOnProperty` để inject properties hoặc tạo bean có điều kiện.
    - `PropertySources` ưu tiên: System properties > environment variables > `application.properties`.

---

### 10. ⚠️ Gài: Vì sao gọi `ApplicationContext` như **global singleton** từ class tiện ích là code smell?
- **Vì sao là code smell**:
    - **Phụ thuộc ẩn**: Class dùng `ApplicationContext` trực tiếp, không rõ dependency.
    - **Khó test**: Cần mock context, tăng complexity.
    - **Tăng coupling**: Class phụ thuộc vào Spring, khó di chuyển sang framework khác.
    - **Không kiểm soát lifecycle**: Tự lấy context có thể bỏ qua scope, lazy init.
- **Giải pháp**:
    - Dùng DI để inject bean thay vì lấy từ context:
      ```java
      @Autowired
      private MyService service; // Thay vì context.getBean("myService")
      ```

---

### 11. Resource loading (`classpath:` vs `file:` vs URL) qua context hoạt động thế nào?
- **Resource loading**:
    - `ApplicationContext` implements `ResourceLoader`, hỗ trợ:
        - `classpath:`: Load file từ classpath (như `application.properties`).
        - `file:`: Load từ file system.
        - `URL`: Load từ HTTP/HTTPS.
  ```java
  Resource resource = context.getResource("classpath:config.properties");
  ```
- **Cơ chế**:
    - Spring dùng `Resource` interface để trừu tượng hóa file, stream, hoặc URL.
    - `PathMatchingResourcePatternResolver` hỗ trợ pattern như `classpath*:*.xml`.

---

### 12. Event trong ApplicationContext (publish/listen) áp dụng vào DI/khởi tạo như thế nào?
- **Publish/Listen event**:
    - **Publish**: Dùng `ApplicationEventPublisher` để gửi event:
      ```java
      context.publishEvent(new MyEvent(this, data));
      ```
    - **Listen**: Dùng `@EventListener` hoặc implement `ApplicationListener`:
      ```java
      @EventListener
      public void handleEvent(MyEvent event) { ... }
      ```
- **Áp dụng vào DI/khởi tạo**:
    - Gửi event khi bean khởi tạo xong (như trong `@PostConstruct`).
    - Dùng để thông báo trạng thái (như DB ready) hoặc trigger logic khác.
    - Ví dụ: Publish event để báo `UserService` sẵn sàng sau khi inject DB.

---

# 3) Các cách inject dependency: constructor, setter, field

### 1. Khi nào ưu tiên **constructor injection**? Liên hệ nguyên tắc bất biến và required dependencies.
- **Khi ưu tiên**:
    - Dependency bắt buộc (required).
    - Đảm bảo bất biến (immutability) với `final` fields.
    - Dễ test (không cần Spring context).
- **Liên hệ bất biến**:
    - Constructor injection với `final` đảm bảo dependency không đổi sau khởi tạo:
      ```java
      public class UserService {
          private final UserRepository repo;
          public UserService(UserRepository repo) {
              this.repo = Objects.requireNonNull(repo);
          }
      }
      ```
- **Required dependencies**: Constructor buộc dependency phải có, tránh NPE.

---

### 2. Setter injection thích hợp cho kiểu phụ thuộc nào? Lợi/hại về trạng thái đối tượng?
- **Thích hợp**:
    - Optional dependencies (có thể null hoặc thay đổi runtime).
    - Cần thay đổi dependency trong vòng đời object (như hot-swap).
- **Lợi**:
    - Linh hoạt, dễ thay đổi dependency mà không cần tạo mới object.
    - Phù hợp để phá circular dependency.
- **Hại**:
    - Không đảm bảo bất biến (dependency có thể đổi hoặc null).
    - Dễ gây lỗi nếu setter không được gọi đúng thời điểm.
    - Tăng boilerplate trong test (phải gọi setter).

---

### 3. Field injection: vì sao cộng đồng ít khuyến nghị? Ảnh hưởng tới DI framework khác, test, và mocking?
- **Vì sao không khuyến nghị**:
    - **Ẩn dependency**: Không thấy rõ dependency từ constructor/setter.
    - **Khó test**: Cần reflection hoặc Spring context để inject.
    - **Không bất biến**: Field có thể đổi, gây lỗi thread-safety.
- **Ảnh hưởng**:
    - **DI framework khác**: Một số framework (như Guice) không hỗ trợ field injection tốt.
    - **Test**: Phải dùng `@InjectMocks` hoặc reflection, tăng complexity.
    - **Mocking**: Khó mock field trực tiếp, cần framework hỗ trợ.

---

### 4. ⚠️ Gài: Class có **nhiều constructor**, Spring chọn cái nào? Có cần `@Autowired` ở constructor không? (Boot vs Core)
- **Spring chọn constructor**:
    - **Spring Core**:
        - Nếu chỉ có một constructor, Spring tự động chọn (không cần `@Autowired`).
        - Nếu nhiều constructor, cần `@Autowired` trên constructor mong muốn, nếu không Spring ném `BeanCreationException`.
    - **Spring Boot**:
        - Tương tự, nhưng Boot thường chỉ cần một constructor (do khuyến khích constructor injection).
        - Nếu nhiều constructor, vẫn cần `@Autowired` để chỉ định.
- **Ví dụ**:
  ```java
  public class UserService {
      private final UserRepository repo;
      @Autowired
      public UserService(UserRepository repo) { // Được chọn
          this.repo = repo;
      }
      public UserService(String dummy) { ... } // Bỏ qua
  }
  ```

---

### 5. Bài tập: Viết class có dependency bắt buộc + optional. Bạn định nghĩa constructor/setter/`Optional<T>` sao cho rõ ràng?
```java
public class UserService {
    private final UserRepository repo; // Bắt buộc
    private Logger logger; // Tùy chọn
    public UserService(UserRepository repo) {
        this.repo = Objects.requireNonNull(repo);
    }
    public void setLogger(Optional<Logger> logger) {
        this.logger = logger.orElse(null);
    }
    // Hoặc dùng Optional trong constructor
    public UserService(UserRepository repo, Optional<Logger> logger) {
        this.repo = Objects.requireNonNull(repo);
        this.logger = logger.orElse(null);
    }
}
```
- **Bắt buộc**: Dùng constructor với `final` và `Objects.requireNonNull`.
- **Tùy chọn**: Dùng setter hoặc `Optional<T>` để xử lý null an toàn.

---

### 6. Dùng Lombok `@RequiredArgsConstructor` + `final` fields có lợi gì so với setter injection?
- **Lợi**:
    - **Bất biến**: `final` fields đảm bảo dependency không đổi, tăng thread-safety.
    - **Tự động hóa**: `@RequiredArgsConstructor` tạo constructor cho tất cả `final` fields, giảm boilerplate.
    - **Rõ ràng**: Dependency bắt buộc được khai báo rõ trong constructor.
    - **Dễ test**: Không cần gọi setter trong test.
- **Ví dụ**:
  ```java
  @RequiredArgsConstructor
  public class UserService {
      private final UserRepository repo;
      private Logger logger; // Optional, dùng setter nếu cần
  }
  ```
- **So với setter injection**: Setter không đảm bảo bất biến, cần gọi thêm trong test.

---

### 7. Inject **primitive/value** bằng `@Value` có rủi ro gì (SpEL, default, conversion)?
- **Rủi ro**:
    - **SpEL lỗi**: Nếu SpEL expression (`${...}`) sai cú pháp, ném `SpelParseException`.
    - **Default không rõ ràng**: Nếu property không tồn tại và không có default (`${prop:default}`), có thể inject null hoặc giá trị không mong muốn.
    - **Type conversion**: Spring tự động convert string sang primitive, nhưng nếu không convert được, ném `TypeMismatchException`.
- **Giải pháp**:
    - Luôn cung cấp default: `@Value("${db.port:5432}")`.
    - Kiểm tra SpEL syntax cẩn thận.
    - Dùng `Environment` để truy cập property an toàn hơn.

---

### 8. Inject **bean theo điều kiện** (`@ConditionalOnProperty`, `@Profile`) phối hợp với constructor injection thế nào?
- **Cơ chế**:
    - `@ConditionalOnProperty`: Chỉ tạo bean nếu property thỏa mãn.
    - `@Profile`: Chỉ tạo bean trong profile cụ thể.
- **Phối hợp với constructor injection**:
    - Dùng `Optional<T>` hoặc `@Nullable` trong constructor:
      ```java
      public class UserService {
          private final Optional<CacheService> cache;
          public UserService(@ConditionalOnProperty("cache.enabled") Optional<CacheService> cache) {
              this.cache = cache;
          }
      }
      ```
    - Spring chỉ inject bean nếu điều kiện thỏa, nếu không thì `Optional.empty()`.

---

### 9. ⚠️ Gài: DI vòng tròn A↔B với **constructor injection** thường thất bại. Chiến lược thay thế?
- **Vì sao thất bại**: Spring cần tạo A trước nhưng A cần B, và B cần A, gây `BeanCurrentlyInCreationException`.
- **Chiến lược thay thế**:
    1. **Tái cấu trúc**: Tách logic chung thành interface hoặc facade để loại bỏ vòng lặp.
    2. **Setter injection**: Dùng setter cho một trong hai bean:
       ```java
       public class A {
           private B b;
           @Autowired
           public void setB(B b) { this.b = b; }
       }
       ```
    3. **@Lazy**: Dùng `@Lazy` trên một dependency:
       ```java
       public class A {
           public A(@Lazy B b) { ... }
       }
       ```
    4. **Event-based**: Dùng event để thông báo giữa A và B, tránh trực tiếp phụ thuộc.

---

### 10. `required=false` trong `@Autowired` trên setter/field: tác động gì tới NPE?
- **`required=false`**:
    - Cho phép Spring bỏ qua injection nếu không tìm thấy bean.
    - Setter/field không được inject, dẫn đến `null`.
- **Tác động NPE**:
    - Nếu code không kiểm tra null trước khi dùng, gây `NullPointerException`.
    - Ví dụ:
      ```java
      @Autowired(required = false)
      private Logger logger;
      public void log() {
          logger.info("Log"); // NPE nếu logger null
      }
      ```
- **Giải pháp**:
    - Dùng `Optional<T>` hoặc kiểm tra null:
      ```java
      public void log() {
          if (logger != null) logger.info("Log");
      }
      ```

---

### 11. Inject **lazy** cho bean nặng tài nguyên: `ObjectProvider<T>`/`Provider<T>` dùng ra sao?
- **`ObjectProvider<T>`** (Spring) hoặc `Provider<T>` (JSR-330):
    - Trì hoãn tạo bean đến khi gọi `get()`:
      ```java
      @Autowired
      private ObjectProvider<HeavyBean> heavyBeanProvider;
      public void useBean() {
          HeavyBean bean = heavyBeanProvider.getIfAvailable(); // Tạo khi cần
      }
      ```
- **Use-case**:
    - Bean nặng (như DB connection) chỉ cần trong một số trường hợp.
    - Tránh khởi tạo bean khi không dùng.
- **Lợi ích**: Giảm time-to-first-request, tiết kiệm tài nguyên.

---

### 12. Khi viết **integration test**, bạn thay field injection bằng constructor injection có lợi gì?
- **Lợi ích**:
    - **Dễ mock**: Constructor injection cho phép truyền mock trực tiếp:
      ```java
      UserRepository mockRepo = mock(UserRepository.class);
      UserService service = new UserService(mockRepo);
      ```
    - **Không cần Spring context**: Test chạy nhanh hơn, không cần `@SpringBootTest`.
    - **Rõ ràng dependency**: Biết chính xác dependency cần mock.
    - **An toàn hơn**: Tránh NPE do field injection không được set trong test.

---

# 4) @Component, @Service, @Repository, @Controller & Component Scan

### 1. Sự khác nhau thực chất giữa `@Component`, `@Service`, `@Repository`, `@Controller` là gì? (nghĩa ngữ nghĩa vs kỹ thuật).
- **Ngữ nghĩa**:
    - `@Component`: Generic annotation cho bất kỳ bean nào.
    - `@Service`: Dùng cho business logic (service layer).
    - `@Repository`: Dùng cho data access (DAO layer).
    - `@Controller`: Dùng cho web controllers (MVC).
- **Kỹ thuật**:
    - Tất cả đều là `@Component` (meta-annotated), được Spring scan và tạo bean.
    - `@Repository`: Kích hoạt **exception translation** (như `SQLException` → `DataAccessException`).
    - `@Controller`: Tích hợp với Spring MVC, hỗ trợ `@RequestMapping`.

---

### 2. ⚠️ Gài: `@Repository` kích hoạt **exception translation** như thế nào? Khi nào **không** hoạt động?
- **Cơ chế**:
    - `@Repository` được xử lý bởi `PersistenceExceptionTranslationPostProcessor` (tự động register trong `@EnableJpaRepositories`).
    - Chuyển đổi checked exceptions (như `SQLException`) thành Spring’s `DataAccessException`.
- **Khi không hoạt động**:
    - Không bật `@EnableJpaRepositories` hoặc không có `PersistenceExceptionTranslationPostProcessor`.
    - Class không được scan (nằm ngoài base package).
    - Exception không phải từ data access (như `NullPointerException`).
- **Xác minh**: Kiểm tra `@EnableJpaRepositories` trong config hoặc log exception.

---

### 3. Component scan tìm bean theo **base package** ra sao? Mặc định của `@SpringBootApplication` là gì?
- **Cơ chế**:
    - Spring scan tất cả class trong base package (và sub-packages) để tìm `@Component` (hoặc meta-annotations như `@Service`).
    - Tạo bean cho class có annotation phù hợp.
- **Mặc định `@SpringBootApplication`**:
    - Base package là package chứa class có `@SpringBootApplication`.
    - Ví dụ: Nếu `MainApp` trong `com.example`, Spring scan `com.example` và sub-packages.
- **Tùy chỉnh**: Dùng `@ComponentScan(basePackages = {"com.example.pkg1", "com.example.pkg2"})`.

---

### 4. Tại sao các class nên đặt **cùng hoặc dưới** package của main application?
- **Lý do**:
    - `@SpringBootApplication` mặc định scan package chứa nó và sub-packages.
    - Class ngoài package này không được scan, dẫn đến không tạo bean.
- **Hệ quả nếu không tuân thủ**:
    - Bean không được tạo, gây `NoSuchBeanDefinitionException`.
- **Giải pháp**: Dùng `@ComponentScan` để chỉ định thêm package hoặc di chuyển class vào sub-package.

---

### 5. Include/Exclude filter trong `@ComponentScan` dùng khi nào? Ví dụ loại trừ bean test stub.
- **Khi nào dùng**:
    - Lọc class cụ thể khi scan để tránh tạo bean không mong muốn (như test stubs).
    - Tùy chỉnh để chỉ scan class có annotation hoặc pattern cụ thể.
- **Ví dụ loại trừ test stub**:
  ```java
  @ComponentScan(
      basePackages = "com.example",
      excludeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = TestStub.class)
  )
  public class AppConfig {}
  ```
- **Include filter**:
  ```java
  @ComponentScan(
      basePackages = "com.example",
      includeFilters = @Filter(type = FilterType.ANNOTATION, classes = Service.class)
  )
  ```

---

### 6. Custom stereotype: tạo annotation meta-annotated với `@Component` để gộp common annotations – khi nào hữu ích?
- **Custom stereotype**:
    - Tạo annotation mới, meta-annotated với `@Component` và các annotation khác:
      ```java
      @Target(ElementType.TYPE)
      @Retention(RetentionPolicy.RUNTIME)
      @Component
      @Transactional
      public @interface MyService {}
      ```
- **Khi hữu ích**:
    - Gộp các annotation thường dùng (như `@Component`, `@Transactional`, `@Scope`).
    - Đảm bảo cấu hình nhất quán cho nhóm bean (như tất cả service đều `@Transactional`).
    - Ví dụ: Tạo `@MyService` cho các service trong ứng dụng.

---

### 7. ⚠️ Gài: Vì sao class annotated đúng mà **không được scan**? (module khác, không nằm trong base package, không có `@ComponentScan`, cấu hình bị ghi đè…)
- **Nguyên nhân**:
    - **Không nằm trong base package**: Class ngoài package của `@SpringBootApplication` hoặc `@ComponentScan`.
    - **Module khác**: Module không được import hoặc không khai báo trong `module-info.java` (Java 9+).
    - **Không có `@ComponentScan`**: Config không chỉ định base package.
    - **Cấu hình bị ghi đè**: Nhiều `@ComponentScan` với `excludeFilters` loại bỏ class.
- **Xác minh**:
    - Kiểm tra base package trong `@ComponentScan` hoặc `@SpringBootApplication`.
    - Dùng `--debug` hoặc log để xem danh sách bean được scan.
- **Giải pháp**: Thêm `@ComponentScan` hoặc di chuyển class vào base package.

---

### 8. Ảnh hưởng của `proxyBeanMethods` trong `@Configuration` (full vs lite, gọi method @Bean lồng nhau).
- **proxyBeanMethods=true** (mặc định, full mode):
    - Spring tạo CGLIB proxy cho `@Configuration` class.
    - Gọi method `@Bean` lồng nhau trả về cùng instance (singleton).
    - Đảm bảo bean consistency, nhưng có overhead do proxy.
- **proxyBeanMethods=false** (lite mode):
    - Không tạo proxy, method `@Bean` lồng nhau tạo instance mới.
    - Hiệu năng cao hơn, nhưng cần cẩn thận với singleton scope.
- **Ví dụ**:
  ```java
  @Configuration(proxyBeanMethods = true)
  public class AppConfig {
      @Bean
      DataSource ds() { return new DataSource(); }
      @Bean
      JdbcTemplate jdbcTemplate() { return new JdbcTemplate(ds()); } // Cùng instance
  }
  ```

---

### 9. `@Controller` vs `@RestController`: khác biệt và hậu quả khi gắn nhầm?
- **Khác biệt**:
    - **`@Controller`**: Dùng cho Spring MVC, trả về view name (thường dùng với Thymeleaf, JSP).
    - **`@RestController`**: Kết hợp `@Controller` và `@ResponseBody`, trả về JSON/XML trực tiếp.
- **Hậu quả khi gắn nhầm**:
    - Dùng `@Controller` cho API REST: Trả về view name thay vì JSON, gây lỗi response.
    - Dùng `@RestController` cho MVC: Không render được view, trả về raw data.

---

### 10. Khi có cả `@ComponentScan` và `@EnableJpaRepositories`/`@EntityScan`, phạm vi scan giao nhau thế nào?
- **`@ComponentScan`**: Scan `@Component`, `@Service`, `@Repository`, v.v. trong base package.
- **`@EnableJpaRepositories`**: Scan `@Repository` cho JPA repositories, thường chỉ định `basePackages` riêng.
- **`@EntityScan`**: Scan `@Entity` classes để tạo schema, không liên quan đến bean.
- **Giao nhau**:
    - Nếu base package trùng nhau, `@Repository` classes được scan bởi cả hai.
    - `@EnableJpaRepositories` ưu tiên cấu hình repository (như proxy creation).
- **Lưu ý**: Tránh trùng base package để giảm scan time và tránh nhầm lẫn.

---

### 11. Bean trùng tên khi scan & khai báo `@Bean` thủ công: Spring xử lý ưu tiên ra sao?
- **Xử lý**:
    - Bean từ `@Bean` thủ công trong `@Configuration` ưu tiên hơn bean từ component scan nếu trùng tên.
    - Spring ghi đè bean từ scan bằng bean từ `@Bean`.
- **Ví dụ**:
  ```java
  @Component("myBean")
  public class MyBean {}
  @Bean
  public MyBean myBean() { return new MyBean(); } // Thắng
  ```
- **Giải pháp**: Dùng `@Qualifier` hoặc đổi tên bean để tránh xung đột.

---

### 12. Bài tập: Cho sơ đồ packages, hãy chọn basePackages và filters để chỉ scan đúng các lớp cần thiết.
**Sơ đồ**:
```
com.example
├── service
│   ├── UserService.java (@Service)
│   ├── OrderService.java (@Service)
├── repo
│   ├── UserRepo.java (@Repository)
│   ├── TestStub.java (@Component)
```
**Yêu cầu**: Chỉ scan `@Service` và `@Repository`, loại trừ `TestStub`.

**Giải pháp**:
```java
@SpringBootApplication
@ComponentScan(
    basePackages = {"com.example.service", "com.example.repo"},
    excludeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = TestStub.class)
)
public class MainApp {}
```
- **basePackages**: Chỉ scan `service` và `repo`.
- **excludeFilters**: Loại bỏ `TestStub`.

---

# 5) Bean Lifecycle (tạo, khởi tạo, hủy)

### 1. Liệt kê **các bước** lifecycle: instantiate → populate properties → *Aware → BPP `postProcessBeforeInitialization` → init → BPP `postProcessAfterInitialization` → sử dụng → destroy.
1. **Instantiate**: Tạo instance bằng constructor.
2. **Populate properties**: Inject dependencies (constructor, setter, field).
3. **Aware interfaces**: Gọi các method của `*Aware` (như `setBeanName`).
4. **BeanPostProcessor#postProcessBeforeInitialization**: Áp dụng logic trước init (như validation).
5. **Init**: Gọi `@PostConstruct`, `afterPropertiesSet()`, custom init method.
6. **BeanPostProcessor#postProcessAfterInitialization**: Áp dụng logic sau init (như proxy creation).
7. **Sử dụng**: Bean sẵn sàng.
8. **Destroy**: Gọi `@PreDestroy`, `destroy()`, custom destroy method khi context đóng.

---

### 2. Vai trò các `*Aware` interfaces (`BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware`…)? Khi nào dùng là hợp lý?
- **Vai trò**:
    - **BeanNameAware**: Truyền tên bean vào (`setBeanName`), dùng để log hoặc điều kiện dựa trên tên.
    - **BeanFactoryAware**: Truyền `BeanFactory` để truy cập bean khác.
    - **ApplicationContextAware**: Truyền `ApplicationContext` để publish event hoặc load resource.
- **Khi dùng hợp lý**:
    - Khi bean cần biết metadata (như tên) hoặc truy cập container (như lấy bean động).
    - Ví dụ: `ApplicationContextAware` để publish event:
      ```java
      public class MyBean implements ApplicationContextAware {
          private ApplicationContext context;
          @Override
          public void setApplicationContext(ApplicationContext context) {
              this.context = context;
          }
      }
      ```
- **Lưu ý**: Tránh lạm dụng, tăng coupling với container.

---

### 3. BeanPostProcessor là gì? Viết ví dụ use-case thực tế (logging, validation, proxy hóa).
- **BeanPostProcessor**: Interface cho phép can thiệp trước/sau khởi tạo bean (như modify bean, tạo proxy).
- **Use-case**:
    - **Logging**: Log khi bean khởi tạo.
    - **Validation**: Kiểm tra cấu hình bean.
    - **Proxy hóa**: Tạo AOP proxy.
- **Ví dụ logging**:
  ```java
  public class LoggingBeanPostProcessor implements BeanPostProcessor {
      @Override
      public Object postProcessBeforeInitialization(Object bean, String beanName) {
          System.out.println("Before init: " + beanName);
          return bean;
      }
      @Override
      public Object postProcessAfterInitialization(Object bean, String beanName) {
          System.out.println("After init: " + beanName);
          return bean;
      }
  }
  ```

---

### 4. ⚠️ Gài: Thứ tự thực thi nhiều BPP (`@Order`), ảnh hưởng nếu thứ tự sai?
- **Thứ tự**:
    - Dùng `@Order(n)` hoặc implement `Ordered` để chỉ định thứ tự `BeanPostProcessor`.
    - Thấp hơn `n` chạy trước.
- **Ảnh hưởng nếu sai**:
    - Proxy creation (như AOP) cần chạy sau validation, nếu sai thứ tự có thể proxy bean chưa hợp lệ.
    - Ví dụ: Nếu logging BPP chạy sau AOP BPP, log không ghi được trạng thái gốc của bean.
- **Giải pháp**: Đặt `@Order` rõ ràng, ưu tiên BPP quan trọng (như AOP) sau cùng.

---

### 5. `SmartInitializingSingleton` làm gì? Khác `InitializingBean` ra sao?
- **`SmartInitializingSingleton`**:
    - Gọi `afterSingletonsInstantiated()` sau khi tất cả singleton beans được khởi tạo.
    - Dùng để thực hiện logic phụ thuộc vào nhiều bean (như pre-warming cache).
- **`InitializingBean`**:
    - Gọi `afterPropertiesSet()` ngay sau khi bean được inject dependencies.
    - Dùng để khởi tạo logic nội tại của bean.
- **Khác biệt**:
    - `SmartInitializingSingleton`: Chạy một lần sau khi tất cả singleton sẵn sàng.
    - `InitializingBean`: Chạy riêng cho mỗi bean.

---

### 6. `@DependsOn` dùng khi nào? Có nên lạm dụng để “sửa” vấn đề thứ tự?
- **Khi dùng**:
    - Đảm bảo bean A được khởi tạo trước bean B:
      ```java
      @Bean
      @DependsOn("dataSource")
      JdbcTemplate jdbcTemplate() { ... }
      ```
    - Use-case: Khởi tạo DB trước khi tạo repository.
- **Lạm dụng**:
    - Tăng coupling, làm cấu hình khó hiểu.
    - Không giải quyết được vấn đề thiết kế sai (như circular dependency).
- **Giải pháp**: Tái cấu trúc code hoặc dùng `@Lazy` thay vì lạm dụng `@DependsOn`.

---

### 7. Khởi tạo **eager vs lazy** khác nhau thế nào? Ảnh hưởng tới time-to-first-request?
- **Eager**:
    - Bean được tạo ngay khi context `refresh()`, thường cho singleton.
    - Tăng time-to-first-request do khởi tạo trước.
- **Lazy**:
    - Bean được tạo khi gọi `getBean()` hoặc inject lần đầu.
    - Giảm time-to-first-request, nhưng có thể gây latency khi bean được truy cập.
- **Ảnh hưởng**:
    - Eager phù hợp khi cần tất cả bean sẵn sàng (như DB connection).
    - Lazy dùng cho bean nặng hoặc hiếm dùng (như cache).

---

### 8. ⚠️ Gài: Prototype scope có được gọi destroy phase không? Vì sao nhiều người hiểu nhầm?
- **Prototype scope**:
    - **Không gọi destroy phase**: Spring không quản lý lifecycle của prototype bean sau khi trả về client.
    - Lý do: Spring không giữ tham chiếu đến prototype instance, không biết khi nào destroy.
- **Hiểu nhầm**:
    - Nhiều người nghĩ `@PreDestroy` sẽ chạy như singleton, nhưng chỉ singleton/request/session scope gọi destroy.
- **Giải pháp**:
    - Implement `DisposableBean` hoặc custom cleanup logic khi client không cần prototype bean nữa.

---

### 9. Interaction giữa lifecycle và AOP proxy: `@PostConstruct` chạy trên proxy hay target? Hệ quả là gì?
- **@PostConstruct**:
    - Chạy trên **target object**, không phải proxy.
    - Lý do: `@PostConstruct` được gọi bởi `InitDestroyAnnotationBeanPostProcessor` trước khi AOP proxy được tạo.
- **Hệ quả**:
    - Logic trong `@PostConstruct` không được AOP intercept (như `@Transactional`).
    - Nếu cần AOP trong init, dùng `afterPropertiesSet()` hoặc custom init method trong proxy.

---

### 10. Truyền tham số cấu hình từ `Environment`/`PropertySources` vào lifecycle như thế nào?
- **Cách truyền**:
    - Dùng `@Value` để inject property vào bean:
      ```java
      @Value("${db.url}")
      private String dbUrl;
      ```
    - Dùng `Environment` trong `@PostConstruct`:
      ```java
      @Autowired
      private Environment env;
      @PostConstruct
      public void init() {
          String url = env.getProperty("db.url");
      }
      ```
- **Use-case**: Cấu hình DB, API endpoint, hoặc feature toggle trong init/destroy phase.

---

### 11. Exception trong init/destroy dẫn tới điều gì? Context có **fail fast** không?
- **Exception trong init**:
    - Ném `BeanCreationException`, làm context `refresh()` thất bại.
    - Context không khởi tạo được, ứng dụng dừng.
- **Exception trong destroy**:
    - Ném `BeanDestructionException`, nhưng không ảnh hưởng context khác.
    - Context vẫn đóng, nhưng tài nguyên có thể không được cleanup đúng.
- **Fail fast**: Context fail fast trong init, không trong destroy.

---

### 12. Bài tập: Hãy sắp xếp đúng thứ tự gọi khi có cả: `*Aware` → BPP → `@PostConstruct` → `afterPropertiesSet()` → `initMethod`.
1. Constructor
2. Inject dependencies
3. `*Aware` interfaces (`setBeanName`, `setApplicationContext`, v.v.)
4. `BeanPostProcessor#postProcessBeforeInitialization`
5. `@PostConstruct`
6. `InitializingBean#afterPropertiesSet()`
7. Custom `initMethod` (định nghĩa trong `@Bean(initMethod = "...")`)
8. `BeanPostProcessor#postProcessAfterInitialization`

---

# 6) @PostConstruct, @PreDestroy, InitializingBean, DisposableBean

### 1. So sánh `@PostConstruct` với `InitializingBean#afterPropertiesSet()` và `initMethod` cấu hình trong `@Bean`. Ưu/nhược từng cách.
- **`@PostConstruct`**:
    - **Ưu**: Chuẩn JSR-250, portable, dễ dùng, không phụ thuộc Spring.
    - **Nhược**: Không chạy trên prototype scope nếu không quản lý lifecycle.
- **`InitializingBean#afterPropertiesSet()`**:
    - **Ưu**: Linh hoạt, cho phép logic phức tạp trong code.
    - **Nhược**: Phụ thuộc Spring, không portable.
- **`initMethod` (trong `@Bean`)**:
    - **Ưu**: Không cần implement interface, dễ cấu hình trong `@Configuration`.
    - **Nhược**: Cần khai báo trong bean definition, dễ bỏ sót.

**Lựa chọn**: Dùng `@PostConstruct` cho đơn giản, `initMethod` cho cấu hình tập trung.

---

### 2. Thứ tự **chính xác** lúc khởi tạo: constructor → DI → `@PostConstruct` → `afterPropertiesSet()` → custom initMethod.
- Xác nhận đúng:
    1. Constructor
    2. Dependency Injection (constructor, setter, field)
    3. `@PostConstruct`
    4. `afterPropertiesSet()`
    5. Custom `initMethod`

---

### 3. Thứ tự **chính xác** lúc hủy: `@PreDestroy` → `DisposableBean#destroy()` → custom destroyMethod.
- Xác nhận đúng:
    1. `@PreDestroy`
    2. `DisposableBean#destroy()`
    3. Custom `destroyMethod`

---

### 4. ⚠️ Gài: Khi bean là **prototype**, `@PreDestroy` có chạy không? Nếu không, muốn chạy thì làm sao?
- **Không chạy**:
    - Prototype beans không được Spring quản lý lifecycle sau khi trả về client.
    - `@PreDestroy` chỉ chạy cho singleton/request/session scope.
- **Cách chạy**:
    - Implement `DisposableBean` và gọi `destroy()` thủ công:
      ```java
      public class MyBean implements DisposableBean {
          @Override
          public void destroy() { ... }
      }
      MyBean bean = context.getBean(MyBean.class);
      bean.destroy();
      ```
    - Dùng `DisposableBeanAdapter` để register cleanup logic.

---

### 5. `@PostConstruct` nên (hoặc không nên) làm gì? Ví dụ: mở connection nặng vs validate cấu hình.
- **Nên**:
    - Validate cấu hình (như kiểm tra properties).
    - Khởi tạo tài nguyên nhẹ (như cache).
- **Không nên**:
    - Mở connection nặng (như DB connection) vì có thể làm chậm context startup.
    - Thực hiện logic phức tạp, nên để trong service method.
- **Ví dụ**:
  ```java
  @PostConstruct
  public void init() {
      validateConfig(); // OK
      // openDbConnection(); // Không nên
  }
  ```

---

### 6. Nếu `@PostConstruct` ném exception, chuyện gì xảy ra với context?
- Ném `BeanCreationException`, làm context `refresh()` thất bại.
- Ứng dụng dừng khởi động, không tạo được bean khác.
- **Giải pháp**: Xử lý exception trong `@PostConstruct` hoặc dùng `try-catch`.

---

### 7. Sự khác nhau khi đặt `@PostConstruct` trên **proxy class** vs **target class**? (JDK dynamic proxy vs CGLIB)
- **Target class**:
    - `@PostConstruct` chạy trên target object trước khi proxy được tạo.
    - Không bị ảnh hưởng bởi AOP.
- **Proxy class**:
    - Với JDK dynamic proxy: Chỉ áp dụng cho interface, `@PostConstruct` vẫn chạy trên target.
    - Với CGLIB: Proxy kế thừa target, `@PostConstruct` chạy trên target, không trên proxy.
- **Hệ quả**: Logic trong `@PostConstruct` không được AOP intercept.

---

### 8. Dùng `DisposableBean` khi nào thay vì `@PreDestroy`?
- **Khi dùng**:
    - Cần logic cleanup phức tạp trong code (như đóng nhiều tài nguyên).
    - Bean không dùng `@PreDestroy` (như trong legacy code).
- **Ví dụ**:
  ```java
  public class MyBean implements DisposableBean {
      @Override
      public void destroy() {
          closeResources();
      }
  }
  ```
- **Lưu ý**: `@PreDestroy` thường được ưu tiên vì portable và đơn giản hơn.

---

### 9. ⚠️ Gài: Annotate `@PostConstruct` vào **private method** có chạy không? Vào **static method** thì sao?
- **Private method**:
    - **Có chạy**: Spring dùng reflection để gọi `@PostConstruct` trên private method.
    - Ví dụ:
      ```java
      @PostConstruct
      private void init() { ... } // OK
      ```
- **Static method**:
    - **Không chạy**: `@PostConstruct` chỉ áp dụng cho instance method.
    - Spring bỏ qua static method, không ném lỗi.

---

### 10. Có thể gọi thủ công `afterPropertiesSet()` không? Tác hại?
- **Có thể gọi**:
    - Gọi trực tiếp trên bean implement `InitializingBean`.
- **Tác hại**:
    - Phá vỡ lifecycle của Spring, có thể gọi sai thời điểm (trước khi DI hoàn tất).
    - Gây trạng thái không nhất quán (như init hai lần).
    - Giảm tính portable, tăng coupling với Spring.
- **Giải pháp**: Để Spring tự gọi trong lifecycle.

---

### 11. Ảnh hưởng của `@Lazy` lên thời điểm chạy `@PostConstruct`?
- `@Lazy` trì hoãn khởi tạo bean đến khi gọi `getBean()` hoặc inject lần đầu.
- `@PostConstruct` chỉ chạy khi bean thực sự được tạo (không phải khi context `refresh()`).
- **Hệ quả**: Giảm time-to-first-request, nhưng có thể gây latency khi bean được truy cập.

---

### 12. Bài tập: Cho code bean mở connection trong `@PostConstruct` và đóng trong `@PreDestroy`. Hãy nêu rủi ro khi deploy nhiều instance và đề xuất cải tiến.
**Code**:
```java
@Component
public class DbBean {
    private Connection conn;
    @PostConstruct
    public void init() throws SQLException {
        conn = DriverManager.getConnection("jdbc:mysql://...");
    }
    @PreDestroy
    public void destroy() throws SQLException {
        conn.close();
    }
}
```
- **Rủi ro khi deploy nhiều instance**:
    - **Connection leak**: Nếu `@PreDestroy` không chạy (như context không đóng đúng), connection không được đóng.
    - **Resource exhaustion**: Nhiều instance mở nhiều connection, vượt quá giới hạn DB.
    - **Startup chậm**: Mở connection trong `@PostConstruct` làm chậm context startup.
- **Cải tiến**:
    - Dùng `DataSource` thay vì `DriverManager` để quản lý connection pool:
      ```java
      @Component
      public class DbBean {
          private final DataSource dataSource;
          @Autowired
          public DbBean(DataSource dataSource) {
              this.dataSource = dataSource;
          }
          public Connection getConnection() throws SQLException {
              return dataSource.getConnection(); // Lấy từ pool
          }
      }
      ```
    - Trì hoãn mở connection đến khi cần (lazy).
    - Dùng `@PreDestroy` trong `DataSource` bean để đóng pool.

---

# 7) Scope của Bean: singleton, prototype, request, session

### 1. Mặc định scope là gì? Vì sao **stateless singleton** là mẫu khuyến nghị?
- **Mặc định**: Singleton (một instance duy nhất trong context).
- **Vì sao stateless singleton khuyến nghị**:
    - **Hiệu năng**: Chỉ tạo một instance, giảm memory và startup time.
    - **Thread-safety**: Stateless bean không lưu state, tránh race condition.
    - **Đơn giản**: Dễ quản lý, không cần lo lifecycle phức tạp.

---

### 2. Khi nào dùng prototype? Rủi ro nếu inject prototype vào singleton?
- **Khi dùng prototype**:
    - Cần instance mới mỗi khi inject hoặc gọi `getBean()`.
    - Ví dụ: Bean lưu trạng thái request-specific (như form data).
- **Rủi ro inject prototype vào singleton**:
    - Singleton chỉ inject prototype một lần, dẫn đến tái sử dụng instance cũ:
      ```java
      @Component
      @Scope("prototype")
      public class ProtoBean {}
      @Component
      public class SingleBean {
          @Autowired
          private ProtoBean proto; // Chỉ một instance
      }
      ```
    - Hệ quả: ProtoBean không tạo mới, gây lỗi logic nếu cần instance mới.
- **Giải pháp**: Dùng `ObjectProvider` hoặc scoped proxy.

---

### 3. ⚠️ Gài: Inject prototype vào singleton **không** tạo instance mới mỗi lần dùng—tại sao? Giải pháp: `ObjectFactory<T>`/`Provider<T>`/scoped proxy?
- **Tại sao**:
    - Singleton bean được tạo một lần, dependency (prototype) được inject một lần và giữ nguyên.
    - Spring không biết singleton cần instance mới của prototype.
- **Giải pháp**:
    - **`ObjectProvider<T>`**:
      ```java
      @Autowired
      private ObjectProvider<ProtoBean> protoProvider;
      public ProtoBean getProto() {
          return protoProvider.getObject(); // Tạo mới mỗi lần
      }
      ```
    - **`Provider<T>` (JSR-330)**: Tương tự `ObjectProvider`.
    - **Scoped proxy**:
      ```java
      @Component
      @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class ProtoBean {}
      ```
        - Spring tạo proxy, mỗi lần gọi method tạo instance mới.

---

### 4. Request/session scope hoạt động trong **web context** ra sao? Cần gì để hoạt động trong test hoặc non-web?
- **Request scope**:
    - Bean tạo mới cho mỗi HTTP request, destroy khi request hoàn tất.
    - Dùng cho request-specific data (như user session).
- **Session scope**:
    - Bean tạo mới cho mỗi HTTP session, destroy khi session hết hạn.
- **Web context**:
    - Yêu cầu `WebApplicationContext` (như trong Spring MVC).
    - Spring lưu bean trong `HttpServletRequest` hoặc `HttpSession`.
- **Test/non-web**:
    - Dùng `SimpleThreadScope` hoặc custom scope để mô phỏng.
    - Cần register scope với context:
      ```java
      @Bean
      public static CustomScopeConfigurer scopeConfigurer() {
          CustomScopeConfigurer configurer = new CustomScopeConfigurer();
          configurer.addScope("request", new SimpleThreadScope());
          return configurer;
      }
      ```

---

### 5. `@Scope(proxyMode=...)` làm gì? Ảnh hưởng tới equals/hashCode/toString?
- **`@Scope(proxyMode=...)`**:
    - Tạo proxy cho bean (JDK dynamic proxy hoặc CGLIB) để quản lý scope.
    - `proxyMode=TARGET_CLASS`: Dùng CGLIB, hỗ trợ class-based proxy.
    - `proxyMode=INTERFACES`: Dùng JDK proxy, chỉ cho interface.
- **Ảnh hưởng**:
    - **equals/hashCode/toString**: Proxy trả về kết quả của proxy, không phải target object.
    - Có thể gây vấn đề nếu code phụ thuộc vào `equals` của target class.
- **Giải pháp**: Dùng `ObjectProvider` nếu không cần proxy.

---

### 6. Thread-safety của singleton: cách tránh state shared gây race?
- **Vấn đề**: Singleton bean chia sẻ state (như field không `final`) gây race condition khi nhiều thread truy cập.
- **Giải pháp**:
    - Giữ bean **stateless** (không lưu state trong field).
    - Dùng `synchronized`, `ReentrantLock`, hoặc `Atomic` cho state:
      ```java
      public class CounterService {
          private final AtomicInteger counter = new AtomicInteger();
          public int increment() {
              return counter.incrementAndGet();
          }
      }
      ```
    - Dùng request scope cho state-specific data.

---

### 7. ⚠️ Gài: Sử dụng bean request-scope trong service singleton (được gọi từ thread pool) có an toàn không?
- **Không an toàn**:
    - Request-scope bean cần `WebApplicationContext` và `HttpServletRequest`.
    - Thread pool (như `@Async`) không có request context, gây `ScopeNotActiveException`.
- **Giải pháp**:
    - Dùng `ObjectProvider` để lấy request-scope bean khi có context:
      ```java
      @Autowired
      private ObjectProvider<RequestBean> requestBeanProvider;
      public void asyncMethod() {
          RequestBean bean = requestBeanProvider.getIfAvailable();
          if (bean != null) { ... }
      }
      ```
    - Dùng `RequestContextHolder` để truy cập request context:
      ```java
      HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
      ```

---

### 8. Custom scope (ví dụ “tenant” scope): cách xây dựng và use-case.
- **Cách xây dựng**:
    1. Implement `Scope` interface:
       ```java
       public class TenantScope implements Scope {
           private final Map<String, Object> beans = new ConcurrentHashMap<>();
           @Override
           public Object get(String name, ObjectFactory<?> objectFactory) {
               String tenant = TenantContext.getCurrentTenant();
               String key = tenant + ":" + name;
               return beans.computeIfAbsent(key, k -> objectFactory.getObject());
           }
           @Override
           public Object remove(String name) { ... }
           @Override
           public void registerDestructionCallback(String name, Runnable callback) { ... }
           @Override
           public String getConversationId() { return TenantContext.getCurrentTenant(); }
           @Override
           public Object resolveContextualObject(String key) { return null; }
       }
       ```
    2. Register scope:
       ```java
       @Bean
       public static CustomScopeConfigurer scopeConfigurer() {
           CustomScopeConfigurer configurer = new CustomScopeConfigurer();
           configurer.addScope("tenant", new TenantScope());
           return configurer;
       }
       ```
- **Use-case**: Multi-tenant ứng dụng, mỗi tenant có bean riêng (như DB connection).

---

### 9. Sự khác biệt lifecycle destroy giữa singleton vs request/session? Ai thu dọn tài nguyên khi session hết hạn?
- **Singleton**:
    - Destroy khi context đóng (`close()`), gọi `@PreDestroy`, `destroy()`.
- **Request scope**:
    - Destroy khi HTTP request hoàn tất, Spring gọi `@PreDestroy`.
- **Session scope**:
    - Destroy khi `HttpSession` hết hạn, Spring gọi `@PreDestroy` thông qua `HttpSessionBindingListener`.
- **Ai thu dọn**: `WebApplicationContext` quản lý cleanup cho request/session scope.

---

### 10. Dùng scope kết hợp `@Async`/`@Scheduled`: tình huống “leak” hoặc context không hợp lệ?
- **Vấn đề**:
    - `@Async`/`@Scheduled` chạy trong thread pool, không có request/session context.
    - Request/session scope bean gây `ScopeNotActiveException`.
- **Leak**:
    - Nếu thread pool giữ tham chiếu đến request-scope bean, gây memory leak.
- **Giải pháp**:
    - Dùng `ObjectProvider` để lấy bean khi cần.
    - Dùng `RequestContextHolder` để truyền context vào async thread.

---

### 11. Bài tập: Thiết kế dịch vụ upload sử dụng bean theo request để chứa metadata, đảm bảo không rò rỉ sang request khác.
```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UploadMetadata {
    private Map<String, String> metadata = new HashMap<>();
    public void setMetadata(String key, String value) {
        metadata.put(key, value);
    }
}
@Component
public class UploadService {
    private final ObjectProvider<UploadMetadata> metadataProvider;
    @Autowired
    public UploadService(ObjectProvider<UploadMetadata> metadataProvider) {
        this.metadataProvider = metadataProvider;
    }
    public void upload(HttpServletRequest request, String file) {
        UploadMetadata metadata = metadataProvider.getObject();
        metadata.setMetadata("file", file);
    }
}
```
- **Đảm bảo không rò rỉ**: Request scope đảm bảo mỗi request có instance riêng, proxyMode xử lý injection vào singleton.

---

### 12. Khi test với `@DirtiesContext`/`@TestConfiguration`, scope ảnh hưởng thế nào tới hiệu năng test?
- **Ảnh hưởng**:
    - **Singleton**: Tái sử dụng giữa test, nhanh hơn, nhưng `@DirtiesContext` làm context reload, tăng thời gian.
    - **Request/Session scope**: Tạo mới mỗi request trong test, tăng overhead nếu test nhiều request.
    - **Prototype**: Tạo instance mới mỗi lần inject, làm test chậm hơn.
- **@TestConfiguration**:
    - Tạo context riêng, giảm phụ thuộc vào main context, nhưng tăng startup time.
- **Tối ưu**:
    - Tránh `@DirtiesContext` nếu không cần.
    - Dùng mock/stub thay vì full context.

---

# Mini Case (thực chiến ngắn)

### 1. Bạn có 2 service A và B (constructor injection) phụ thuộc lẫn nhau. Hãy liệt kê 3 cách thiết kế để loại bỏ vòng lặp mà vẫn giữ bất biến tốt.
1. **Tái cấu trúc**:
    - Tạo interface `CommonLogic` và class `CommonService` chứa logic chung:
      ```java
      public interface CommonLogic { ... }
      @Service
      public class CommonService implements CommonLogic { ... }
      @Service
      public class A {
          private final CommonLogic common;
          public A(CommonLogic common) { this.common = common; }
      }
      @Service
      public class B {
          public B(CommonLogic common) { this.common = common; }
      }
      ```
2. **Dùng `@Lazy`**:
   ```java
   @Service
   public class A {
       private final B b;
       public A(@Lazy B b) { this.b = b; }
   }
   ```
3. **Event-based**:
    - Dùng `ApplicationEventPublisher` để A và B giao tiếp qua event, tránh trực tiếp phụ thuộc.

---

### 2. Một bean `ImageCache` rất nặng, cold start 3s. Nêu 3 cách giảm **TTS** (time to serve): lazy, pre-warm ở `SmartInitializingSingleton`, hay split module… Phân tích trade-off.
1. **Lazy initialization**:
    - Dùng `@Lazy` để trì hoãn tạo `ImageCache`:
      ```java
      @Bean
      @Lazy
      ImageCache imageCache() { return new ImageCache(); }
      ```
    - **Trade-off**: Giảm TTS, nhưng tăng latency khi `ImageCache` được truy cập lần đầu.
2. **Pre-warm với `SmartInitializingSingleton`**:
   ```java
   @Component
   public class CacheWarmer implements SmartInitializingSingleton {
       @Autowired
       private ImageCache cache;
       @Override
       public void afterSingletonsInstantiated() {
           cache.warmUp();
       }
   }
   ```
    - **Trade-off**: Tăng TTS do warm-up, nhưng đảm bảo cache sẵn sàng khi dùng.
3. **Split module**:
    - Tách `ImageCache` thành module riêng, load async hoặc khi cần.
    - **Trade-off**: Giảm TTS cho main app, nhưng tăng complexity quản lý module.

---

### 3. Bạn cần một bean `RequestContext` chỉ sống theo request nhưng service là singleton. Hãy cho 2 cách inject hợp lệ và rủi ro của mỗi cách.
1. **ObjectProvider**:
   ```java
   @Service
   public class MyService {
       private final ObjectProvider<RequestContext> contextProvider;
       @Autowired
       public MyService(ObjectProvider<RequestContext> contextProvider) {
           this.contextProvider = contextProvider;
       }
       public void process() {
           RequestContext context = contextProvider.getObject();
       }
   }
   ```
    - **Rủi ro**: Ném `ScopeNotActiveException` nếu gọi ngoài request context.
2. **Scoped proxy**:
   ```java
   @Component
   @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
   public class RequestContext {}
   @Service
   public class MyService {
       private final RequestContext context;
       @Autowired
       public MyService(RequestContext context) {
           this.context = context;
       }
   }
   ```
    - **Rủi ro**: Proxy tăng overhead, có thể gây lỗi nếu request context không hợp lệ.

---

### 4. Một `@Repository` không translate `SQLException` sang `DataAccessException`. Hãy liệt kê các nguyên nhân có thể và cách xác minh.
- **Nguyên nhân**:
    1. Không bật `@EnableJpaRepositories` hoặc `PersistenceExceptionTranslationPostProcessor`.
    2. Class không được scan (ngoài base package).
    3. Exception không phải từ data access (như `NullPointerException`).
- **Xác minh**:
    - Kiểm tra `@EnableJpaRepositories` trong config.
    - Dùng `--debug` để log bean registration.
    - Kiểm tra stack trace của exception để xác định nguồn gốc.

---

### 5. Prototype bean mở file handler trong `@PostConstruct`, không bao giờ đóng. Mô tả hậu quả và chiến lược đóng tài nguyên đúng chỗ.
- **Hậu quả**:
    - **Resource leak**: File handler không được đóng, gây hết file descriptors.
    - **Memory leak**: Prototype instances không được GC vì giữ tài nguyên.
- **Chiến lược đóng**:
    - Implement `DisposableBean` và gọi `destroy()` thủ công:
      ```java
      @Component
      @Scope("prototype")
      public class FileBean implements DisposableBean {
          private FileInputStream fis;
          @PostConstruct
          public void init() throws IOException {
              fis = new FileInputStream("file.txt");
          }
          @Override
          public void destroy() throws IOException {
              fis.close();
          }
      }
      FileBean bean = context.getBean(FileBean.class);
      bean.destroy();
      ```
    - Dùng try-with-resources để quản lý tài nguyên thay vì `@PostConstruct`.

---

