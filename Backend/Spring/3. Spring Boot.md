# 1) Cấu trúc dự án Spring Boot

### 1. Cấu trúc thư mục tiêu chuẩn của một app Spring Boot (Maven/Gradle) gồm những gì? Vai trò của `src/main/java`, `src/main/resources`, `src/test/java`?
- **Cấu trúc thư mục** (Maven/Gradle):
  ```
  project-root/
  ├── src/
  │   ├── main/
  │   │   ├── java/                 # Code Java
  │   │   ├── resources/            # Tài nguyên ứng dụng
  │   ├── test/
  │   │   ├── java/                 # Unit/Integration tests
  │   │   ├── resources/            # Tài nguyên cho test
  ├── pom.xml / build.gradle        # File cấu hình build
  ```
- **Vai trò**:
    - **`src/main/java`**: Chứa code Java (controllers, services, repositories, entities, …).
    - **`src/main/resources`**: Chứa tài nguyên như:
        - `application.properties`/`application.yml`: Cấu hình ứng dụng.
        - `static/`: File tĩnh (CSS, JS, images).
        - `templates/`: Template cho view (Thymeleaf, Freemarker).
    - **`src/test/java`**: Chứa test code (JUnit, Mockito, TestRestTemplate).
    - **`src/test/resources`**: Cấu hình và tài nguyên cho test (như `application-test.yml`).
- **Lưu ý**: Maven/Gradle tự động nhận diện cấu trúc này để compile/package.

---

### 2. Vì sao nên đặt lớp `Application` (chứa `main`) ở **root package**? Ảnh hưởng tới **component scanning** nếu đặt sai?
- **Vì sao đặt ở root package**:
    - `@SpringBootApplication` bao gồm `@ComponentScan`, tự động quét các bean trong package chứa lớp `Application` và các sub-package.
    - Đặt ở root (như `com.example`) đảm bảo quét hết các `@Component`, `@Service`, `@Repository`, `@Controller`, … trong dự án.
- **Ảnh hưởng nếu đặt sai**:
    - Nếu đặt trong sub-package (như `com.example.controller`), chỉ quét được bean trong sub-package đó, bỏ sót các bean ở package khác (như `com.example.service`).
    - Gây lỗi `NoSuchBeanDefinitionException` khi Spring không tìm thấy bean.
- **Giải pháp**:
    - Đặt `Application` ở root package.
    - Chỉ định package quét: `@ComponentScan("com.example")`.

---

### 3. Tổ chức package theo **layer** (controller/service/repository) vs theo **feature/module**: trade-off?
- **Theo layer**:
    - Cấu trúc:
      ```
      com.example/
      ├── controller/
      ├── service/
      ├── repository/
      ├── entity/
      ```
    - **Ưu**:
        - Rõ ràng vai trò từng tầng (MVC, DDD).
        - Dễ áp dụng cho dự án nhỏ, ít module.
    - **Nhược**:
        - Khó scale khi dự án lớn, các class trong cùng layer khó tìm.
        - Logic liên quan đến một feature phân tán nhiều nơi.
- **Theo feature/module**:
    - Cấu trúc:
      ```
      com.example/
      ├── user/
      │   ├── UserController.java
      │   ├── UserService.java
      │   ├── UserRepository.java
      │   ├── User.java
      ├── order/
      ```
    - **Ưu**:
        - Tất cả code liên quan đến một feature ở cùng chỗ, dễ bảo trì.
        - Phù hợp với microservices hoặc dự án lớn.
    - **Nhược**:
        - Có thể lặp code (như util) nếu không tách shared module.
        - Cần quy tắc chặt chẽ để tránh lộn xộn.
- **Trade-off**:
    - **Layer**: Tốt cho dự án nhỏ, cần phân tầng rõ ràng.
    - **Feature**: Tốt cho dự án lớn, cần modularization.
    - **Kết hợp**: Tách module theo feature, nhưng giữ layer trong module nhỏ.

---

### 4. ⚠️ Gài: Tạo nhiều module (multi-module) trong một hệ thống Boot — chọn module nào giữ **parent** và quản lý BOM thế nào?
- **Module parent**:
    - Module parent không nên là module chạy Spring Boot (chứa `@SpringBootApplication`).
    - Parent là module chứa `pom.xml`/`build.gradle` tổng, quản lý:
        - Dependencies (BOM).
        - Plugins (như `spring-boot-maven-plugin`).
        - Module con (như `api`, `domain`, `common`).
    - Ví dụ:
      ```
      project/
      ├── parent/                   # Module parent
      │   ├── pom.xml
      ├── api/                      # Module REST API
      ├── domain/                   # Module business logic
      ├── common/                   # Module chia sẻ
      ```
- **Quản lý BOM**:
    - Sử dụng `spring-boot-dependencies` trong parent:
      ```xml
      <dependencyManagement>
          <dependencies>
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-dependencies</artifactId>
                  <version>${spring-boot.version}</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
          </dependencies>
      </dependencyManagement>
      ```
    - Module con chỉ cần khai báo dependency mà không cần version:
      ```xml
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      ```
- **Lưu ý**: Parent không chứa code ứng dụng, chỉ quản lý build.

---

### 5. Đóng gói **fat jar** là gì? Khác gì với war? Khi nào cần build war?
- **Fat JAR**:
    - Là file JAR chứa tất cả dependencies và code ứng dụng, chạy độc lập với `java -jar`.
    - Spring Boot dùng `spring-boot-maven-plugin` để tạo fat JAR, nhúng embedded server (Tomcat, Jetty).
- **Khác WAR**:
    - **WAR**: File deploy lên external server (như Tomcat), không nhúng server.
    - **Fat JAR**: Tự chứa server, không cần external server.
- **Khi cần WAR**:
    - Deploy lên server truyền thống (Tomcat, WebSphere).
    - Yêu cầu doanh nghiệp dùng WAR để quản lý server.
    - Cấu hình WAR:
      ```xml
      <packaging>war</packaging>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-tomcat</artifactId>
          <scope>provided</scope>
      </dependency>
      ```
- **Lưu ý**: WAR cần class `SpringBootServletInitializer`.

---

### 6. Spring Boot Maven/Gradle plugin làm những việc gì khi package/run/repackage?
- **Spring Boot Maven Plugin**:
    - **package**: Tạo fat JAR/WAR, nhúng dependencies và cấu hình manifest.
    - **run**: Chạy ứng dụng với embedded server.
    - **repackage**: Tạo fat JAR từ JAR thường, thêm Spring Boot loader.
    - Ví dụ:
      ```xml
      <plugin>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-maven-plugin</artifactId>
          <executions>
              <execution>
                  <goals>
                      <goal>repackage</goal>
                  </goals>
              </execution>
          </executions>
      </plugin>
      ```
- **Spring Boot Gradle Plugin**:
    - **Tasks**: `bootJar` (tạo fat JAR), `bootRun` (chạy app), `bootWar` (tạo WAR).
    - Ví dụ:
      ```gradle
      plugins {
          id 'org.springframework.boot' version '3.2.0'
      }
      bootJar {
          archiveFileName = 'my-app.jar'
      }
      ```

---

### 7. Cách cấu hình profiles theo file (`application-dev.yml`) và theo môi trường (ENV/CLI) khác nhau thế nào?
- **Theo file**:
    - Tạo file `application-{profile}.yml` (như `application-dev.yml`).
    - Kích hoạt profile:
      ```properties
      spring.profiles.active=dev
      ```
    - Hoặc trong code:
      ```java
      @SpringBootApplication
      public class Application {
          public static void main(String[] args) {
              SpringApplication.run(Application.class, "--spring.profiles.active=dev");
          }
      }
      ```
- **Theo môi trường (ENV/CLI)**:
    - **ENV**: Set biến môi trường:
      ```bash
      export SPRING_PROFILES_ACTIVE=dev
      ```
    - **CLI**: Truyền argument:
      ```bash
      java -jar app.jar --spring.profiles.active=dev
      ```
- **Khác nhau**:
    - File: Tĩnh, dễ quản lý trong repo, phù hợp cho cấu hình cố định.
    - ENV/CLI: Linh hoạt, phù hợp cho container hoặc CI/CD.

---

### 8. Thêm tài nguyên tĩnh (static, templates, public) để phục vụ web: thư mục nào, độ ưu tiên?
- **Thư mục**:
    - **`src/main/resources/static/`**: File tĩnh (CSS, JS, images), truy cập trực tiếp (như `/css/style.css`).
    - **`src/main/resources/public/`**: Tương tự `static/`, ít dùng hơn.
    - **`src/main/resources/templates/`**: Template động (Thymeleaf, Freemarker).
- **Độ ưu tiên** (cho tài nguyên tĩnh):
    1. `/META-INF/resources/`
    2. `/resources/`
    3. `/static/`
    4. `/public/`
- **Lưu ý**: File trong `static/` được phục vụ qua `ResourceHandler` của Spring MVC.

---

### 9. ⚠️ Gài: Vì sao code chạy bằng IDE ổn nhưng khi chạy jar bị lỗi **resource path** (classpath vs file path)?
- **Nguyên nhân**:
    1. **Classpath vs file path**:
        - IDE load resource từ `src/main/resources` trực tiếp.
        - JAR nén resource vào classpath, cần dùng `ClassLoader.getResource()`.
        - Lỗi nếu dùng `File` thay vì `ResourceLoader`:
          ```java
          // Sai
          File file = new File("application.yml");
          // Đúng
          Resource resource = resourceLoader.getResource("classpath:application.yml");
          ```
    2. **Resource không có trong JAR**:
        - File bị bỏ qua khi package (kiểm tra `pom.xml`/`build.gradle`).
    3. **Sai đường dẫn**:
        - Dùng đường dẫn tuyệt đối thay vì `classpath:`.
- **Giải pháp**:
    - Dùng `@Value("classpath:filename")` hoặc `ResourceLoader`.
    - Đảm bảo resource được include trong build.

---

### 10. Case: bạn muốn tách **domain model** và **API** thành 2 module — giao tiếp giữa chúng và chia sẻ DTO như thế nào để tránh rò rỉ?
- **Cấu trúc**:
  ```
  project/
  ├── parent/
  ├── api/                    # REST controllers
  ├── domain/                 # Entities, services, repositories
  ├── common/                 # DTOs, utils
  ```
- **Giao tiếp**:
    - `api` module gọi `domain` qua interface service:
      ```java
      public interface UserService {
          UserDTO createUser(UserDTO userDTO);
      }
      ```
    - `domain` implement interface, `api` inject qua Spring.
- **Chia sẻ DTO**:
    - Đặt DTO trong `common` module:
      ```java
      public class UserDTO {
          private String name;
          private String email;
      }
      ```
    - `api` và `domain` depend trên `common`:
      ```xml
      <dependency>
          <groupId>com.example</groupId>
          <artifactId>common</artifactId>
          <version>${project.version}</version>
      </dependency>
      ```
- **Tránh rò rỉ**:
    - Không để `domain` expose entity trực tiếp, luôn map sang DTO.
    - Dùng `MapStruct` để map entity ↔ DTO.
    - Giới hạn scope của `common` (chỉ DTO, không logic).

---

# 2) @SpringBootApplication & Auto-Configuration

### 1. `@SpringBootApplication` thực chất “gom” những annotation nào? Tác dụng của từng cái?
- **`@SpringBootApplication`** gồm:
    - **`@SpringBootConfiguration`**: Đánh dấu class là configuration (tương đương `@Configuration`).
    - **`@EnableAutoConfiguration`**: Bật auto-configuration dựa trên dependencies.
    - **`@ComponentScan`**: Quét bean trong package và sub-package của class.
- **Ví dụ**:
  ```java
  @SpringBootApplication
  public class Application {
      public static void main(String[] args) {
          SpringApplication.run(Application.class, args);
      }
  }
  ```

---

### 2. Auto-configuration hoạt động theo cơ chế **điều kiện** nào (`@ConditionalOnClass`, `@ConditionalOnMissingBean`, `@ConditionalOnProperty`, …)?
- **Cơ chế**:
    - Spring Boot kiểm tra điều kiện để quyết định có apply auto-config hay không.
- **Điều kiện phổ biến**:
    - **`@ConditionalOnClass`**: Kích hoạt nếu class có trong classpath.
      ```java
      @ConditionalOnClass(JdbcTemplate.class)
      ```
    - **`@ConditionalOnMissingBean`**: Kích hoạt nếu không có bean tương ứng.
      ```java
      @ConditionalOnMissingBean(DataSource.class)
      ```
    - **`@ConditionalOnProperty`**: Kích hoạt nếu property tồn tại hoặc có giá trị cụ thể.
      ```java
      @ConditionalOnProperty(name = "spring.jpa.enabled", havingValue = "true")
      ```
- **Ví dụ**:
    - `DataSourceAutoConfiguration` chỉ chạy nếu có `DataSource` class và không có custom `DataSource` bean.

---

### 3. ⚠️ Gài: Khi cùng lúc có **bean do bạn khai báo** và **bean từ auto-config**, Spring chọn thế nào? Khi nào cần `@Primary` hoặc tự loại trừ?
- **Cách chọn**:
    - Bean do bạn khai báo (`@Bean`, `@Component`) ưu tiên hơn auto-config (do `@ConditionalOnMissingBean`).
    - Nếu có nhiều bean cùng type, Spring chọn bean có `@Primary` hoặc ném `NoUniqueBeanDefinitionException`.
- **Khi nào dùng `@Primary`**:
    - Khi cần chỉ định bean mặc định:
      ```java
      @Bean
      @Primary
      public DataSource primaryDataSource() {
          return new HikariDataSource();
      }
      ```
- **Tự loại trừ**:
    - Loại bỏ auto-config bằng `spring.autoconfigure.exclude`:
      ```properties
      spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
      ```

---

### 4. Làm sao **vô hiệu hóa** một auto-configuration cụ thể (toàn cục hoặc theo profile)?
- **Toàn cục**:
    - Dùng `spring.autoconfigure.exclude` trong `application.properties`:
      ```properties
      spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
      ```
    - Hoặc trong `@SpringBootApplication`:
      ```java
      @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
      ```
- **Theo profile**:
    - Dùng `@ConditionalOnProperty` hoặc cấu hình riêng cho profile:
      ```properties
      # application-dev.yml
      spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
      ```

---

### 5. Debug auto-config: bạn dùng flag/log nào, hay endpoint/condition report nào để thấy **điều kiện khớp/không khớp**?
- **Debug log**:
    - Bật `debug` trong `application.properties`:
      ```properties
      logging.level.org.springframework.boot=DEBUG
      ```
    - Hoặc dùng CLI:
      ```bash
      java -jar app.jar --debug
      ```
    - Log sẽ hiển thị tất cả auto-config được apply hoặc skip.
- **Condition report**:
    - Truy cập endpoint `/actuator/conditions` (nếu bật `spring-boot-starter-actuator`).
    - Report liệt kê điều kiện khớp/không khớp:
      ```json
      {
        "positiveMatches": {...},
        "negativeMatches": {...}
      }
      ```
- **Lưu ý**: Dùng `Spring Boot DevTools` để debug dễ hơn.

---

### 6. Khác biệt giữa **import selector**/`spring.factories` (cũ) và cơ chế **`AutoConfiguration.imports`** (mới) trong Boot? Ảnh hưởng khi viết starter tùy biến?
- **Import selector/`spring.factories`** (Spring Boot < 3.2):
    - File `META-INF/spring.factories` liệt kê auto-config classes:
      ```properties
      org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
      com.example.MyAutoConfiguration
      ```
    - Spring load tất cả config được khai báo.
- **AutoConfiguration.imports** (Spring Boot 3.2+):
    - File `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`:
      ```text
      com.example.MyAutoConfiguration
      ```
    - Chỉ định auto-config cần load, đơn giản hơn.
- **Ảnh hưởng khi viết starter**:
    - **Cũ**: Cần tạo `spring.factories`, dễ lỗi nếu cấu hình sai.
    - **Mới**: Dễ cấu hình hơn, nhưng chỉ tương thích Spring Boot 3.2+.
    - Khi viết starter, chọn cơ chế phù hợp với version Spring Boot.

---

### 7. ⚠️ Gài: Vì sao thêm thư viện Jackson nhưng vẫn **không** serialize JSON? Kể ít nhất 3 khả năng.
1. **Thiếu dependency**:
    - `spring-boot-starter-web` kéo `jackson-databind`, nhưng nếu dùng `spring-boot-starter` thì thiếu.
    - **Giải pháp**: Thêm `spring-boot-starter-web` hoặc `jackson-databind`.
2. **Auto-config bị tắt**:
    - `JacksonAutoConfiguration` bị vô hiệu hóa (qua `spring.autoconfigure.exclude`).
    - **Giải pháp**: Kiểm tra cấu hình hoặc bật lại auto-config.
3. **Sai `@ResponseBody`/`@RestController`**:
    - Controller thiếu `@ResponseBody` hoặc dùng `@Controller` thay vì `@RestController`.
    - **Giải pháp**: Thêm `@ResponseBody` hoặc dùng `@RestController`.

---

### 8. Thứ tự áp dụng auto-config so với `@Configuration` của bạn: khi nào cấu hình tay **ghi đè** được auto-config?
- **Thứ tự**:
    - `@Configuration` của bạn chạy sau auto-config.
    - Auto-config thường có `@ConditionalOnMissingBean`, nên bean của bạn ghi đè bean auto-config.
- **Ghi đè**:
    - Khai báo bean cùng type trong `@Configuration`:
      ```java
      @Configuration
      public class MyConfig {
          @Bean
          public ObjectMapper objectMapper() {
              return new ObjectMapper();
          }
      }
      ```
    - Bean của bạn được ưu tiên nếu không có `@Primary` hoặc điều kiện khác.

---

### 9. Case: bạn muốn thay đổi **ObjectMapper** mặc định — 3 cách hợp lệ, ưu/nhược?
- **Cách 1: `@Bean` trong `@Configuration`**:
  ```java
  @Configuration
  public class JacksonConfig {
      @Bean
      public ObjectMapper objectMapper() {
          ObjectMapper mapper = new ObjectMapper();
          mapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
          return mapper;
      }
  }
  ```
    - **Ưu**: Toàn quyền tùy chỉnh, rõ ràng.
    - **Nhược**: Phải tự cấu hình tất cả.
- **Cách 2: `Jackson2ObjectMapperBuilder`**:
  ```java
  @Configuration
  public class JacksonConfig {
      @Bean
      public Jackson2ObjectMapperBuilder builder() {
          return Jackson2ObjectMapperBuilder.json()
              .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
      }
  }
  ```
    - **Ưu**: Tích hợp tốt với Spring, tái sử dụng cấu hình.
    - **Nhược**: Ít linh hoạt hơn cách 1.
- **Cách 3: `application.properties`**:
  ```properties
  spring.jackson.property-naming-strategy=SNAKE_CASE
  ```
    - **Ưu**: Đơn giản, không cần code.
    - **Nhược**: Giới hạn ở các thuộc tính được hỗ trợ.

---

### 10. Case: cần tắt **web** auto-config (chạy CLI app) — làm sao cấu hình?
- **Cấu hình**:
    - Tắt web auto-config trong `application.properties`:
      ```properties
      spring.main.web-application-type=none
      ```
    - Hoặc trong code:
      ```java
      @SpringBootApplication
      public class Application {
          public static void main(String[] args) {
              SpringApplication app = new SpringApplication(Application.class);
              app.setWebApplicationType(WebApplicationType.NONE);
              app.run(args);
          }
      }
      ```
- **Lưu ý**: Loại bỏ `spring-boot-starter-web` nếu không cần web.

---

# 3) Cấu hình trong `application.properties` / `application.yml`

### 1. Khác nhau căn bản giữa `.properties` và `.yml`? Ưu/nhược, case dễ lỗi (indent, list, map)?
- **Khác nhau**:
    - **`.properties`**: Key-value dạng phẳng, cú pháp đơn giản (key=value).
    - **`.yml`**: Cấu trúc phân cấp, hỗ trợ list, map, dễ đọc hơn.
- **Ưu/Nhược**:
    - **`.properties`**:
        - Ưu: Đơn giản, phổ biến, dễ parse.
        - Nhược: Không hỗ trợ cấu trúc phức tạp, dễ lặp key.
    - **`.yml`**:
        - Ưu: Hỗ trợ list/map, rõ ràng khi cấu hình phức tạp.
        - Nhược: Dễ lỗi indentation, phức tạp hơn khi parse.
- **Case dễ lỗi**:
    - **Indent**: YAML yêu cầu indent chính xác (2 spaces), sai gây lỗi parse.
    - **List**:
      ```yaml
      # Sai
      servers:
      - host: localhost
        port: 8080
      # Đúng
      servers:
        - host: localhost
          port: 8080
      ```
    - **Map**: Sai key hoặc cấu trúc gây lỗi binding.

---

### 2. **Externalized Configuration**: các nguồn cấu hình được Spring Boot đọc theo thứ tự ưu tiên như thế nào (CLI args, ENV, system props, files, …)?
- **Thứ tự ưu tiên** (cao → thấp):
    1. Command-line arguments (`--key=value`).
    2. System properties (`-Dkey=value`).
    3. Environment variables (`SPRING_KEY`).
    4. `application-{profile}.properties`/`yml`.
    5. `application.properties`/`yml` (default).
    6. `@ConfigurationProperties` trong code.
    7. Default properties trong `@SpringBootApplication`.
- **Lưu ý**: Nguồn ưu tiên cao ghi đè nguồn thấp.

---

### 3. ⚠️ Gài: ENV `SPRING_DATASOURCE_URL` ánh xạ sang `spring.datasource.url` theo quy tắc gì? Khi có dấu chấm/gạch dưới thì sao?
- **Quy tắc ánh xạ**:
    - Spring chuyển ENV variables (`SPRING_DATASOURCE_URL`) sang property key (`spring.datasource.url`):
        - Gạch dưới (`_`) thành dấu chấm (`.`) hoặc camelCase.
        - Chữ hoa thành chữ thường.
    - Ví dụ:
        - `SPRING_DATASOURCE_URL` → `spring.datasource.url`.
        - `SPRING_DATASOURCE_USERNAME` → `spring.datasource.username`.
- **Dấu chấm/gạch dưới**:
    - Dấu chấm trong ENV không được phép, thay bằng gạch dưới.
    - Gạch dưới trong property key ánh xạ trực tiếp sang ENV.
- **Lưu ý**: ENV phải bắt đầu bằng `SPRING_` cho Spring Boot properties.

---

### 4. `application-{profile}.yml` load và **merge** với default ra sao? Có thể kích hoạt **nhiều profile** cùng lúc không?
- **Load và merge**:
    - `application.yml` (default) load trước.
    - `application-{profile}.yml` load sau, ghi đè key trùng với default.
    - Ví dụ:
      ```yaml
      # application.yml
      spring.datasource.url: jdbc:mysql://localhost:3306/default
      # application-dev.yml
      spring.datasource.url: jdbc:mysql://localhost:3306/dev
      ```
      → `spring.datasource.url` lấy giá trị từ `application-dev.yml`.
- **Nhiều profile**:
    - Có thể kích hoạt nhiều profile:
      ```properties
      spring.profiles.active=dev,prod
      ```
    - Thứ tự profile trong `spring.profiles.active` quyết định ưu tiên (profile cuối ghi đè).

---

### 5. Sử dụng placeholder `${...}` và default `${...:default}`: khi nào có hiệu lực, rủi ro vòng lặp?
- **Placeholder**:
    - Dùng để tham chiếu property khác:
      ```yaml
      app.name: MyApp
      app.description: ${app.name} is a Spring Boot app
      ```
    - Default value:
      ```yaml
      app.port: ${server.port:8080}
      ```
- **Hiệu lực**:
    - Áp dụng trong `application.properties`/`yml` hoặc `@Value`.
    - Đọc từ tất cả nguồn cấu hình (ENV, system props, …).
- **Rủi ro vòng lặp**:
    - Xảy ra khi 2 property tham chiếu lẫn nhau:
      ```yaml
      a: ${b}
      b: ${a}
      ```
    - Gây `IllegalStateException` khi khởi động.
    - **Giải pháp**: Kiểm tra cấu hình, tránh tham chiếu vòng.

---

### 6. Secret trong config: những anti-pattern thường gặp (đưa thẳng vào repo). Các lựa chọn thay thế an toàn hơn?
- **Anti-pattern**:
    - Đưa secret (password, API key) vào `application.properties` và commit vào Git.
    - Hardcode secret trong code.
- **Lựa chọn an toàn**:
    1. **Environment variables**:
       ```bash
       export SPRING_DATASOURCE_PASSWORD=secret
       ```
    2. **External config file**:
        - Đặt secret trong file ngoài (như `/etc/app/config.yml`), load bằng:
          ```properties
          spring.config.import=file:/etc/app/config.yml
          ```
    3. **Secret management**:
        - Dùng Vault, AWS Secrets Manager, hoặc Kubernetes Secrets.
        - Ví dụ với Vault:
          ```properties
          spring.cloud.vault.enabled=true
          spring.cloud.vault.uri=http://vault:8200
          ```

---

### 7. Chuyển đổi kiểu dữ liệu khi bind (duration, size, list, enum) diễn ra thế nào? Cần chú ý format nào?
- **Chuyển đổi**:
    - Spring Boot dùng `PropertyEditor` hoặc `Converter` để bind property sang type:
        - **Duration**: Hỗ trợ `PTnHnMnS` (ISO-8601) hoặc đơn vị (như `10s`).
          ```yaml
          app.timeout: PT30S
          ```
        - **Size**: Hỗ trợ đơn vị (như `10MB`, `1GB`).
          ```yaml
          spring.servlet.multipart.max-file-size: 10MB
          ```
        - **List**: Dùng dấu phẩy hoặc YAML array:
          ```yaml
          app.roles: admin,user
          # hoặc
          app.roles:
            - admin
            - user
          ```
        - **Enum**: Match với tên enum (case-insensitive):
          ```yaml
          app.role: ADMIN
          ```
- **Chú ý format**:
    - Duration: Phải đúng cú pháp ISO-8601 hoặc đơn vị.
    - List: Tránh khoảng trắng thừa.
    - Enum: Kiểm tra tên enum hợp lệ.

---

### 8. ⚠️ Gài: Vì sao `application.yml` của bạn **không** được load khi chạy jar nhưng lại được load trong IDE?
- **Nguyên nhân**:
    1. **File không nằm trong JAR**:
        - `application.yml` không được include khi package (kiểm tra `pom.xml`/`build.gradle`).
    2. **Sai classpath**:
        - JAR tìm `application.yml` trong `BOOT-INF/classes/`, nhưng IDE tìm trực tiếp trong `src/main/resources`.
    3. **Profile sai**:
        - `spring.profiles.active` không khớp với file có sẵn trong JAR.
- **Giải pháp**:
    - Đảm bảo `application.yml` nằm trong `src/main/resources`.
    - Kiểm tra build file:
      ```xml
      <resources>
          <resource>
              <directory>src/main/resources</directory>
          </resource>
      </resources>
      ```
    - Dùng `spring.config.location` để chỉ định file:
      ```bash
      java -jar app.jar --spring.config.location=classpath:/application.yml
      ```

---

### 9. Case: tách cấu hình theo **environment** (dev/staging/prod) và **region** (ap, eu). Bạn đặt file & active profile thế nào?
- **Cấu trúc file**:
  ```
  src/main/resources/
  ├── application.yml                # Default
  ├── application-dev.yml
  ├── application-staging.yml
  ├── application-prod.yml
  ├── application-dev-ap.yml
  ├── application-dev-eu.yml
  ```
- **Nội dung**:
  ```yaml
  # application.yml
  spring.datasource.url: jdbc:mysql://localhost:3306/default
  # application-dev.yml
  spring.profiles.include: dev-ap
  spring.datasource.url: jdbc:mysql://localhost:3306/dev
  # application-dev-ap.yml
  app.region: ap
  ```
- **Active profile**:
    - CLI:
      ```bash
      java -jar app.jar --spring.profiles.active=dev,dev-ap
      ```
    - ENV:
      ```bash
      export SPRING_PROFILES_ACTIVE=dev,dev-ap
      ```
- **Lưu ý**: Dùng `spring.profiles.include` để gộp cấu hình.

---

### 10. Case: cần override một vài key **tạm thời** khi chạy container: bạn chọn ENV hay CLI args? Vì sao?
- **Chọn ENV**:
    - **Lý do**:
        - ENV dễ tích hợp với container (Docker, Kubernetes).
        - Có thể set trong `Dockerfile` hoặc Kubernetes ConfigMap.
        - Không cần thay đổi command khi deploy.
    - **Ví dụ**:
      ```bash
      export SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/prod
      docker run -e SPRING_DATASOURCE_URL my-app
      ```
- **CLI args**:
    - Dùng khi cần override nhanh trong testing:
      ```bash
      java -jar app.jar --spring.datasource.url=jdbc:mysql://db:3306/test
      ```
    - Nhược: Phải chỉnh sửa command, khó tự động hóa.

---

# 4) Starter & Dependency Management

### 1. **Spring Boot Starter** là gì? Vì sao dùng starter thay vì tự liệt kê từng dependency?
- **Starter**:
    - Là tập hợp dependencies được cấu hình sẵn cho một use-case (như `spring-boot-starter-web`).
    - Bao gồm tất cả thư viện cần thiết và cấu hình mặc định.
- **Vì sao dùng**:
    - Giảm công liệt kê từng dependency và version.
    - Đảm bảo tương thích giữa các thư viện (nhờ BOM).
    - Tích hợp auto-configuration.
- **Ví dụ**:
    - `spring-boot-starter-web` kéo `spring-web`, `jackson`, `tomcat`, v.v.

---

### 2. `spring-boot-dependencies` (BOM) hoạt động thế nào? Tại sao không cần chỉ định version cho đa số starters?
- **BOM (Bill of Materials)**:
    - `spring-boot-dependencies` là file POM định nghĩa version cho tất cả dependencies phổ biến.
    - Được import trong `dependencyManagement`:
      ```xml
      <dependencyManagement>
          <dependencies>
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-dependencies</artifactId>
                  <version>${spring-boot.version}</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
          </dependencies>
      </dependencyManagement>
      ```
- **Không cần version**:
    - Starter kế thừa version từ BOM, tránh xung đột version.
    - Ví dụ:
      ```xml
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      ```

---

### 3. ⚠️ Gài: Khi thêm một lib **ngoài BOM**, làm sao tránh **xung đột phiên bản** (dependency hell)?
- **Cách tránh**:
    1. **Kiểm tra compatibility**:
        - Xem tài liệu Spring Boot hoặc `spring-boot-dependencies` để chọn version tương thích.
    2. **Explicit version**:
       ```xml
       <dependency>
           <groupId>com.example</groupId>
           <artifactId>custom-lib</artifactId>
           <version>1.2.3</version>
       </dependency>
       ```
    3. **Dependency exclusions**:
        - Loại bỏ dependency xung đột:
          ```xml
          <dependency>
              <groupId>com.example</groupId>
              <artifactId>custom-lib</artifactId>
              <exclusions>
                  <exclusion>
                      <groupId>org.slf4j</groupId>
                      <artifactId>slf4j-api</artifactId>
                  </exclusion>
              </exclusions>
          </dependency>
          ```
    4. **Use `dependencyManagement`**:
        - Định nghĩa version trong parent:
          ```xml
          <dependencyManagement>
              <dependencies>
                  <dependency>
                      <groupId>com.example</groupId>
                      <artifactId>custom-lib</artifactId>
                      <version>1.2.3</version>
                  </dependency>
              </dependencies>
          </dependencyManagement>
          ```

---

### 4. Vai trò `spring-boot-starter-web`: gồm những module chính nào (web MVC, embedded server, JSON…)? Khi nào cần `spring-boot-starter-webflux`?
- **`spring-boot-starter-web`**:
    - **Module chính**:
        - `spring-web`: Spring MVC, REST support.
        - `spring-boot-starter-tomcat`: Embedded Tomcat.
        - `jackson-databind`: JSON serialization.
        - `spring-boot-starter-validation`: Bean Validation.
    - Dùng cho ứng dụng web MVC truyền thống.
- **`spring-boot-starter-webflux`**:
    - Dùng cho reactive web (non-blocking, dựa trên Project Reactor).
    - Bao gồm `spring-webflux`, `reactor-netty`.
    - Dùng khi:
        - Xử lý high-concurrency, low-latency.
        - Stream dữ liệu (như Server-Sent Events).

---

### 5. `spring-boot-starter-data-jpa`: cung cấp những gì? Nhắc đến JPA provider, transaction, EntityManager, query.
- **Cung cấp**:
    - **JPA provider**: Hibernate (mặc định).
    - **Transaction**: `@EnableTransactionManagement` và `PlatformTransactionManager`.
    - **EntityManager**: Auto-configured qua `EntityManagerFactory`.
    - **Query**: `JpaRepository` với derived queries và `@Query`.
- **Ví dụ**:
  ```java
  @Repository
  public interface UserRepository extends JpaRepository<User, Long> {
      List<User> findByName(String name);
  }
  ```
- **Auto-config**:
    - Cấu hình `DataSource` qua `spring.datasource.*`.
    - Tạo `EntityManagerFactory` và `TransactionManager`.

---

### 6. `spring-boot-starter-validation`: tích hợp Bean Validation (Jakarta Validation) ra sao? Phối hợp với Spring MVC như thế nào?
- **Tích hợp**:
    - Cung cấp `hibernate-validator` (Jakarta Validation implementation).
    - Auto-config `Validator` bean (`LocalValidatorFactoryBean`).
- **Phối hợp với Spring MVC**:
    - Dùng `@Valid`/`@Validated` trên `@RequestBody`, `@ModelAttribute`:
      ```java
      @PostMapping("/users")
      public ResponseEntity<User> create(@Valid @RequestBody UserDTO userDTO, BindingResult result) {
          if (result.hasErrors()) return ResponseEntity.badRequest().build();
          return ResponseEntity.ok(userService.save(userDTO));
      }
      ```
    - Lỗi validation ném `MethodArgumentNotValidException`, xử lý qua `@ExceptionHandler`.

---

### 7. ⚠️ Gài: Tại sao thêm `spring-boot-starter-web` lại **kéo** Tomcat, nhưng bạn muốn dùng Jetty/Undertow thì làm gì?
- **Vì sao kéo Tomcat**:
    - `spring-boot-starter-web` phụ thuộc `spring-boot-starter-tomcat`.
- **Dùng Jetty/Undertow**:
    - Loại bỏ Tomcat và thêm Jetty/Undertow:
      ```xml
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
          <exclusions>
              <exclusion>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-starter-tomcat</artifactId>
              </exclusion>
          </exclusions>
      </dependency>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-jetty</artifactId>
      </dependency>
      ```

---

### 8. Gradle vs Maven với Boot: khác nhau về **plugin** và **cách áp BOM** (platform/bom import).
- **Plugin**:
    - **Maven**: `spring-boot-maven-plugin` cho `package`, `run`, `repackage`.
    - **Gradle**: `org.springframework.boot` plugin cho `bootJar`, `bootRun`.
- **Áp BOM**:
    - **Maven**:
      ```xml
      <dependencyManagement>
          <dependencies>
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-dependencies</artifactId>
                  <version>${spring-boot.version}</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
          </dependencies>
      </dependencyManagement>
      ```
    - **Gradle**:
      ```gradle
      plugins {
          id 'org.springframework.boot' version '3.2.0'
      }
      dependencies {
          implementation platform('org.springframework.boot:spring-boot-dependencies:3.2.0')
          implementation 'org.springframework.boot:spring-boot-starter-web'
      }
      ```
- **Khác biệt**:
    - Maven: Dùng `<dependencyManagement>` và `<scope>import</scope>`.
    - Gradle: Dùng `platform` để import BOM.

---

### 9. Case: viết **custom starter** cho nội bộ công ty: cần những thành phần nào (auto-config, metadata, sample)?
- **Thành phần**:
    1. **Auto-configuration**:
       ```java
       @Configuration
       @ConditionalOnClass(MyService.class)
       public class MyAutoConfiguration {
           @Bean
           @ConditionalOnMissingBean
           public MyService myService() {
               return new MyService();
           }
       }
       ```
    2. **Metadata**:
        - File `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`:
          ```text
          com.example.MyAutoConfiguration
          ```
    3. **Sample**:
        - Cung cấp tài liệu và ví dụ sử dụng:
          ```java
          @SpringBootApplication
          public class SampleApp {
              public static void main(String[] args) {
                  SpringApplication.run(SampleApp.class, args);
              }
          }
          ```
- **Cấu hình dependency**:
  ```xml
  <dependency>
      <groupId>com.example</groupId>
      <artifactId>my-starter</artifactId>
      <version>1.0.0</version>
  </dependency>
  ```

---

### 10. Case: app cần cả MVC và WebFlux cho 2 use-case khác nhau — có nên trộn trong cùng project? Rủi ro?
- **Có nên trộn**:
    - Không nên, vì:
        - MVC (blocking) và WebFlux (non-blocking) có mô hình khác nhau.
        - Trộn gây phức tạp cấu hình, dễ xung đột dependency.
    - **Giải pháp**: Tách thành 2 module/project riêng.
- **Rủi ro**:
    - Xung đột dependency (như `spring-web` vs `spring-webflux`).
    - Hiệu năng kém nếu dùng blocking code trong WebFlux.
    - Khó debug và bảo trì.
- **Cấu hình nếu phải trộn**:
  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-webflux</artifactId>
  </dependency>
  ```
    - Tách endpoint rõ ràng (`/api/mvc/*`, `/api/webflux/*`).

---

# 5) Profiles & Configuration nâng cao

### 1. `@Profile` dùng trên class/method `@Bean` hoạt động ra sao? Cú pháp profile expression (AND/OR/NOT)?
- **Trên class**:
  ```java
  @Profile("dev")
  @Configuration
  public class DevConfig {
      @Bean
      public DataSource dataSource() {
          return new HikariDataSource();
      }
  }
  ```
- **Trên method**:
  ```java
  @Configuration
  public class AppConfig {
      @Bean
      @Profile("prod")
      public DataSource prodDataSource() {
          return new HikariDataSource();
      }
  }
  ```
- **Profile expression**:
    - **AND**: `@Profile("dev & db")` → Cả `dev` và `db` phải active.
    - **OR**: `@Profile("dev | test")` → `dev` hoặc `test` active.
    - **NOT**: `@Profile("!prod")` → Không phải `prod`.
- **Lưu ý**: Kích hoạt profile qua `spring.profiles.active`.

---

### 2. Kích hoạt profile: qua file, ENV, CLI, programmatic — ưu/nhược từng cách?
- **Qua file**:
    - `application.properties`:
      ```properties
      spring.profiles.active=dev
      ```
    - Ưu: Tĩnh, dễ quản lý.
    - Nhược: Không linh hoạt khi deploy.
- **ENV**:
    - `export SPRING_PROFILES_ACTIVE=dev`
    - Ưu: Tích hợp tốt với container.
    - Nhược: Khó debug nếu sai ENV.
- **CLI**:
    - `java -jar app.jar --spring.profiles.active=dev`
    - Ưu: Linh hoạt, dễ test.
    - Nhược: Phải chỉnh command.
- **Programmatic**:
  ```java
  SpringApplication app = new SpringApplication(Application.class);
  app.setAdditionalProfiles("dev");
  app.run(args);
  ```
    - Ưu: Kiểm soát trong code.
    - Nhược: Hardcode, khó thay đổi.

---

### 3. ⚠️ Gài: `spring.profiles.active` vs `spring.profiles.include` khác nhau thế nào khi merge cấu hình?
- **`spring.profiles.active`**:
    - Kích hoạt profile chính, ghi đè cấu hình default.
    - Ví dụ:
      ```properties
      spring.profiles.active=dev
      ```
- **`spring.profiles.include`**:
    - Gộp thêm profile phụ vào profile chính, không ghi đè.
    - Ví dụ:
      ```yaml
      # application-dev.yml
      spring.profiles.include: db
      ```
    - Load cả `application-dev.yml` và `application-db.yml`.
- **Khác biệt**:
    - `active`: Quyết định profile chính.
    - `include`: Bổ sung cấu hình, giữ nguyên profile chính.

---

### 4. `@ConfigurationProperties` là gì? So sánh với `@Value` về type-safety, testability, tổ chức cấu hình.
- **`@ConfigurationProperties`**:
    - Bind cấu hình vào POJO:
      ```java
      @ConfigurationProperties(prefix = "app")
      public class AppConfig {
          private String name;
          private int port;
          // Getters/Setters
      }
      ```
- **So sánh**:
    - **Type-safety**:
        - `@ConfigurationProperties`: Type-safe, validate tại compile-time.
        - `@Value`: Không type-safe, lỗi runtime nếu sai format.
    - **Testability**:
        - `@ConfigurationProperties`: Dễ test với POJO, hỗ trợ validation.
        - `@Value`: Khó mock/test do inject trực tiếp.
    - **Tổ chức**:
        - `@ConfigurationProperties`: Gom nhóm cấu hình, dễ đọc.
        - `@Value`: Phân tán, khó quản lý khi nhiều property.

---

### 5. Cách đăng ký `@ConfigurationProperties`: `@ConfigurationPropertiesScan` vs `@EnableConfigurationProperties` vs khai báo `@Bean`. Khi nào cần cái nào?
- **`@ConfigurationPropertiesScan`**:
    - Quét tất cả `@ConfigurationProperties` trong package:
      ```java
      @SpringBootApplication
      @ConfigurationPropertiesScan
      public class Application { ... }
      ```
    - Dùng khi có nhiều class `@ConfigurationProperties`.
- **`@EnableConfigurationProperties`**:
    - Chỉ định class cụ thể:
      ```java
      @EnableConfigurationProperties(AppConfig.class)
      ```
    - Dùng khi chỉ cần một vài class cụ thể.
- **Khai báo `@Bean`**:
  ```java
  @Bean
  @ConfigurationProperties(prefix = "app")
  public AppConfig appConfig() {
      return new AppConfig();
  }
  ```
    - Dùng khi cần kiểm soát instance hoặc cấu hình phức tạp.
- **Khi nào dùng**:
    - `@ConfigurationPropertiesScan`: Dự án lớn, nhiều config.
    - `@EnableConfigurationProperties`: Dự án nhỏ, ít config.
    - `@Bean`: Cần custom logic khi tạo bean.

---

### 6. **Constructor binding** cho `@ConfigurationProperties`: lợi ích về bất biến, yêu cầu gì trên class?
- **Constructor binding**:
  ```java
  @ConfigurationProperties(prefix = "app")
  public class AppConfig {
      private final String name;
      private final int port;
      public AppConfig(String name, int port) {
          this.name = name;
          this.port = port;
      }
      // Getters only
  }
  ```
- **Lợi ích**:
    - Bất biến (immutable), an toàn thread.
    - Rõ ràng giá trị bắt buộc (không cần setter).
- **Yêu cầu**:
    - Constructor duy nhất hoặc có `@ConstructorBinding`.
    - Các field phải khớp với property key.
    - Bật `@EnableConfigurationProperties` hoặc `@ConfigurationPropertiesScan`.

---

### 7. ⚠️ Gài: Vì sao field trong `@ConfigurationProperties` **không bind** được? Liệt kê ít nhất 3 nguyên nhân (prefix sai, không có setter/constructor, không được scan, …).
1. **Prefix sai**:
    - `@ConfigurationProperties(prefix = "app")` nhưng property là `server.*`.
    - **Giải pháp**: Kiểm tra prefix trong `application.yml`.
2. **Không có setter/constructor**:
    - Thiếu setter (cho non-immutable) hoặc constructor (cho immutable).
    - **Giải pháp**: Thêm setter hoặc constructor với `@ConstructorBinding`.
3. **Không được scan**:
    - Class không được đăng ký qua `@ConfigurationPropertiesScan` hoặc `@EnableConfigurationProperties`.
    - **Giải pháp**: Thêm annotation hoặc khai báo `@Bean`.

---

### 8. Validate cấu hình bằng `@Validated` + constraint trên `@ConfigurationProperties`: thông báo lỗi hiển thị như thế nào khi app khởi động?
- **Cấu hình**:
  ```java
  @ConfigurationProperties(prefix = "app")
  @Validated
  public class AppConfig {
      @NotNull
      private String name;
      // Getters/Setters
  }
  ```
- **Thông báo lỗi**:
    - Nếu validation fail (như `app.name` null), Spring ném `BindValidationException`.
    - Lỗi hiển thị trong log khi khởi động:
      ```
      Description:
      Binding to target AppConfig failed:
          Property: app.name
          Value: null
          Reason: must not be null
      ```
- **Lưu ý**: Dùng `@Validated` để kích hoạt validation.

---

### 9. Chuyển đổi cấu hình nhạy cảm theo profile (ví dụ datasource, logging, CORS): pattern “**fail fast**” với missing required props?
- **Pattern “fail fast”**:
    - Yêu cầu property bắt buộc bằng `@NotNull`:
      ```java
      @ConfigurationProperties(prefix = "app")
      @Validated
      public class AppConfig {
          @NotNull
          private String datasourceUrl;
      }
      ```
    - Spring ném lỗi khi khởi động nếu thiếu property.
- **Theo profile**:
  ```yaml
  # application-dev.yml
  app.datasource-url: jdbc:mysql://localhost:3306/dev
  # application-prod.yml
  app.datasource-url: jdbc:mysql://prod:3306/prod
  ```
- **CORS**:
  ```yaml
  spring.web.cors.allowed-origins: http://localhost:3000
  ```

---

### 10. Case: cần structure hóa config phức tạp (map/list lồng nhau, enum, duration/size). Bạn định nghĩa POJO và test binding như thế nào?
- **POJO**:
  ```java
  @ConfigurationProperties(prefix = "app")
  @Validated
  public class AppConfig {
      @NotNull
      private String name;
      private Duration timeout;
      private DataSize maxSize;
      private Map<String, Server> servers;
      private List<String> roles;
      private Role role; // Enum
      public enum Role { ADMIN, USER }
      public static class Server {
          private String host;
          private int port;
          // Getters/Setters
      }
      // Getters/Setters
  }
  ```
- **Cấu hình**:
  ```yaml
  app:
    name: MyApp
    timeout: PT30S
    max-size: 10MB
    role: ADMIN
    roles:
      - admin
      - user
    servers:
      primary:
        host: localhost
        port: 8080
      secondary:
        host: backup
        port: 8081
  ```
- **Test binding**:
  ```java
  @SpringBootTest
  public class AppConfigTest {
      @Autowired
      private AppConfig config;
      @Test
      void testBinding() {
          assertEquals("MyApp", config.getName());
          assertEquals(Duration.ofSeconds(30), config.getTimeout());
          assertEquals(DataSize.ofMegabytes(10), config.getMaxSize());
          assertEquals(Role.ADMIN, config.getRole());
          assertTrue(config.getServers().containsKey("primary"));
      }
  }
  ```

---

# 6) Thực chiến ngắn (2–5 phút/câu)

### 1. Thiết lập 3 profile `dev/staging/prod` cho một service REST dùng JPA + Validation; mô tả file cấu hình, bật profile, và cách đảm bảo **không** dùng nhầm config prod.
- **File cấu hình**:
  ```
  src/main/resources/
  ├── application.yml
  ├── application-dev.yml
  ├── application-staging.yml
  ├── application-prod.yml
  ```
  ```yaml
  # application.yml
  spring.datasource.url: jdbc:mysql://localhost:3306/default
  # application-dev.yml
  spring.datasource.url: jdbc:mysql://localhost:3306/dev
  spring.jpa.hibernate.ddl-auto: update
  # application-staging.yml
  spring.datasource.url: jdbc:mysql://staging:3306/staging
  spring.jpa.hibernate.ddl-auto: validate
  # application-prod.yml
  spring.datasource.url: jdbc:mysql://prod:3306/prod
  spring.jpa.hibernate.ddl-auto: none
  ```
- **Bật profile**:
    - ENV:
      ```bash
      export SPRING_PROFILES_ACTIVE=dev
      ```
    - CLI:
      ```bash
      java -jar app.jar --spring.profiles.active=dev
      ```
- **Không dùng nhầm prod**:
    - Set `spring.profiles.active` trong CI/CD pipeline.
    - Dùng `@Profile("!prod")` cho cấu hình không phải prod:
      ```java
      @Profile("!prod")
      @Configuration
      public class NonProdConfig { ... }
      ```
    - Kiểm tra profile trong code:
      ```java
      @Autowired
      private Environment env;
      if (Arrays.asList(env.getActiveProfiles()).contains("prod")) {
          // Validate prod config
      }
      ```

---

### 2. Tùy biến JSON (naming strategy, date/time) **toàn cục** mà không đụng tới từng controller — nêu 2–3 cách khác nhau.
- **Cách 1: `application.properties`**:
  ```properties
  spring.jackson.property-naming-strategy=SNAKE_CASE
  spring.jackson.date-format=yyyy-MM-dd
  ```
    - Ưu: Đơn giản, không cần code.
    - Nhược: Giới hạn ở các property được hỗ trợ.
- **Cách 2: `@Bean` ObjectMapper**:
  ```java
  @Configuration
  public class JacksonConfig {
      @Bean
      public ObjectMapper objectMapper() {
          ObjectMapper mapper = new ObjectMapper();
          mapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
          mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));
          return mapper;
      }
  }
  ```
    - Ưu: Toàn quyền tùy chỉnh.
    - Nhược: Cần code thêm.
- **Cách 3: `Jackson2ObjectMapperBuilder`**:
  ```java
  @Configuration
  public class JacksonConfig {
      @Bean
      public Jackson2ObjectMapperBuilder builder() {
          return Jackson2ObjectMapperBuilder.json()
              .propertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)
              .simpleDateFormat("yyyy-MM-dd");
      }
  }
  ```
    - Ưu: Tích hợp tốt với Spring.
    - Nhược: Ít linh hoạt hơn cách 2.

---

### 3. Viết một `MailAutoConfiguration` nội bộ: điều kiện, bean cung cấp, properties kèm prefix, và cách **override** bởi ứng dụng.
- **Auto-configuration**:
  ```java
  @Configuration
  @ConditionalOnClass(JavaMailSender.class)
  @ConditionalOnProperty(prefix = "app.mail", name = "enabled", havingValue = "true")
  public class MailAutoConfiguration {
      @Bean
      @ConditionalOnMissingBean
      public JavaMailSender mailSender(AppMailProperties properties) {
          JavaMailSenderImpl sender = new JavaMailSenderImpl();
          sender.setHost(properties.getHost());
          sender.setPort(properties.getPort());
          return sender;
      }
  }
  ```
- **Properties**:
  ```java
  @ConfigurationProperties(prefix = "app.mail")
  public class AppMailProperties {
      private boolean enabled;
      private String host;
      private int port;
      // Getters/Setters
  }
  ```
- **Metadata**:
  ```text
  # META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
  com.example.MailAutoConfiguration
  ```
- **Override**:
    - Ứng dụng khai báo bean `JavaMailSender`:
      ```java
      @Configuration
      public class CustomConfig {
          @Bean
          public JavaMailSender mailSender() {
              JavaMailSenderImpl sender = new JavaMailSenderImpl();
              sender.setHost("smtp.custom.com");
              return sender;
          }
      }
      ```

---

### 4. App cần chạy CLI (không web) để xử lý batch: bạn loại bỏ web auto-config, đọc config, và cấu hình profile như thế nào?
- **Loại bỏ web**:
  ```properties
  spring.main.web-application-type=none
  ```
- **Đọc config**:
  ```java
  @ConfigurationProperties(prefix = "batch")
  public class BatchConfig {
      private String inputFile;
      private String outputFile;
      // Getters/Setters
  }
  ```
  ```yaml
  batch:
    input-file: /data/input.csv
    output-file: /data/output.csv
  ```
- **Profile**:
  ```bash
  java -jar app.jar --spring.profiles.active=batch
  ```
- **Code CLI**:
  ```java
  @SpringBootApplication
  public class BatchApplication implements CommandLineRunner {
      @Autowired
      private BatchConfig config;
      public static void main(String[] args) {
          SpringApplication.run(BatchApplication.class, args);
      }
      @Override
      public void run(String... args) {
          // Process config.inputFile
      }
  }
  ```

---

### 5. Sự cố khởi động: auto-config báo **mismatch điều kiện**. Trình tự bạn dùng để khoanh vùng nguyên nhân?
- **Trình tự**:
    1. **Bật debug log**:
       ```properties
       logging.level.org.springframework.boot=DEBUG
       ```
        - Xem log để tìm auto-config bị skip và lý do.
    2. **Kiểm tra `/actuator/conditions`**:
        - Enable Actuator và truy cập endpoint:
          ```bash
          curl http://localhost:8080/actuator/conditions
          ```
        - Xem điều kiện khớp/không khớp.
    3. **Kiểm tra dependency**:
        - Xác minh classpath có class cần thiết (`@ConditionalOnClass`).
        - Dùng `mvn dependency:tree` hoặc `gradle dependencies`.
    4. **Kiểm tra properties**:
        - Xác minh `@ConditionalOnProperty` có khớp với `application.yml`.
    5. **Kiểm tra bean conflict**:
        - Xem nếu custom bean ghi đè auto-config (`@ConditionalOnMissingBean`).
- **Ví dụ**:
    - Nếu `DataSourceAutoConfiguration` fail, kiểm tra `spring.datasource.url` hoặc dependency `spring-boot-starter-jdbc`.

---

