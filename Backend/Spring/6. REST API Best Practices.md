# 1) Thiết kế & Cấu trúc REST API

### 1. Thế nào là **resource** trong REST? Cách đặt tên URI theo danh từ số nhiều (ví dụ `/users/{id}`) và khi nào nên có **sub-resource** (ví dụ `/orders/{id}/items`)?
- **Resource**:
    - Là thực thể hoặc tập hợp dữ liệu trong REST (như `User`, `Order`).
    - Đại diện bằng URI (như `/users`, `/users/{id}`).
- **Đặt tên URI**:
    - Dùng danh từ số nhiều cho collection (như `/users` thay vì `/user`).
    - Dùng `{id}` cho resource cụ thể (như `/users/123`).
    - Quy ước: lowercase, phân cách bằng dấu gạch ngang (`-`), tránh dấu gạch dưới (`_`).
- **Sub-resource**:
    - Dùng khi resource con phụ thuộc vào resource cha.
    - Ví dụ: `/orders/123/items` (các item thuộc về order 123).
    - Khi dùng: Quan hệ 1-n (như `Order` → `OrderItems`), hoặc để tổ chức logic rõ ràng.
    - Không nên lạm dụng nếu resource con có thể độc lập (như `/products` thay vì `/orders/123/products`).

---

### 2. So sánh hành vi **GET/POST/PUT/PATCH/DELETE** về tính **safe**, **idempotent**. Khi nào dùng PUT vs PATCH?
- **So sánh**:
    - **GET**:
        - **Safe**: Có (không thay đổi trạng thái server).
        - **Idempotent**: Có (gọi nhiều lần cho cùng kết quả).
        - Dùng: Lấy dữ liệu (như `/users/123`).
    - **POST**:
        - **Safe**: Không.
        - **Idempotent**: Không (mỗi lần gọi tạo resource mới).
        - Dùng: Tạo resource (như `/users`).
    - **PUT**:
        - **Safe**: Không.
        - **Idempotent**: Có (thay thế toàn bộ resource, gọi lại không đổi kết quả).
        - Dùng: Cập nhật toàn bộ resource (như `/users/123` với payload đầy đủ).
    - **PATCH**:
        - **Safe**: Không.
        - **Idempotent**: Có (nếu dùng JSON Patch chuẩn).
        - Dùng: Cập nhật một phần resource (như `/users/123` với `{ "name": "newName" }`).
    - **DELETE**:
        - **Safe**: Không.
        - **Idempotent**: Có (xóa nhiều lần không thay đổi trạng thái).
        - Dùng: Xóa resource (như `/users/123`).
- **PUT vs PATCH**:
    - **PUT**: Thay thế toàn bộ resource, yêu cầu payload đầy đủ. Dùng khi client biết toàn bộ trạng thái mới.
    - **PATCH**: Cập nhật một phần, chỉ gửi thay đổi. Dùng khi client chỉ muốn sửa vài field.

---

### 3. ⚠️ Gài: Tại sao `POST /users/{id}` thường là thiết kế tệ? Trình bày phương án đúng cho “tạo user có id do server cấp”.
- **Tại sao tệ**:
    - Theo REST, `POST` tạo resource mới, server quyết định ID (không phải client).
    - `/users/{id}` ngụ ý resource đã tồn tại, phù hợp với `PUT` hoặc `GET`, không phải `POST`.
    - Gây nhầm lẫn: Client có thể nghĩ `{id}` là input, nhưng server không dùng.
- **Phương án đúng**:
    - Dùng `POST /users` để tạo user, server sinh ID.
    - Trả `201 Created` với header `Location: /users/123`.
    - Ví dụ:
      ```http
      POST /users
      Content-Type: application/json
      { "name": "John", "email": "john@example.com" }
      
      Response:
      201 Created
      Location: /users/123
      { "id": 123, "name": "John", "email": "john@example.com" }
      ```

---

### 4. Quy ước **versioning**: path (`/v1`), header, query — trade-off từng cách, khi nào nên “sunset” một version?
- **Path (`/v1`)**:
    - Ví dụ: `/v1/users`.
    - **Ưu**: Rõ ràng, dễ test, client dễ dùng.
    - **Nhược**: Làm dài URI, khó thay đổi nếu có nhiều version.
- **Header**:
    - Ví dụ: `Accept: application/vnd.example.v1+json`.
    - **Ưu**: URI sạch, không thay đổi khi version mới.
    - **Nhược**: Khó debug, client phải thêm header.
- **Query**:
    - Ví dụ: `/users?version=1`.
    - **Ưu**: Dễ implement, không cần thay đổi URI.
    - **Nhược**: Ít RESTful, dễ nhầm lẫn với tham số lọc.
- **Trade-off**:
    - Path: Tốt cho API công khai, dễ khám phá.
    - Header: Phù hợp microservices, client nội bộ.
    - Query: Dùng tạm thời hoặc test nội bộ.
- **Sunset version**:
    - Khi version cũ không còn client dùng (dựa trên log/metric).
    - Có ít nhất 6-12 tháng thông báo deprecation.
    - Trả header `Deprecation: true` hoặc `Sunset: <date>`.

---

### 5. Thiết kế **quan hệ** giữa resources: trả **link** (HATEOAS nhẹ) vs trả **embedded**; khi nào chỉ nên trả `id`?
- **Link (HATEOAS)**:
    - Trả URI liên quan trong response:
      ```json
      {
        "id": 123,
        "name": "John",
        "_links": {
          "self": { "href": "/users/123" },
          "orders": { "href": "/users/123/orders" }
        }
      }
      ```
    - **Ưu**: Giảm payload, client tự quyết định lấy dữ liệu liên quan.
    - **Nhược**: Cần thêm request để lấy sub-resource.
- **Embedded**:
    - Trả dữ liệu sub-resource trực tiếp:
      ```json
      {
        "id": 123,
        "name": "John",
        "orders": [
          { "id": 1, "total": 100 }
        ]
      }
      ```
    - **Ưu**: Giảm số request, tiện cho client.
    - **Nhược**: Payload lớn, khó cache.
- **Chỉ trả `id`**:
    - Khi sub-resource lớn hoặc không cần thiết ngay (như `/orders/123/items` trả `productId` thay vì `Product`).
    - Khi client có thể lazy-load sau.

---

### 6. Phân trang/sắp xếp/lọc: đề xuất tham số chuẩn (`page`, `size`, `sort`, `q`), giới hạn tối đa `size`, chống DoS.
- **Tham số chuẩn**:
    - `page`: Số trang (0-based hoặc 1-based, ưu tiên 0).
    - `size`: Số bản ghi mỗi trang (mặc định 20).
    - `sort`: Sắp xếp (như `sort=createdAt,desc`).
    - `q`: Lọc (như `q=status:active`).
    - Ví dụ: `GET /users?page=0&size=20&sort=name,asc&q=status:active`.
- **Giới hạn `size`**:
    - Tối đa 100 hoặc 200 để tránh tải nặng server.
    - Ví dụ:
      ```java
      @GetMapping("/users")
      public Page<User> getUsers(@RequestParam(defaultValue = "0") int page,
                                 @RequestParam(defaultValue = "20") int size,
                                 Pageable pageable) {
          if (size > 100) throw new IllegalArgumentException("Size exceeds limit");
          return userService.findAll(pageable);
      }
      ```
- **Chống DoS**:
    - Giới hạn `size` và số request (rate limiting).
    - Validate tham số, trả `400` nếu sai.

---

### 7. Quy tắc chuẩn hóa **định dạng ngày giờ, tiền tệ**: ISO 8601, số thập phân; tránh kiểu mơ hồ time zone.
- **Ngày giờ**:
    - Dùng ISO 8601: `2025-08-15T17:46:00Z` (UTC) hoặc `2025-08-15T17:46:00+07:00` (with offset).
    - Tránh: `15/08/2025` (mơ hồ múi giờ, định dạng).
- **Tiền tệ**:
    - Số thập phân với `BigDecimal`, định dạng JSON số (như `100.50`).
    - Chỉ định currency code (ISO 4217, như `USD`, `VND`).
    - Ví dụ:
      ```json
      {
        "amount": 100.50,
        "currency": "USD"
      }
      ```
- **Tránh mơ hồ**:
    - Luôn kèm offset hoặc dùng UTC.
    - Cấu hình Jackson:
      ```java
      @Bean
      public ObjectMapper objectMapper() {
          ObjectMapper mapper = new ObjectMapper();
          mapper.registerModule(new JavaTimeModule());
          mapper.setTimeZone(TimeZone.getTimeZone("UTC"));
          return mapper;
      }
      ```

---

### 8. Chuẩn **request-id / correlation-id** trong header để trace qua nhiều service — vì sao nên có?
- **Tại sao cần**:
    - **Traceability**: Theo dõi request qua nhiều service (như API → DB → Queue).
    - **Debugging**: Dễ tìm log liên quan khi lỗi xảy ra.
    - **Audit**: Ghi lại hành vi request cho mục đích kiểm tra.
- **Cơ chế**:
    - Client gửi `X-Correlation-Id` hoặc server sinh nếu thiếu.
    - Ví dụ:
      ```java
      @Component
      public class CorrelationIdFilter implements Filter {
          @Override
          public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
              String correlationId = req.getHeader("X-Correlation-Id");
              if (correlationId == null) {
                  correlationId = UUID.randomUUID().toString();
              }
              MDC.put("correlationId", correlationId);
              ((HttpServletResponse) res).setHeader("X-Correlation-Id", correlationId);
              chain.doFilter(req, res);
          }
      }
      ```

---

### 9. ⚠️ Gài: Cần export **CSV**: bạn đặt endpoint và content negotiation như thế nào để vẫn tuân thủ REST?
- **Endpoint**:
    - Dùng `/resources/export` hoặc query param `format=csv`:
      ```http
      GET /users/export?format=csv
      ```
- **Content Negotiation**:
    - Client gửi header `Accept: text/csv`.
    - Server trả `Content-Type: text/csv`.
    - Ví dụ:
      ```java
      @GetMapping(value = "/users/export", produces = "text/csv")
      public ResponseEntity<String> exportUsersCsv() {
          String csv = userService.exportToCsv();
          return ResponseEntity.ok()
              .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=users.csv")
              .body(csv);
      }
      ```
- **Tuân thủ REST**:
    - Giữ URI là resource (`/users/export`), dùng `Accept` để chọn format.
    - Trả `200 OK` với body là CSV.

---

### 10. Tài liệu hóa: yêu cầu tối thiểu của **OpenAPI** (định nghĩa schema, examples, error responses).
- **Yêu cầu tối thiểu**:
    - **Info**: Tên API, version, mô tả.
    - **Paths**: Định nghĩa endpoint, method, tham số, response.
    - **Schemas**: Định nghĩa cấu trúc request/response (như `UserDTO`).
    - **Examples**: Ví dụ payload cho request/response.
    - **Error Responses**: Mô tả HTTP status (400, 404) và error model.
- **Ví dụ (OpenAPI YAML)**:
  ```yaml
  openapi: 3.0.3
  info:
    title: User API
    version: 1.0.0
  paths:
    /users:
      get:
        summary: List users
        responses:
          '200':
            content:
              application/json:
                schema:
                  type: array
                  items:
                    $ref: '#/components/schemas/User'
          '400':
            content:
              application/problem+json:
                schema:
                  $ref: '#/components/schemas/Error'
  components:
    schemas:
      User:
        type: object
        properties:
          id: { type: integer }
          name: { type: string }
      Error:
        type: object
        properties:
          code: { type: string }
          message: { type: string }
  ```

---

# 2) HTTP Status Codes (Ánh xạ đúng & Tinh gọn)

### 1. Khi **tạo** resource thành công, nên trả mã gì và kèm header nào? Khác biệt 200 vs **201**.
- **Tạo thành công**:
    - Trả `201 Created`.
    - Header: `Location: /resources/{id}`.
    - Ví dụ:
      ```http
      POST /users
      201 Created
      Location: /users/123
      ```
- **200 vs 201**:
    - `200 OK`: Request thành công, thường dùng cho `GET` hoặc `POST` không tạo resource.
    - `201 Created`: Tạo resource mới, kèm `Location` để chỉ resource vừa tạo.

---

### 2. Khi **xóa** resource idempotent (xóa nhiều lần cũng như nhau) trả mã gì hợp lý?
- **Trả mã**:
    - `204 No Content`: Xóa thành công, không cần body.
    - `404 Not Found`: Nếu resource không tồn tại (vẫn idempotent).
- **Ví dụ**:
  ```http
  DELETE /users/123
  204 No Content
  ```

---

### 3. ⚠️ Gài: Truy vấn rỗng (không có item nào) với **GET /resources** nên trả 200 với mảng rỗng hay 404? Vì sao?
- **Trả**:
    - `200 OK` với mảng rỗng (`[]`).
- **Tại sao**:
    - Collection resource (`/resources`) tồn tại, chỉ là không có item.
    - `404 Not Found` phù hợp khi resource cụ thể (như `/resources/123`) không tồn tại.
- **Ví dụ**:
  ```http
  GET /users
  200 OK
  []
  ```

---

### 4. Phân biệt **400** (bad request) vs **422** (unprocessable entity) trong validate dữ liệu.
- **400 Bad Request**:
    - Request sai cú pháp hoặc không hợp lệ (như JSON sai format).
    - Ví dụ: `POST /users` với body không phải JSON.
- **422 Unprocessable Entity**:
    - Request hợp lệ về cú pháp, nhưng dữ liệu không xử lý được (như email sai định dạng).
    - Ví dụ: `POST /users` với `{ "email": "invalid" }`.
- **Lựa chọn**:
    - `400`: Lỗi chung, client cần sửa request.
    - `422`: Lỗi validate cụ thể, kèm chi tiết field lỗi.

---

### 5. Phân biệt **401** vs **403** với ví dụ cụ thể; khi nào dùng **407** (proxy auth)?
- **401 Unauthorized**:
    - Chưa xác thực (thiếu token hoặc sai username/password).
    - Ví dụ: Gọi `/api/users` mà không gửi JWT.
- **403 Forbidden**:
    - Đã xác thực nhưng không đủ quyền.
    - Ví dụ: User với role `USER` gọi `/admin/users`.
- **407 Proxy Authentication Required**:
    - Yêu cầu xác thực tại proxy server.
    - Ví dụ: Client cần cung cấp credentials cho proxy trước khi gửi request.

---

### 6. Tài nguyên di chuyển: khi nào trả **301/308** vs **302/307**? Ảnh hưởng tới idempotency.
- **301 Moved Permanently**:
    - Resource di chuyển vĩnh viễn.
    - Dùng cho: URL cũ bị deprecate, client nên lưu URL mới.
- **308 Permanent Redirect**:
    - Giống `301`, nhưng giữ nguyên HTTP method.
- **302 Found**:
    - Redirect tạm thời, không yêu cầu client lưu URL mới.
- **307 Temporary Redirect**:
    - Giống `302`, nhưng giữ nguyên method.
- **Idempotency**:
    - `301/308` không ảnh hưởng idempotency nếu client làm theo redirect.
    - `302/307` có thể phá idempotency nếu client đổi method (như `POST` thành `GET`).

---

### 7. **409 Conflict** dùng cho các tình huống nào (duplicate, state conflict, optimistic locking)?
- **Tình huống**:
    - **Duplicate**: Tạo resource đã tồn tại (như `POST /users` với email trùng).
    - **State conflict**: Request xung đột với trạng thái hiện tại (như đặt hàng khi hết hàng).
    - **Optimistic locking**: Cập nhật resource bị xung đột version.
- **Ví dụ**:
  ```http
  PUT /users/123
  409 Conflict
  { "code": "version_conflict", "message": "Resource updated by another request" }
  ```

---

### 8. **429 Too Many Requests**: nên trả thêm header gì (rate limit, retry-after)?
- **Header**:
    - `X-Rate-Limit-Limit`: Giới hạn request tối đa.
    - `X-Rate-Limit-Remaining`: Số request còn lại.
    - `Retry-After`: Thời gian chờ trước khi thử lại (giây hoặc timestamp).
- **Ví dụ**:
  ```http
  429 Too Many Requests
  X-Rate-Limit-Limit: 100
  X-Rate-Limit-Remaining: 0
  Retry-After: 60
  ```

---

### 9. ⚠️ Gài: Khi upload thành công nhưng xử lý hậu kỳ vẫn chạy nền, nên trả status nào hợp lý? (gợi ý 202)
- **Trả**:
    - `202 Accepted`: Request được chấp nhận, nhưng xử lý chưa hoàn tất.
    - Kèm header `Location` để client theo dõi trạng thái:
      ```http
      POST /uploads
      202 Accepted
      Location: /uploads/123/status
      ```
- **Lý do**:
    - Phù hợp với REST khi xử lý bất đồng bộ (như upload file rồi xử lý nền).

---

### 10. **5xx** khi nào được phép trả ra? Rủi ro lạm dụng 500 che lỗi 4xx hợp lệ.
- **Khi trả 5xx**:
    - Lỗi server ngoài dự đoán (như DB crash, upstream timeout).
    - Ví dụ: `500 Internal Server Error`, `503 Service Unavailable`.
- **Rủi ro lạm dụng 500**:
    - Che giấu lỗi 4xx (như validate sai → `400`, không đủ quyền → `403`).
    - Làm client khó xử lý đúng (như retry với `500` thay vì sửa request).
- **Giải pháp**:
    - Ánh xạ lỗi chính xác:
      ```java
      if (user == null) throw new ResponseStatusException(HttpStatus.NOT_FOUND);
      if (!hasPermission) throw new ResponseStatusException(HttpStatus.FORBIDDEN);
      ```

---

# 3) Error Handling & Error Model

### 1. Tiêu chí của một **error response** tốt: trường tối thiểu nên có (code nội bộ, message, fields lỗi, correlationId, timestamp, docs link).
- **Trường tối thiểu**:
    - `code`: Mã lỗi nội bộ (như `user_not_found`).
    - `message`: Thông điệp dễ hiểu (như `User with ID 123 not found`).
    - `fields`: Chi tiết lỗi validate (như `{ "email": "Invalid format" }`).
    - `correlationId`: ID để trace lỗi.
    - `timestamp`: Thời gian lỗi (ISO 8601).
    - `docs`: Link đến tài liệu API.
- **Ví dụ**:
  ```json
  {
    "code": "validation_failed",
    "message": "Invalid input data",
    "fields": { "email": "Must be valid email" },
    "correlationId": "123e4567-e89b-12d3-a456-426614174000",
    "timestamp": "2025-08-15T17:46:00Z",
    "docs": "https://api.example.com/docs/errors"
  }
  ```

---

### 2. So sánh error model **tự thiết kế** với **RFC 7807 Problem Details** (`application/problem+json`). Khi nào nên dùng mỗi loại?
- **Tự thiết kế**:
    - Linh hoạt, tùy chỉnh theo nhu cầu (như thêm `fields`, `code`).
    - **Ưu**: Dễ tích hợp với client nội bộ.
    - **Nhược**: Không chuẩn, client bên ngoài khó hiểu.
- **RFC 7807 Problem Details**:
    - Chuẩn: `type`, `title`, `status`, `detail`, `instance`.
    - Content-Type: `application/problem+json`.
    - Ví dụ:
      ```json
      {
        "type": "https://api.example.com/errors/validation",
        "title": "Validation Error",
        "status": 422,
        "detail": "Invalid email format",
        "instance": "/users/123"
      }
      ```
    - **Ưu**: Chuẩn hóa, dễ tích hợp với client RESTful.
    - **Nhược**: Ít linh hoạt hơn cho nhu cầu đặc thù.
- **Lựa chọn**:
    - Tự thiết kế: API nội bộ, cần tùy chỉnh mạnh.
    - RFC 7807: API công khai, cần tuân thủ chuẩn.

---

### 3. Chuẩn hóa **mã lỗi nội bộ** (domain-specific) tách biệt với HTTP status — lợi ích cho client.
- **Lợi ích**:
    - Client biết chính xác lỗi (như `user_not_found` thay vì chỉ `404`).
    - Dễ xử lý logic cụ thể (như retry, hiển thị thông báo).
    - Tách biệt logic nghiệp vụ khỏi HTTP status.
- **Ví dụ**:
  ```json
  {
    "code": "insufficient_balance",
    "message": "Account balance is too low",
    "status": 409
  }
  ```

---

### 4. ⚠️ Gài: Có nên trả **stack trace**/chi tiết SQL ra ngoài? Trình bày chính sách “leak-proof” nhưng vẫn hỗ trợ debug.
- **Không trả stack trace/SQL**:
    - Lộ thông tin nhạy cảm (như cấu trúc DB, server version).
    - Tăng nguy cơ tấn công (như SQL injection dựa trên lỗi).
- **Chính sách leak-proof**:
    - Chỉ trả `code`, `message`, `correlationId` cho client.
    - Log chi tiết (stack trace, SQL) vào server log với `correlationId`.
    - Ví dụ:
      ```java
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
          @ExceptionHandler(Exception.class)
          public ResponseEntity<ErrorResponse> handleException(Exception ex, WebRequest request) {
              String correlationId = request.getHeader("X-Correlation-Id");
              log.error("Error occurred, correlationId={}", correlationId, ex);
              return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                  .body(new ErrorResponse("internal_error", "An unexpected error occurred", correlationId));
          }
      }
      ```

---

### 5. Trả lỗi **multi-field validation** (nhiều trường sai cùng lúc) cần cấu trúc payload ra sao?
- **Payload**:
  ```json
  {
    "code": "validation_failed",
    "message": "Invalid input data",
    "fields": {
      "email": "Must be valid email",
      "name": "Cannot be empty",
      "age": "Must be at least 18"
    },
    "correlationId": "123e4567-e89b-12d3-a456-426614174000",
    "timestamp": "2025-08-15T17:46:00Z"
  }
  ```
- **Cấu hình**:
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
          Map<String, String> fields = ex.getBindingResult().getFieldErrors().stream()
              .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));
          return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY)
              .body(new ErrorResponse("validation_failed", "Invalid input data", fields));
      }
  }
  ```

---

### 6. Phân biệt **business error** (ví dụ “số dư không đủ”) với **validation error** (format email sai). Trả status & body khác nhau?
- **Business error**:
    - Liên quan đến logic nghiệp vụ (như `InsufficientBalanceException`).
    - Status: `409 Conflict` hoặc `400 Bad Request`.
    - Body:
      ```json
      {
        "code": "insufficient_balance",
        "message": "Account balance is too low",
        "status": 409
      }
      ```
- **Validation error**:
    - Lỗi cú pháp hoặc định dạng (như email sai).
    - Status: `422 Unprocessable Entity`.
    - Body:
      ```json
      {
        "code": "validation_failed",
        "message": "Invalid input data",
        "fields": { "email": "Invalid format" }
      }
      ```

---

### 7. i18n thông điệp lỗi: server nên trả **message key** hay **message đã dịch**? Trade-off.
- **Message key**:
    - Trả `code` như `invalid_email`, client dịch dựa trên locale.
    - **Ưu**: Payload nhỏ, client linh hoạt chọn ngôn ngữ.
    - **Nhược**: Client phải xử lý i18n.
- **Message đã dịch**:
    - Server dịch dựa trên `Accept-Language` hoặc query param `lang`.
    - **Ưu**: Client nhận thông điệp sẵn dùng.
    - **Nhược**: Server phải quản lý nhiều ngôn ngữ.
- **Trade-off**:
    - Message key: Phù hợp API công khai, client đa dạng.
    - Message đã dịch: Tốt cho API nội bộ, client đơn giản.

---

### 8. Idempotency & retries: cách thiết kế lỗi **transient** (503/504) vs **permanent** (4xx) để client biết chiến lược retry.
- **Transient (503/504)**:
    - Lỗi tạm thời (như DB timeout, upstream không phản hồi).
    - Trả `Retry-After` để client thử lại.
    - Ví dụ:
      ```http
      503 Service Unavailable
      Retry-After: 30
      ```
- **Permanent (4xx)**:
    - Lỗi cố định (như `400`, `422`, `403`), client không nên retry.
    - Ví dụ:
      ```http
      422 Unprocessable Entity
      { "code": "invalid_email", "message": "Email format is invalid" }
      ```
- **Thiết kế**:
    - Transient: Trả `503`, `504` với `Retry-After`.
    - Permanent: Trả `4xx` với chi tiết lỗi.

---

### 9. Logging & correlation: log gì ở server khi xảy ra lỗi để khớp với `X-Correlation-Id` client gửi lên?
- **Log gì**:
    - `correlationId`, HTTP status, error code, message, stack trace.
    - Ví dụ:
      ```java
      log.error("Error processing request, correlationId={}, status={}, code={}, message={}",
          correlationId, status, errorCode, message, exception);
      ```
- **Cơ chế**:
    - Dùng MDC để gắn `correlationId`:
      ```java
      MDC.put("correlationId", request.getHeader("X-Correlation-Id"));
      ```

---

### 10. ⚠️ Gài: Khi upstream timeout, bạn bọc lỗi thành 500 hay 504? Cách bảo toàn ngữ nghĩa HTTP.
- **Trả**:
    - `504 Gateway Timeout`: Upstream (như DB, API khác) không phản hồi kịp.
- **Tại sao không 500**:
    - `500 Internal Server Error` dành cho lỗi nội tại server (như code crash).
    - `504` chính xác hơn, báo client rằng lỗi do upstream.
- **Bảo toàn ngữ nghĩa**:
  ```java
  try {
      Response response = upstreamService.call();
      return ResponseEntity.ok(response);
  } catch (TimeoutException ex) {
      throw new ResponseStatusException(HttpStatus.GATEWAY_TIMEOUT, "Upstream service timed out");
  }
  ```

---

# 4) Tối ưu Response & Caching

### 1. Khi nào dùng **ETag** vs `Last-Modified`? Trình bày flow với **If-None-Match** → **304 Not Modified**.
- **ETag**:
    - Chuỗi hash đại diện trạng thái resource (như MD5 của content).
    - Dùng khi: Resource thay đổi phức tạp, không chỉ dựa vào thời gian.
- **Last-Modified**:
    - Timestamp lần cuối resource thay đổi.
    - Dùng khi: Resource có thời gian cập nhật rõ ràng.
- **Flow với If-None-Match**:
    1. Server trả resource với `ETag: "abc123"`.
    2. Client gửi `If-None-Match: "abc123"` trong request tiếp theo.
    3. Server kiểm tra ETag:
        - Nếu khớp → trả `304 Not Modified`.
        - Nếu khác → trả `200 OK` với body mới.
- **Ví dụ**:
  ```java
  @GetMapping("/users/{id}")
  public ResponseEntity<User> getUser(@PathVariable Long id, @RequestHeader(value = "If-None-Match", required = false) String ifNoneMatch) {
      User user = userService.findById(id);
      String etag = generateEtag(user);
      if (ifNoneMatch != null && ifNoneMatch.equals(etag)) {
          return ResponseEntity.status(HttpStatus.NOT_MODIFIED).build();
      }
      return ResponseEntity.ok().eTag(etag).body(user);
  }
  ```

---

### 2. **Cache-Control** (public, private, no-store, max-age, s-maxage) áp dụng cho tài nguyên nào?
- **`public`**: Có thể cache bởi mọi proxy/CDN.
    - Dùng: Tài nguyên tĩnh (như `/images/logo.png`).
- **`private`**: Chỉ cache bởi client.
    - Dùng: Dữ liệu cá nhân (như `/users/123/profile`).
- **`no-store`**: Không cache.
    - Dùng: Dữ liệu nhạy cảm (như `/payment`).
- **`max-age`**: Thời gian cache hợp lệ (giây).
    - Dùng: Tài nguyên thay đổi ít (như `/products`).
- **`s-maxage`**: Thời gian cache cho proxy/CDN.
    - Dùng: API công khai qua CDN.
- **Ví dụ**:
  ```http
  Cache-Control: public, max-age=3600
  ```

---

### 3. Compression (gzip/br) & pagination lớn: các **anti-pattern** thường gặp (nén hai lần, stream không đóng…).
- **Anti-pattern**:
    - **Nén hai lần**: Server nén gzip, nhưng CDN nén lại, gây lỗi giải nén.
    - **Stream không đóng**: Trả dữ liệu lớn qua stream nhưng không đóng, gây memory leak.
    - **Pagination lớn**: Cho phép `size` quá lớn, gây tải nặng server.
- **Giải pháp**:
    - Kiểm tra header `Accept-Encoding`:
      ```java
      @GetMapping(value = "/data", produces = MediaType.APPLICATION_JSON_VALUE)
      public ResponseEntity<StreamingResponseBody> streamData() {
          StreamingResponseBody stream = out -> {
              // Viết stream
              out.flush();
          };
          return ResponseEntity.ok()
              .header(HttpHeaders.CONTENT_ENCODING, "gzip")
              .body(stream);
      }
      ```
    - Giới hạn `size` (như 100).

---

### 4. ⚠️ Gài: Trả **206 Partial Content** cho tải tệp lớn — yêu cầu header nào từ client?
- **Header yêu cầu**:
    - `Range: bytes=0-999`: Client chỉ định phạm vi byte.
- **Server response**:
    - `206 Partial Content`.
    - Headers: `Content-Range: bytes 0-999/10000`, `Content-Length: 1000`.
- **Ví dụ**:
  ```http
  GET /files/large.pdf
  Range: bytes=0-999
  
  Response:
  206 Partial Content
  Content-Range: bytes 0-999/10000
  Content-Length: 1000
  ```

---

### 5. **Conditional requests** cho PUT/PATCH để chống overwrite (If-Match với ETag) — vì sao quan trọng?
- **Tại sao quan trọng**:
    - Ngăn cập nhật xung đột (như hai client cùng sửa resource).
    - Đảm bảo tính toàn vẹn dữ liệu.
- **Flow**:
    1. Client lấy resource với `ETag: "v1"`.
    2. Client gửi `PUT` với `If-Match: "v1"`.
    3. Server kiểm tra ETag:
        - Nếu khớp → cập nhật, trả `200`.
        - Nếu không khớp → trả `412 Precondition Failed`.
- **Ví dụ**:
  ```java
  @PutMapping("/users/{id}")
  public ResponseEntity<Void> updateUser(@PathVariable Long id, @RequestBody UserDTO dto, @RequestHeader("If-Match") String ifMatch) {
      User user = userService.findById(id);
      if (!ifMatch.equals(generateEtag(user))) {
          throw new ResponseStatusException(HttpStatus.PRECONDITION_FAILED);
      }
      userService.update(user, dto);
      return ResponseEntity.ok().build();
  }
  ```

---

# 5) Idempotency, Concurrency & Consistency

### 1. Idempotency key cho **POST** (tạo đơn hàng, thanh toán) — cơ chế, lưu ở đâu, timeout?
- **Cơ chế**:
    - Client gửi `Idempotency-Key` trong header.
    - Server kiểm tra key:
        - Nếu chưa có → xử lý, lưu key và response vào cache/DB.
        - Nếu đã có → trả response cũ.
- **Lưu ở đâu**:
    - Cache (như Redis) hoặc DB (bảng `idempotency_keys`).
    - Ví dụ (Redis):
      ```java
      @PostMapping("/orders")
      public ResponseEntity<Order> createOrder(@RequestHeader("Idempotency-Key") String key, @RequestBody OrderDTO dto) {
          String cached = redis.get(key);
          if (cached != null) {
              return ResponseEntity.ok(objectMapper.readValue(cached, Order.class));
          }
          Order order = orderService.create(dto);
          redis.setex(key, 3600, objectMapper.writeValueAsString(order)); // Timeout 1h
          return ResponseEntity.status(HttpStatus.CREATED).body(order);
      }
      ```
- **Timeout**:
    - 1-24 giờ, tùy nghiệp vụ (như 1 giờ cho thanh toán).

---

### 2. **Optimistic locking**: cách trình bày conflict cho client (409 và lỗi chi tiết).
- **Cơ chế**:
    - Dùng `@Version` trong JPA hoặc ETag.
    - Khi conflict, trả `409 Conflict`.
- **Response**:
  ```json
  {
    "code": "version_conflict",
    "message": "Resource has been modified by another request",
    "currentVersion": 2,
    "timestamp": "2025-08-15T17:46:00Z"
  }
  ```

---

### 3. ⚠️ Gài: Client gửi cùng một request hai lần, server đã tạo resource — server nên trả response gì lần thứ hai?
- **Trả**:
    - `200 OK` hoặc `201 Created` với resource đã tạo, kèm `Location` header.
- **Lý do**:
    - Với `Idempotency-Key`, server nhận diện request trùng, trả response cũ.
    - Đảm bảo idempotency: gọi lại không tạo resource mới.
- **Ví dụ**:
  ```http
  POST /orders
  Idempotency-Key: abc123
  201 Created
  Location: /orders/456
  ```

---

### 4. Đảm bảo **at-least-once** vs **exactly-once** trong bối cảnh API + hàng đợi — vai trò của idempotency key.
- **At-least-once**:
    - Request được xử lý ít nhất một lần (có thể trùng).
    - Phù hợp hàng đợi không đảm bảo exactly-once delivery.
- **Exactly-once**:
    - Request chỉ xử lý đúng một lần.
    - Dùng `Idempotency-Key` để server nhận diện và bỏ qua request trùng.
- **Vai trò idempotency key**:
    - Lưu key và response để trả kết quả cũ cho request trùng.
    - Đảm bảo exactly-once semantics trong môi trường phân tán.

---

### 5. Hợp đồng **partial update** bằng PATCH + JSON Merge Patch/JSON Patch — tiêu chí lựa chọn, rủi ro.
- **JSON Merge Patch**:
    - Gửi object với field cần cập nhật:
      ```json
      PATCH /users/123
      { "name": "New Name" }
      ```
    - **Ưu**: Đơn giản, dễ hiểu.
    - **Nhược**: Không hỗ trợ xóa field hoặc thao tác phức tạp.
- **JSON Patch**:
    - Gửi mảng thao tác (`add`, `remove`, `replace`):
      ```json
      PATCH /users/123
      [
        { "op": "replace", "path": "/name", "value": "New Name" },
        { "op": "remove", "path": "/email" }
      ]
      ```
    - **Ưu**: Linh hoạt, hỗ trợ thao tác chi tiết.
    - **Nhược**: Phức tạp hơn, cần client hiểu chuẩn.
- **Lựa chọn**:
    - JSON Merge Patch: API đơn giản, client không cần logic phức tạp.
    - JSON Patch: Cần cập nhật phức tạp (như thêm/xóa phần tử mảng).
- **Rủi ro**:
    - Merge Patch: Không rõ ý định xóa field (null có thể là lỗi).
    - JSON Patch: Sai cú pháp path hoặc op gây lỗi `400`.

---

# 6) Bảo mật (Nhẹ) & Giới hạn Tốc độ

### 1. Các header bảo mật cơ bản cần có trong response (CORS, `X-Content-Type-Options`, `X-Frame-Options`/`CSP`).
- **Header**:
    - **CORS**: `Access-Control-Allow-Origin: https://example.com`.
    - **`X-Content-Type-Options: nosniff`**: Ngăn browser đoán content type.
    - **`X-Frame-Options: DENY`**: Ngăn nhúng iframe.
    - **`Content-Security-Policy`**: Giới hạn nguồn tài nguyên (như `script-src 'self'`).
- **Ví dụ**:
  ```java
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http.headers(headers -> headers
          .contentTypeOptions()
          .and()
          .frameOptions(frame -> frame.deny())
          .contentSecurityPolicy(csp -> csp.policyDirectives("script-src 'self'")));
      return http.build();
  }
  ```

---

### 2. **CORS**: chiến lược allow-list origin & phương thức; tránh `*` cho credentialed requests.
- **Chiến lược**:
    - Allow-list: Chỉ cho phép origin cụ thể (như `https://frontend.com`).
    - Phương thức: Chỉ cho phép `GET`, `POST`, `PUT`, v.v.
    - Ví dụ:
      ```java
      @Bean
      public CorsConfigurationSource corsConfigurationSource() {
          CorsConfiguration config = new CorsConfiguration();
          config.addAllowedOrigin("https://frontend.com");
          config.addAllowedMethod("GET,POST,PUT");
          config.setAllowCredentials(true);
          UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
          source.registerCorsConfiguration("/**", config);
          return source;
      }
      ```
- **Tránh `***`**:
    - Credentialed requests (như gửi cookie) yêu cầu origin cụ thể.
    - `*` làm lộ thông tin nhạy cảm cho domain không tin cậy.

---

### 3. **Rate limiting** & **throttling**: vị trí thực thi (API gateway vs service), contract lỗi khi vượt ngưỡng.
- **Vị trí**:
    - **API Gateway**: Thực thi chung cho tất cả service (như Spring Cloud Gateway).
    - **Service**: Thực thi chi tiết theo endpoint (như dùng `@RateLimiter`).
- **Contract lỗi**:
    - Trả `429 Too Many Requests`.
    - Header: `X-Rate-Limit-Limit`, `X-Rate-Limit-Remaining`, `Retry-After`.
- **Ví dụ**:
  ```java
  @Bean
  public RateLimiterRegistry rateLimiterRegistry() {
      return RateLimiterRegistry.of(RateLimiterConfig.custom()
          .limitForPeriod(100)
          .timeoutDuration(Duration.ofSeconds(60))
          .build());
  }
  ```

---

### 4. ⚠️ Gài: API công khai nhưng có endpoint “admin-only” — bạn truyền thông chính sách rate/role thế nào trong OpenAPI?
- **OpenAPI**:
    - Mô tả quyền trong `securitySchemes` và rate limit trong `responses`.
    - Ví dụ:
      ```yaml
      paths:
        /admin/users:
          get:
            security:
              - bearerAuth: [ROLE_ADMIN]
            responses:
              '200':
                description: Success
              '429':
                description: Too Many Requests
                headers:
                  Retry-After:
                    schema:
                      type: integer
      components:
        securitySchemes:
          bearerAuth:
            type: http
            scheme: bearer
            bearerFormat: JWT
      ```

---

# 7) ControllerAdvice & ExceptionHandler (Xử lý Exception Toàn cục)

### 1. Sự khác nhau giữa `@ExceptionHandler` trong **controller cụ thể** và `@RestControllerAdvice`/`@ControllerAdvice` toàn cục.
- **Trong controller**:
    - `@ExceptionHandler` chỉ xử lý exception trong controller đó.
    - Ví dụ:
      ```java
      @RestController
      public class UserController {
          @ExceptionHandler(UserNotFoundException.class)
          public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
              return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse("user_not_found", ex.getMessage()));
          }
      }
      ```
- **Toàn cục**:
    - `@RestControllerAdvice` xử lý exception cho tất cả controller.
    - Ví dụ:
      ```java
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ExceptionHandler(UserNotFoundException.class)
          public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
              return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse("user_not_found", ex.getMessage()));
          }
      }
      ```

---

### 2. Cơ chế chọn **handler phù hợp** khi có nhiều `@ExceptionHandler` bắt cùng kiểu. `@Order` ảnh hưởng ra sao?
- **Cơ chế**:
    - Spring chọn handler dựa trên mức độ cụ thể của exception (con class trước cha class).
    - Nếu cùng mức độ, ưu tiên `@ExceptionHandler` trong controller trước `@RestControllerAdvice`.
    - `@Order` hoặc `@Priority` quyết định thứ tự trong `@RestControllerAdvice`.
- **Ví dụ**:
  ```java
  @RestControllerAdvice
  @Order(1)
  public class SpecificExceptionHandler {
      @ExceptionHandler(IllegalArgumentException.class)
      public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException ex) {
          return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse("specific_error", ex.getMessage()));
      }
  }
  @RestControllerAdvice
  @Order(2)
  public class GenericExceptionHandler {
      @ExceptionHandler(Exception.class)
      public ResponseEntity<ErrorResponse> handleGeneric(Exception ex) {
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ErrorResponse("generic_error", ex.getMessage()));
      }
  }
  ```

---

### 3. Mapping exception → HTTP status: dùng `@ResponseStatus`, ném `ResponseStatusException`, hay trả `ResponseEntity` — khi nào chọn cách nào?
- **@ResponseStatus**:
    - Gắn trực tiếp vào exception class:
      ```java
      @ResponseStatus(HttpStatus.NOT_FOUND)
      public class UserNotFoundException extends RuntimeException {}
      ```
    - **Khi dùng**: Exception cố định status (như `UserNotFoundException` → `404`).
- **ResponseStatusException**:
    - Ném runtime với status tùy chỉnh:
      ```java
      throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found");
      ```
    - **Khi dùng**: Cần status động hoặc không muốn tạo exception class.
- **ResponseEntity**:
    - Trả trực tiếp từ `@ExceptionHandler`:
      ```java
      @ExceptionHandler(UserNotFoundException.class)
      public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
          return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse("user_not_found", ex.getMessage()));
      }
      ```
    - **Khi dùng**: Cần tùy chỉnh body, header.

---

### 4. ⚠️ Gài: Vì sao handler **không chạy** khi exception bị **catch** ở dưới và không ném lên? Cách thiết kế để vẫn có error model chuẩn hóa.
- **Nguyên nhân**:
    - Exception bị catch trong service/controller, không ném lên để `@RestControllerAdvice` xử lý.
    - Ví dụ:
      ```java
      @GetMapping("/users/{id}")
      public ResponseEntity<User> getUser(@PathVariable Long id) {
          try {
              return ResponseEntity.ok(userService.findById(id));
          } catch (UserNotFoundException ex) {
              return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null); // Không chuẩn hóa
          }
      }
      ```
- **Thiết kế chuẩn hóa**:
    - Luôn ném exception lên:
      ```java
      @GetMapping("/users/{id}")
      public User getUser(@PathVariable Long id) {
          return userService.findById(id); // Ném UserNotFoundException
      }
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ExceptionHandler(UserNotFoundException.class)
          public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
              return ResponseEntity.status(HttpStatus.NOT_FOUND)
                  .body(new ErrorResponse("user_not_found", ex.getMessage()));
          }
      }
      ```

---

### 5. Kết hợp **validation** (JSR 380) với advice: gom `MethodArgumentNotValidException` thành payload thống nhất.
- **Cấu hình**:
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
          Map<String, String> fields = ex.getBindingResult().getFieldErrors().stream()
              .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));
          ErrorResponse error = new ErrorResponse("validation_failed", "Invalid input data", fields);
          return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
      }
  }
  ```
- **Payload**:
  ```json
  {
    "code": "validation_failed",
    "message": "Invalid input data",
    "fields": {
      "email": "Must be valid email",
      "name": "Cannot be empty"
    }
  }
  ```

---

### 6. Dòng chảy log lỗi: log ở advice hay ở filter/interceptor? Tránh double-logging.
- **Log ở advice**:
    - `@RestControllerAdvice` là nơi tập trung xử lý lỗi, log chi tiết với `correlationId`.
    - Ví dụ:
      ```java
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
          @ExceptionHandler(Exception.class)
          public ResponseEntity<ErrorResponse> handleException(Exception ex, WebRequest request) {
              String correlationId = request.getHeader("X-Correlation-Id");
              log.error("Error, correlationId={}", correlationId, ex);
              return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                  .body(new ErrorResponse("internal_error", ex.getMessage()));
          }
      }
      ```
- **Tránh double-logging**:
    - Không log trong filter/interceptor trừ khi cần ghi request metadata.
    - Dùng MDC để gắn `correlationId` xuyên suốt.

---

### 7. Trả error response nhất quán cho **sync** và **async** (Callable/DeferredResult) — cần lưu ý gì?
- **Sync**:
    - Trả `ResponseEntity` từ `@ExceptionHandler`.
- **Async (Callable/DeferredResult)**:
    - Xử lý exception trong `AsyncHandlerExceptionResolver` hoặc `@RestControllerAdvice`.
    - Ví dụ:
      ```java
      @GetMapping("/async")
      public Callable<User> getUserAsync() {
          return () -> {
              try {
                  return userService.findById(1L);
              } catch (Exception ex) {
                  throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found");
              }
          };
      }
      ```
- **Lưu ý**:
    - Đảm bảo `@RestControllerAdvice` bắt được exception từ async.
    - Trả error response thống nhất (như RFC 7807).

---

### 8. Truyền `correlationId`/`traceId` vào error response từ advice như thế nào?
- **Cơ chế**:
    - Lấy `correlationId` từ header hoặc MDC.
    - Thêm vào `ErrorResponse`.
- **Ví dụ**:
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(Exception.class)
      public ResponseEntity<ErrorResponse> handleException(Exception ex, WebRequest request) {
          String correlationId = request.getHeader("X-Correlation-Id");
          if (correlationId == null) correlationId = MDC.get("correlationId");
          ErrorResponse error = new ErrorResponse("internal_error", ex.getMessage(), correlationId);
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
      }
  }
  ```

---

### 9. ⚠️ Gài: Vì sao `@ControllerAdvice` không bắt lỗi của **WebFlux** hoặc **filter** tự viết? Phạm vi tác dụng.
- **Nguyên nhân**:
    - `@ControllerAdvice` chỉ bắt exception từ controller layer trong Spring MVC.
    - **WebFlux**: Dùng `WebExceptionHandler` thay vì `@ControllerAdvice`.
    - **Filter**: Exception xảy ra trước khi đến controller, không vào scope của `@ControllerAdvice`.
- **Phạm vi tác dụng**:
    - `@ControllerAdvice`: Controller và service layer trong MVC.
- **Giải pháp**:
    - WebFlux:
      ```java
      @Component
      public class GlobalWebExceptionHandler implements WebExceptionHandler {
          @Override
          public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
              ErrorResponse error = new ErrorResponse("internal_error", ex.getMessage());
              exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);
              return exchange.getResponse().writeWith(Mono.just(exchange.getResponse().bufferFactory().wrap(error.toJson())));
          }
      }
      ```
    - Filter: Xử lý trong `Filter` hoặc ném lên controller.

---

### 10. Test `@ControllerAdvice`: chiến lược viết **integration test** cho mapping lỗi chuẩn (MockMvc/WebTestClient).
- **MockMvc (MVC)**:
  ```java
  @SpringBootTest
  @AutoConfigureMockMvc
  public class ExceptionHandlerTest {
      @Autowired
      private MockMvc mockMvc;
      @Test
      public void testUserNotFound() throws Exception {
          mockMvc.perform(get("/users/999"))
              .andExpect(status().isNotFound())
              .andExpect(jsonPath("$.code").value("user_not_found"));
      }
  }
  ```
- **WebTestClient (WebFlux)**:
  ```java
  @SpringBootTest
  @AutoConfigureWebTestClient
  public class ExceptionHandlerTest {
      @Autowired
      private WebTestClient webTestClient;
      @Test
      public void testUserNotFound() {
          webTestClient.get().uri("/users/999")
              .exchange()
              .expectStatus().isNotFound()
              .expectBody()
              .jsonPath("$.code").isEqualTo("user_not_found");
      }
  }
  ```

---

# 8) Mini Case (Thực chiến 2–5 phút mỗi câu)

### 1. Thiết kế API **tạo đơn hàng** đảm bảo idempotent: nêu contract header, status 201/200, và error khi key trùng nhưng payload khác.
- **Contract**:
    - Header: `Idempotency-Key: <UUID>`.
    - Request: `POST /orders` với body `{ "items": [], "total": 100 }`.
    - Response:
        - Thành công: `201 Created`, `Location: /orders/123`.
        - Trùng key, cùng payload: `200 OK` với resource cũ.
        - Trùng key, payload khác: `409 Conflict` với `{ "code": "idempotency_conflict", "message": "Request conflicts with existing idempotency key" }`.
- **Ví dụ**:
  ```java
  @PostMapping("/orders")
  public ResponseEntity<Order> createOrder(@RequestHeader("Idempotency-Key") String key, @RequestBody OrderDTO dto) {
      String cached = redis.get(key);
      if (cached != null) {
          Order cachedOrder = objectMapper.readValue(cached, Order.class);
          if (!dto.equals(cachedOrder.toDTO())) {
              throw new ResponseStatusException(HttpStatus.CONFLICT, "Idempotency conflict");
          }
          return ResponseEntity.ok(cachedOrder);
      }
      Order order = orderService.create(dto);
      redis.setex(key, 3600, objectMapper.writeValueAsString(order));
      return ResponseEntity.status(HttpStatus.CREATED)
          .header(HttpHeaders.LOCATION, "/orders/" + order.getId())
          .body(order);
  }
  ```

---

### 2. Xây error model theo **Problem Details** cho validate thất bại: body mẫu, cách nhét `invalid-params`.
- **Body mẫu**:
  ```json
  {
    "type": "https://api.example.com/errors/validation",
    "title": "Validation Error",
    "status": 422,
    "detail": "Invalid input data",
    "instance": "/users",
    "invalid-params": [
      { "name": "email", "reason": "Must be valid email" },
      { "name": "name", "reason": "Cannot be empty" }
    ]
  }
  ```
- **Cấu hình**:
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity<ProblemDetail> handleValidation(MethodArgumentNotValidException ex) {
          ProblemDetail problem = ProblemDetail.forStatusAndDetail(HttpStatus.UNPROCESSABLE_ENTITY, "Invalid input data");
          problem.setType(URI.create("https://api.example.com/errors/validation"));
          List<Map<String, String>> invalidParams = ex.getBindingResult().getFieldErrors().stream()
              .map(e -> Map.of("name", e.getField(), "reason", e.getDefaultMessage()))
              .collect(Collectors.toList());
          problem.setProperty("invalid-params", invalidParams);
          return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(problem);
      }
  }
  ```

---

### 3. Chuẩn hóa pagination cho toàn hệ thống: quyết định tên tham số, status khi trang vượt quá giới hạn, và links `first/prev/next/last`.
- **Tham số**:
    - `page`: 0-based, mặc định 0.
    - `size`: Mặc định 20, tối đa 100.
    - `sort`: `<field>,<asc|desc>` (như `sort=createdAt,desc`).
- **Status khi vượt giới hạn**:
    - `416 Range Not Satisfiable` nếu `page` vượt tổng số trang.
    - Ví dụ:
      ```http
      GET /users?page=999
      416 Range Not Satisfiable
      { "code": "page_out_of_range", "message": "Requested page exceeds total pages" }
      ```
- **Links**:
    - Trả trong header `Link` hoặc body:
      ```json
      {
        "content": [...],
        "_links": {
          "first": { "href": "/users?page=0&size=20" },
          "prev": { "href": "/users?page=1&size=20" },
          "next": { "href": "/users?page=3&size=20" },
          "last": { "href": "/users?page=10&size=20" }
        }
      }
      ```

---

### 4. Thiết kế retry/backoff phía client với lỗi 503/504; server hỗ trợ header gì để client thông minh hơn.
- **Retry/backoff**:
    - Client dùng exponential backoff (như 1s, 2s, 4s).
    - Server trả `Retry-After`:
      ```http
      503 Service Unavailable
      Retry-After: 30
      ```
- **Header hỗ trợ**:
    - `Retry-After`: Thời gian chờ (giây hoặc timestamp).
    - `X-Retry-Limit`: Giới hạn số lần retry (khuyến nghị).
- **Ví dụ**:
  ```java
  @ExceptionHandler(ServiceUnavailableException.class)
  public ResponseEntity<ErrorResponse> handleServiceUnavailable(ServiceUnavailableException ex) {
      return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
          .header("Retry-After", "30")
          .body(new ErrorResponse("service_unavailable", ex.getMessage()));
  }
  ```

---

### 5. Ánh xạ exception domain (ví dụ `InsufficientBalanceException`) sang HTTP code & body; đảm bảo **không lộ** thông tin nhạy cảm.
- **Ánh xạ**:
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(InsufficientBalanceException.class)
      public ResponseEntity<ErrorResponse> handleInsufficientBalance(InsufficientBalanceException ex) {
          return ResponseEntity.status(HttpStatus.CONFLICT)
              .body(new ErrorResponse("insufficient_balance", "Account balance is too low"));
      }
  }
  ```
- **Không lộ thông tin**:
    - Không trả số dư cụ thể hoặc thông tin tài khoản.
    - Log chi tiết vào server log với `correlationId`.

---

### 6. Sửa API cũ: trước trả 200 cho tạo mới, giờ muốn đúng chuẩn 201 + `Location`. Kế hoạch **backward compatible** và timeline deprecate.
- **Kế hoạch**:
    1. Giữ `200 OK` cho client cũ, thêm header `Location`.
    2. Trả `201 Created` nếu client gửi header `Accept-Version: 2`.
    3. Thông báo deprecation:
       ```http
       Deprecation: true
       Sunset: Fri, 15 Aug 2026 17:46:00 GMT
       ```
    4. Sau 6-12 tháng, chỉ trả `201 Created`.
- **Ví dụ**:
  ```java
  @PostMapping("/users")
  public ResponseEntity<User> createUser(@RequestHeader(value = "Accept-Version", defaultValue = "1") String version, @RequestBody UserDTO dto) {
      User user = userService.create(dto);
      if ("2".equals(version)) {
          return ResponseEntity.status(HttpStatus.CREATED)
              .header(HttpHeaders.LOCATION, "/users/" + user.getId())
              .body(user);
      }
      return ResponseEntity.ok()
          .header(HttpHeaders.LOCATION, "/users/" + user.getId())
          .header("Deprecation", "true")
          .body(user);
  }
  ```

---

### 7. Sự cố: client báo đôi lúc nhận 200 body rỗng khi conditional GET. Hãy nêu checklist kiểm tra ETag/If-None-Match/304.
- **Checklist**:
    1. **ETag sinh sai**: Kiểm tra hàm sinh ETag có nhất quán không.
    2. **If-None-Match không xử lý**: Server không kiểm tra header `If-None-Match`.
    3. **304 sai**: Server trả `200` thay vì `304` khi ETag khớp.
    4. **Cache proxy**: Proxy/CDN can thiệp, trả `200` rỗng.
    5. **Client lỗi**: Client gửi `If-None-Match` sai hoặc không xử lý `304`.
- **Ví dụ sửa**:
  ```java
  @GetMapping("/users/{id}")
  public ResponseEntity<User> getUser(@PathVariable Long id, @RequestHeader(value = "If-None-Match", required = false) String ifNoneMatch) {
      User user = userService.findById(id);
      String etag = generateEtag(user);
      if (ifNoneMatch != null && ifNoneMatch.equals(etag)) {
          return ResponseEntity.status(HttpStatus.NOT_MODIFIED).eTag(etag).build();
      }
      return ResponseEntity.ok().eTag(etag).body(user);
  }
  ```

---

