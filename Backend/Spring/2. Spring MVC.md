# 1) Kiến trúc Spring MVC (Front Controller & các thành phần)

### 1. Mô tả mô hình **Front Controller** của Spring MVC. `DispatcherServlet` đứng ở đâu trong kiến trúc?
- **Front Controller**: Là một design pattern nơi một servlet trung tâm (`DispatcherServlet`) xử lý tất cả HTTP requests, điều phối đến các thành phần phù hợp (controllers, services, views).
- **Vai trò `DispatcherServlet`**:
    - Là **Front Controller** trong Spring MVC, nhận tất cả requests từ client.
    - Chuyển request đến `HandlerMapping` để tìm controller method, gọi `HandlerAdapter` để thực thi, và render response qua `ViewResolver`.
    - Đứng ở đầu pipeline, điều phối toàn bộ luồng xử lý request.
- **Cơ chế**:
    - Nhận request → Map URL đến handler → Thực thi controller → Trả về view hoặc JSON.
- **Ví dụ**: Trong Spring Boot, `DispatcherServlet` tự động cấu hình để xử lý tất cả requests (mặc định map `/`).

---

### 2. Phân biệt vai trò: `DispatcherServlet`, `HandlerMapping`, `HandlerAdapter`, `Controller`, `ViewResolver`, `View`, `Model`, `ModelAndView`, `HttpMessageConverter`.
- **`DispatcherServlet`**: Front Controller, điều phối request đến các thành phần khác.
- **`HandlerMapping`**: Map URL và HTTP method đến controller method (handler). Ví dụ: `RequestMappingHandlerMapping` map `@RequestMapping`.
- **`HandlerAdapter`**: Thực thi handler (controller method) và trả về `ModelAndView`. Ví dụ: `RequestMappingHandlerAdapter` hỗ trợ `@RequestMapping`.
- **`Controller`**: Class xử lý logic request, trả về view name hoặc dữ liệu (JSON). Đánh dấu bởi `@Controller` hoặc `@RestController`.
- **`ViewResolver`**: Chuyển view name thành `View` (như Thymeleaf, JSP). Ví dụ: `InternalResourceViewResolver` cho JSP.
- **`View`**: Đối tượng render response (như HTML từ Thymeleaf). Ví dụ: `ThymeleafView`.
- **`Model`**: Container chứa dữ liệu (key-value) truyền từ controller đến view.
- **`ModelAndView`**: Gộp `Model` và view name, dùng khi controller trả về cả hai.
- **`HttpMessageConverter`**: Chuyển đổi request/response body (như JSON, XML). Ví dụ: `MappingJackson2HttpMessageConverter` cho JSON.

---

### 3. ⚠️ Gài: Khi nào Spring gọi **HandlerMapping** trước **HandlerAdapter**? Nếu có nhiều HandlerMapping, Spring ưu tiên thế nào?
- **Thứ tự**:
    - Spring gọi `HandlerMapping` trước để tìm handler (controller method) dựa trên URL, HTTP method, headers, v.v.
    - Sau khi tìm được handler, `HandlerAdapter` được gọi để thực thi handler và xử lý kết quả trả về.
- **Nhiều HandlerMapping**:
    - Spring duyệt qua tất cả `HandlerMapping` theo thứ tự ưu tiên (`@Order` hoặc `Ordered` interface).
    - HandlerMapping đầu tiên trả về handler hợp lệ được chọn.
    - Ví dụ: `RequestMappingHandlerMapping` (cho `@RequestMapping`) thường có ưu tiên cao hơn `SimpleUrlHandlerMapping`.
- **Lưu ý**: Nếu không HandlerMapping nào khớp, Spring ném `404 Not Found`.

---

### 4. `Model` khác gì `ModelMap` và `ModelAndView`? Khi nào chọn mỗi loại?
- **`Model`**:
    - Interface, chứa dữ liệu key-value truyền đến view.
    - Dùng trong method signature: `public String method(Model model)`.
- **`ModelMap`**:
    - Class cụ thể, mở rộng `LinkedHashMap`, cung cấp API giống `Model`.
    - Dùng khi cần thêm nhiều thuộc tính hoặc logic phức tạp.
- **`ModelAndView`**:
    - Gộp `Model` và view name, cho phép trả cả view và dữ liệu.
    - Dùng khi controller cần chỉ định rõ view name: `return new ModelAndView("viewName", model)`.
- **Khi chọn**:
    - `Model`: Dùng cho đơn giản, chỉ cần thêm dữ liệu vào view.
    - `ModelMap`: Dùng khi cần thao tác phức tạp với dữ liệu (như merge nhiều map).
    - `ModelAndView`: Dùng khi cần trả cả view name và dữ liệu, đặc biệt trong `@Controller`.

---

### 5. Cơ chế **Content Negotiation** hoạt động ra sao (header `Accept`, extension, query param)?
- **Content Negotiation**: Spring chọn định dạng response (JSON, XML, HTML) dựa trên yêu cầu client.
- **Cơ chế**:
    - **Header `Accept`**: Client chỉ định định dạng mong muốn (như `application/json`).
    - **Extension**: URL có đuôi (như `.json`, `.xml`). Ví dụ: `/api/users.json`.
    - **Query param**: Tham số `format` (như `?format=json`).
- **Thứ tự ưu tiên** (mặc định):
    1. Extension (nếu bật `PathExtensionContentNegotiationStrategy`).
    2. Query param (`format`).
    3. Header `Accept`.
- **Cấu hình**:
  ```java
  @Bean
  public ContentNegotiationConfigurer configurer() {
      return new ContentNegotiationConfigurer() {
          @Override
          public void configureContentNegotiation(ContentNegotiationManagerFactoryBean factory) {
              factory.addMediaType("json", MediaType.APPLICATION_JSON);
              factory.setFavorParameter(true);
          }
      };
  }
  ```

---

### 6. Liên hệ Spring MVC với **Template Engines** (Thymeleaf, JSP): `ViewResolver` cấu hình thế nào, `prefix`/`suffix` ảnh hưởng gì?
- **Liên hệ**:
    - Spring MVC dùng `ViewResolver` để map view name sang template (Thymeleaf, JSP).
    - Template engine render `Model` thành HTML.
- **Cấu hình `ViewResolver`**:
    - **Thymeleaf**:
      ```java
      @Bean
      public ThymeleafViewResolver thymeleafViewResolver() {
          ThymeleafViewResolver resolver = new ThymeleafViewResolver();
          resolver.setTemplateEngine(templateEngine());
          resolver.setViewNames(new String[] {"*.html"});
          resolver.setOrder(1);
          return resolver;
      }
      ```
    - **JSP**:
      ```java
      @Bean
      public InternalResourceViewResolver jspViewResolver() {
          InternalResourceViewResolver resolver = new InternalResourceViewResolver();
          resolver.setPrefix("/WEB-INF/views/");
          resolver.setSuffix(".jsp");
          return resolver;
      }
      ```
- **`prefix`/`suffix`**:
    - `prefix`: Thư mục chứa template (như `/WEB-INF/views/`).
    - `suffix`: Đuôi file (như `.jsp`, `.html`).
    - Ví dụ: View name `home` → `/WEB-INF/views/home.jsp`.

---

### 7. ⚠️ Gài: Vì sao đôi khi view không render dù controller trả về tên view hợp lệ? Kể ít nhất 3 nguyên nhân có thể.
1. **ViewResolver không cấu hình đúng**:
    - `prefix`/`suffix` sai hoặc thiếu, dẫn đến không tìm thấy file template.
    - Ví dụ: `prefix=/views/` nhưng template nằm ở `/WEB-INF/views/`.
2. **Không có ViewResolver phù hợp**:
    - Template engine (như Thymeleaf) không được cấu hình hoặc dependency thiếu.
    - Ví dụ: Thiếu `spring-boot-starter-thymeleaf` cho Thymeleaf.
3. **Tên view không khớp**:
    - View name trả về không tồn tại hoặc không khớp với `ViewResolver`’s `viewNames`.
    - Ví dụ: Trả `home` nhưng template là `home.html` và `suffix` không cấu hình.
- **Xác minh**: Kiểm tra log, cấu hình `ViewResolver`, và đường dẫn template.

---

### 8. Phân biệt **Filter**, **Interceptor**, **AOP** về vị trí trong pipeline và use case điển hình.
- **`Filter`**:
    - **Vị trí**: Chạy trước `DispatcherServlet`, trong Servlet container (như Tomcat).
    - **Use-case**: Logging, CORS, CSRF protection, authentication.
    - **Ví dụ**: `CorsFilter` cho CORS.
- **`Interceptor`**:
    - **Vị trí**: Chạy trong Spring MVC pipeline, trước/sau khi gọi controller method (`preHandle`, `postHandle`, `afterCompletion`).
    - **Use-case**: Kiểm tra quyền, logging request, đo thời gian xử lý.
    - **Ví dụ**: `HandlerInterceptor` để log thời gian request.
- **`AOP`**:
    - **Vị trí**: Chạy ở tầng logic (cross-cutting concerns), không giới hạn trong MVC.
    - **Use-case**: Transaction management, logging, performance monitoring.
    - **Ví dụ**: `@Transactional` cho service method.
- **So sánh**:
    - `Filter`: Xử lý ở mức HTTP, không biết Spring context.
    - `Interceptor`: Biết Spring context, phù hợp cho logic MVC.
    - `AOP`: Linh hoạt hơn, áp dụng ở bất kỳ tầng nào.

---

### 9. `ControllerAdvice`/`RestControllerAdvice` nằm ở tầng nào trong pipeline? Tác động tới binding/exception ra sao?
- **Vị trí**: Chạy trong Spring MVC pipeline, sau khi controller method xử lý hoặc khi có exception.
- **Tác động**:
    - **Binding**: Dùng `@InitBinder` để tùy chỉnh data binding toàn cục:
      ```java
      @ControllerAdvice
      public class GlobalBindingAdvice {
          @InitBinder
          public void initBinder(WebDataBinder binder) {
              binder.addValidators(new CustomValidator());
          }
      }
      ```
    - **Exception**: Dùng `@ExceptionHandler` để xử lý lỗi toàn cục:
      ```java
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ExceptionHandler(ValidationException.class)
          public ResponseEntity<?> handleValidation(ValidationException ex) {
              return ResponseEntity.badRequest().body(ex.getMessage());
          }
      }
      ```
- **`@RestControllerAdvice`**: Tương tự `@ControllerAdvice`, nhưng tự động áp dụng `@ResponseBody` cho JSON response.

---

### 10. Khi nào nên tách **DTO** ra khỏi **Entity** ở tầng MVC? Hệ quả nếu bind trực tiếp Entity lên form/JSON?
- **Khi nào tách DTO**:
    - Cần expose dữ liệu khác với Entity (như ẩn trường nhạy cảm).
    - Tránh lộ cấu trúc DB hoặc quan hệ JPA (như lazy loading).
    - Cần validate khác nhau giữa create/update.
- **Hệ quả nếu bind trực tiếp Entity**:
    - **Lazy loading**: Gây `LazyInitializationException` nếu truy cập quan hệ ngoài session.
    - **Over-posting**: Client có thể gửi dữ liệu vào trường không mong muốn (như `id`).
    - **Dữ liệu nhạy cảm**: Lộ thông tin như `password`.
    - **JSON recursion**: Quan hệ hai chiều (như `@OneToMany`) gây infinite recursion.
- **Giải pháp**: Dùng DTO và map với `MapStruct` hoặc thủ công.

---

# 2) Luồng xử lý request end-to-end

### 1. Mô tả chi tiết luồng: HTTP request → `DispatcherServlet` → chọn handler → gọi controller method → xử lý service/repo → trả `ModelAndView`/`ResponseEntity` → resolve view/serialize → HTTP response.
1. **HTTP request**: Client gửi request (như `GET /users`).
2. **`DispatcherServlet`**: Nhận request, điều phối đến `HandlerMapping`.
3. **Chọn handler**: `HandlerMapping` tìm controller method dựa trên URL, HTTP method, v.v.
4. **Gọi controller method**: `HandlerAdapter` thực thi method, inject tham số (`@RequestParam`, `@RequestBody`).
5. **Xử lý service/repo**: Controller gọi service/repo để xử lý logic, truy cập DB.
6. **Trả `ModelAndView`/`ResponseEntity`**:
    - MVC: Trả `ModelAndView` chứa view name và dữ liệu.
    - REST: Trả `ResponseEntity` hoặc object với `@ResponseBody`.
7. **Resolve view/serialize**:
    - MVC: `ViewResolver` map view name sang `View`, render HTML.
    - REST: `HttpMessageConverter` serialize object thành JSON/XML.
8. **HTTP response**: Trả response về client (HTML, JSON, v.v.).

---

### 2. Spring chọn **controller method** dựa trên những tiêu chí nào (URL, HTTP method, params, headers, consumes/produces)?
- **Tiêu chí**:
    - **URL**: So khớp với `@RequestMapping` hoặc `@GetMapping` path.
    - **HTTP method**: `GET`, `POST`, v.v. (như `@GetMapping`, `@PostMapping`).
    - **Params**: Tham số query hoặc form (như `params = "type=admin"`).
    - **Headers**: HTTP headers (như `headers = "X-API-Version=1"`).
    - **Consumes**: Content-Type của request body (như `consumes = "application/json"`).
    - **Produces**: Accept header của response (như `produces = "application/json"`).
- **Ví dụ**:
  ```java
  @GetMapping(value = "/users", params = "role=admin", produces = MediaType.APPLICATION_JSON_VALUE)
  public List<User> getAdminUsers() { ... }
  ```

---

### 3. ⚠️ Gài: Hai method mapping “na ná” nhau—Spring ném lỗi gì, và cách disambiguate (cụ thể tiêu chí ưu tiên)?
- **Lỗi**: Spring ném `AmbiguousHandlerMethodsException` nếu không xác định được method duy nhất.
- **Ví dụ**:
  ```java
  @GetMapping("/users")
  public String method1() { ... }
  @GetMapping("/users")
  public String method2() { ... }
  ```
- **Disambiguate**:
    - Thêm tiêu chí cụ thể:
        - **Params**: `params = "type=admin"`.
        - **Headers**: `headers = "X-API-Version=1"`.
        - **Consumes/Produces**: `consumes = "application/json"`.
    - **Ưu tiên**:
        1. Path chính xác hơn (như `/users/{id}` > `/users`).
        2. HTTP method cụ thể (như `GET` > bất kỳ).
        3. Params/headers/consumes/produces khớp chính xác hơn.
- **Giải pháp**:
  ```java
  @GetMapping(value = "/users", params = "type=admin")
  public String method1() { ... }
  @GetMapping(value = "/users", params = "type=user")
  public String method2() { ... }
  ```

---

### 4. Giải thích các **HandlerMethodArgumentResolver** phổ biến (bind `@PathVariable`, `@RequestParam`, `@RequestBody`, `@RequestHeader`, `@CookieValue`, `Principal`, `Pageable` …).
- **HandlerMethodArgumentResolver**: Chuyển đổi tham số request thành argument của controller method.
- **Phổ biến**:
    - **`@PathVariable`**: Lấy giá trị từ URL path (như `/users/{id}` → `id`).
    - **`@RequestParam`**: Lấy query param hoặc form data (như `?name=John`).
    - **`@RequestBody`**: Deserialize request body (JSON/XML) thành object.
    - **`@RequestHeader`**: Lấy giá trị từ HTTP header.
    - **`@CookieValue`**: Lấy giá trị từ cookie.
    - **`Principal`**: Lấy user đã xác thực (từ `SecurityContext`).
    - **`Pageable`**: Lấy thông tin phân trang/sorting (như `?page=0&size=10`).
- **Ví dụ**:
  ```java
  @GetMapping("/users/{id}")
  public User getUser(@PathVariable Long id, @RequestParam String name, @RequestBody UserDTO userDTO) { ... }
  ```

---

### 5. **HandlerMethodReturnValueHandler** xử lý những kiểu trả về nào (`String`, `ModelAndView`, `ResponseEntity`, object với `@ResponseBody`, `void`)?
- **HandlerMethodReturnValueHandler**: Xử lý giá trị trả về của controller method.
- **Kiểu trả về**:
    - **`String`**: View name (MVC) hoặc raw body (nếu `@ResponseBody`).
    - **`ModelAndView`**: Gộp view name và `Model` cho MVC.
    - **`ResponseEntity`**: Response với status, headers, body (thường cho REST).
    - **Object với `@ResponseBody`**: Serialize thành JSON/XML.
    - **`void`**: Không trả body (status 200) hoặc forward đến view mặc định.
- **Ví dụ**:
  ```java
  @GetMapping("/users")
  public ModelAndView getUsers() {
      return new ModelAndView("users", "users", userList);
  }
  @GetMapping("/api/users")
  @ResponseBody
  public List<User> getUsersApi() {
      return userList;
  }
  ```

---

### 6. Trình tự chạy của **Interceptor** (`preHandle`/`postHandle`/`afterCompletion`) trong lifecycle một request.
- **Trình tự**:
    1. **`preHandle`**: Chạy trước khi gọi controller method. Trả `false` để hủy request.
    2. **`postHandle`**: Chạy sau controller method, trước khi render view. Dùng để modify `ModelAndView`.
    3. **`afterCompletion`**: Chạy sau khi response hoàn tất, kể cả khi có exception.
- **Ví dụ**:
  ```java
  public class LoggingInterceptor implements HandlerInterceptor {
      @Override
      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
          log.info("Before controller");
          return true;
      }
      @Override
      public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
          log.info("After controller");
      }
      @Override
      public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
          log.info("After response");
      }
  }
  ```

---

### 7. ⚠️ Gài: Sự khác nhau về phạm vi xử lý lỗi giữa `@ExceptionHandler`, `ControllerAdvice`, và `HandlerExceptionResolver`.
- **`@ExceptionHandler`**:
    - Phạm vi: Chỉ trong controller chứa nó.
    - Dùng để xử lý lỗi cục bộ.
    - Ví dụ:
      ```java
      @ExceptionHandler(ValidationException.class)
      public ResponseEntity<?> handleValidation(ValidationException ex) { ... }
      ```
- **`ControllerAdvice`/`RestControllerAdvice`**:
    - Phạm vi: Toàn cục, áp dụng cho tất cả controllers.
    - Dùng cho lỗi chung hoặc binding toàn cục.
- **`HandlerExceptionResolver`**:
    - Phạm vi: Toàn cục, chạy ở mức `DispatcherServlet`.
    - Dùng để xử lý lỗi không được catch bởi `@ExceptionHandler` hoặc `@ControllerAdvice`.
    - Ví dụ: `SimpleMappingExceptionResolver` map lỗi đến view.
- **Ưu tiên**: `@ExceptionHandler` (cục bộ) > `@ControllerAdvice` > `HandlerExceptionResolver`.

---

### 8. Cơ chế **HttpMessageConverter**: Khi nào được dùng? Cách chọn converter cho JSON/XML/Form.
- **Khi nào dùng**:
    - Đọc `@RequestBody` (deserialize JSON/XML/form → object).
    - Viết `@ResponseBody` hoặc `ResponseEntity` (serialize object → JSON/XML).
- **Cách chọn converter**:
    - Spring duyệt qua danh sách `HttpMessageConverter` (như `MappingJackson2HttpMessageConverter` cho JSON).
    - Chọn converter dựa trên:
        - **Content-Type** của request (cho `@RequestBody`).
        - **Accept header** hoặc `produces` (cho `@ResponseBody`).
    - Ví dụ:
      ```java
      @PostMapping(value = "/users", consumes = MediaType.APPLICATION_JSON_VALUE)
      public User createUser(@RequestBody UserDTO userDTO) { ... }
      ```
- **Cấu hình**:
  ```java
  @Bean
  public MappingJackson2HttpMessageConverter jsonConverter() {
      return new MappingJackson2HttpMessageConverter();
  }
  ```

---

### 9. Ảnh hưởng của **async** (`Callable`, `DeferredResult`, `SseEmitter`) tới luồng xử lý và timeouts.
- **Async**:
    - **Callable**: Trả về `Callable<T>`, chạy logic trong thread riêng, `DispatcherServlet` trả thread về pool.
    - **DeferredResult**: Trả về `DeferredResult<T>`, cho phép set result từ thread khác (như queue consumer).
    - **SseEmitter**: Trả về stream dữ liệu (Server-Sent Events) cho real-time updates.
- **Ảnh hưởng**:
    - Giảm blocking của main thread, tăng throughput.
    - Timeout: Cần cấu hình `AsyncTaskExecutor` hoặc timeout trong `DeferredResult`:
      ```java
      @GetMapping("/async")
      public DeferredResult<String> async() {
          DeferredResult<String> result = new DeferredResult<>(5000L); // 5s timeout
          asyncService.process(result);
          return result;
      }
      ```
- **Lưu ý**: Cấu hình `taskExecutor` và timeout trong `WebMvcConfigurer`.

---

### 10. CORS kiểm soát ở đâu trong luồng (Filter vs `@CrossOrigin`)? Ưu/nhược mỗi cách?
- **Filter**:
    - Chạy trước `DispatcherServlet`, trong Servlet container.
    - Dùng `CorsFilter` hoặc cấu hình global:
      ```java
      @Bean
      public CorsFilter corsFilter() {
          CorsConfiguration config = new CorsConfiguration();
          config.addAllowedOrigin("*");
          UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
          source.registerCorsConfiguration("/**", config);
          return new CorsFilter(source);
      }
      ```
    - **Ưu**: Toàn cục, áp dụng cho tất cả endpoints, kể cả non-Spring.
    - **Nhược**: Ít linh hoạt, khó tùy chỉnh cho từng endpoint.
- **`@CrossOrigin`**:
    - Chạy trong Spring MVC, áp dụng trên class/method.
    - Ví dụ:
      ```java
      @CrossOrigin(origins = "http://example.com")
      @GetMapping("/users")
      public List<User> getUsers() { ... }
      ```
    - **Ưu**: Linh hoạt, cấu hình chi tiết cho từng endpoint.
    - **Nhược**: Phải annotate nhiều nơi, dễ bỏ sót.

---

# 3) Vai trò của Controller, Model, ViewResolver

### 1. `@Controller` chịu trách nhiệm gì? Khi nào trả tên view vs trả dữ liệu JSON?
- **Trách nhiệm**:
    - Xử lý HTTP request, gọi service/repo, trả response (view name hoặc JSON).
- **Khi trả tên view**:
    - Dùng trong MVC truyền thống, render HTML qua template (Thymeleaf, JSP).
    - Ví dụ:
      ```java
      @Controller
      public class UserController {
          @GetMapping("/users")
          public String getUsers(Model model) {
              model.addAttribute("users", userService.findAll());
              return "users"; // View name
          }
      }
      ```
- **Khi trả JSON**:
    - Dùng `@ResponseBody` hoặc `@RestController` cho REST API.
    - Ví dụ:
      ```java
      @RestController
      public class UserApiController {
          @GetMapping("/api/users")
          public List<User> getUsers() {
              return userService.findAll();
          }
      }
      ```

---

### 2. `Model` dùng để làm gì? Dữ liệu trong `Model` đi tới view như thế nào?
- **Dùng để**:
    - Chứa dữ liệu (key-value) truyền từ controller đến view.
- **Cách truyền**:
    - Controller thêm dữ liệu vào `Model`:
      ```java
      model.addAttribute("user", user);
      ```
    - `ViewResolver` resolve view name thành `View` (như `ThymeleafView`).
    - Template engine (Thymeleaf, JSP) truy cập dữ liệu qua key:
      ```html
      <!-- Thymeleaf -->
      <p th:text="${user.name}"></p>
      ```

---

### 3. ⚠️ Gài: `RedirectAttributes` khác `Model` gì trong pattern **PRG** (Post/Redirect/Get)? Khi nào dùng **flash attributes**?
- **`RedirectAttributes`**:
    - Dùng trong PRG để truyền dữ liệu qua redirect (lưu trong session tạm thời).
    - **Flash attributes**: Dữ liệu chỉ sống qua một redirect, tự động xóa sau khi render.
- **Khác `Model`**:
    - `Model`: Truyền dữ liệu trực tiếp đến view trong cùng request.
    - `RedirectAttributes`: Truyền dữ liệu qua redirect, lưu tạm trong session.
- **Khi dùng flash attributes**:
    - Thông báo thành công/lỗi sau POST:
      ```java
      @PostMapping("/users")
      public String createUser(@ModelAttribute User user, RedirectAttributes redirectAttributes) {
          userService.save(user);
          redirectAttributes.addFlashAttribute("message", "User created");
          return "redirect:/users";
      }
      ```

---

### 4. `ViewResolver` là gì, có những loại phổ biến nào? Thứ tự `order` của nhiều ViewResolver ảnh hưởng thế nào?
- **`ViewResolver`**: Map view name thành `View` để render response.
- **Loại phổ biến**:
    - `InternalResourceViewResolver`: Cho JSP.
    - `ThymeleafViewResolver`: Cho Thymeleaf.
    - `ContentNegotiatingViewResolver`: Chọn resolver dựa trên content negotiation.
- **Thứ tự `order`**:
    - Spring duyệt `ViewResolver` theo `order` (thấp hơn chạy trước).
    - Ví dụ:
      ```java
      @Bean
      public ThymeleafViewResolver thymeleafViewResolver() {
          ThymeleafViewResolver resolver = new ThymeleafViewResolver();
          resolver.setOrder(1);
          return resolver;
      }
      @Bean
      public InternalResourceViewResolver jspViewResolver() {
          InternalResourceViewResolver resolver = new InternalResourceViewResolver();
          resolver.setOrder(2);
          return resolver;
      }
      ```
    - Nếu Thymeleaf không resolve được, thử JSP.

---

### 5. Khi render Thymeleaf, lấy biến từ `Model` ở view; kể 3 lỗi binding thường gặp và cách nhận diện.
1. **Sai tên biến**:
    - Dùng `${user.name}` nhưng `Model` chỉ có `userName`.
    - **Nhận diện**: `Property or field 'name' cannot be found`.
    - **Giải pháp**: Kiểm tra key trong `Model`.
2. **Null object**:
    - Truy cập `${user.address.street}` khi `address` là null.
    - **Nhận diện**: `NullPointerException` hoặc không render.
    - **Giải pháp**: Dùng `th:if="${user.address != null}"`.
3. **Sai định dạng**:
    - Bind số hoặc ngày không đúng format (như `String` thay vì `LocalDate`).
    - **Nhận diện**: `Failed to convert property value`.
    - **Giải pháp**: Dùng `@DateTimeFormat` hoặc custom converter.

---

### 6. `@SessionAttributes` làm gì? Rủi ro khi quên xóa dữ liệu session-bound?
- **`@SessionAttributes`**:
    - Lưu dữ liệu trong `Model` vào `HttpSession` để dùng qua nhiều request.
    - Ví dụ:
      ```java
      @Controller
      @SessionAttributes("user")
      public class UserController {
          @GetMapping("/edit")
          public String edit(Model model) {
              model.addAttribute("user", new User());
              return "edit";
          }
          @PostMapping("/save")
          public String save(@ModelAttribute("user") User user, SessionStatus status) {
              status.setComplete(); // Xóa khỏi session
              return "redirect:/home";
          }
      }
      ```
- **Rủi ro quên xóa**:
    - Memory leak: Dữ liệu session không được xóa, tích lũy trong server.
    - Dữ liệu cũ: Request sau dùng lại dữ liệu sai.
- **Giải pháp**: Gọi `SessionStatus.setComplete()` sau khi hoàn tất.

---

### 7. ⚠️ Gài: Khi controller trả `String` tên view nhưng **cũng có** `@ResponseBody` trên method thì chuyện gì xảy ra?
- **Hành vi**:
    - `@ResponseBody` khiến Spring trả `String` như raw body (text/plain) thay vì view name.
    - `ViewResolver` không được gọi, không render template.
- **Ví dụ**:
  ```java
  @GetMapping("/test")
  @ResponseBody
  public String test() {
      return "home"; // Trả "home" như text, không phải view
  }
  ```
- **Lưu ý**: Dùng `@RestController` cũng tương tự, vì nó bao gồm `@ResponseBody`.

---

# 4) Xử lý request & response (HTTP, status, headers)

### 1. Chuẩn REST: phân biệt **GET/POST/PUT/PATCH/DELETE** về tính **safe**/**idempotent**. Hệ quả khi dùng sai.
- **Safe**: Không thay đổi trạng thái server (chỉ đọc).
- **Idempotent**: Gọi nhiều lần cho cùng kết quả.
- **Phân biệt**:
    - **GET**: Safe, idempotent (lấy dữ liệu). Sai: Dùng GET để update → lộ dữ liệu qua URL.
    - **POST**: Không safe, không idempotent (tạo resource). Sai: Dùng POST để lấy dữ liệu → không cache được.
    - **PUT**: Không safe, idempotent (update toàn bộ resource). Sai: Dùng PUT để update partial → mất dữ liệu.
    - **PATCH**: Không safe, không idempotent (update một phần). Sai: Dùng PATCH để tạo → không chuẩn REST.
    - **DELETE**: Không safe, idempotent (xóa resource). Sai: Dùng DELETE để update → hành vi không rõ ràng.
- **Hệ quả**: Sai HTTP method gây hiểu nhầm, lỗi cache, hoặc vi phạm chuẩn REST.

---

### 2. Khi nào nên dùng `ResponseEntity` thay vì trả object thuần + `@ResponseBody`? Cách set status, headers, cookies.
- **Khi dùng `ResponseEntity`**:
    - Cần kiểm soát status, headers, hoặc cookies.
    - Trả response phức tạp (như `201 Created` với `Location` header).
- **Ví dụ**:
  ```java
  @PostMapping("/users")
  public ResponseEntity<User> createUser(@RequestBody User user) {
      User saved = userService.save(user);
      HttpHeaders headers = new HttpHeaders();
      headers.add("Location", "/users/" + saved.getId());
      headers.add(HttpHeaders.SET_COOKIE, "session=abc; Path=/");
      return ResponseEntity.status(HttpStatus.CREATED).headers(headers).body(saved);
  }
  ```
- **Trả object thuần**:
    - Dùng khi chỉ cần body (JSON) và status mặc định (200).
    - Ví dụ:
      ```java
      @GetMapping("/users")
      public List<User> getUsers() {
          return userService.findAll();
      }
      ```

---

### 3. ⚠️ Gài: Trả về **201 Created** cần kèm header nào? Cách set `Location` chuẩn.
- **Header cần kèm**: `Location`, chỉ URL của resource mới tạo.
- **Cách set chuẩn**:
  ```java
  @PostMapping("/users")
  public ResponseEntity<User> createUser(@RequestBody User user) {
      User saved = userService.save(user);
      URI location = ServletUriComponentsBuilder
          .fromCurrentRequest()
          .path("/{id}")
          .buildAndExpand(saved.getId())
          .toUri();
      return ResponseEntity.created(location).body(saved);
  }
  ```
- **Lưu ý**: `Location` phải là absolute URL (như `http://example.com/users/1`).

---

### 4. Set **cache headers** (ETag, `Cache-Control`, `Last-Modified`) trong Spring MVC thế nào?
- **Cách set**:
    - **ETag**: Dùng `ShallowEtagHeaderFilter` hoặc custom:
      ```java
      @Bean
      public ShallowEtagHeaderFilter etagFilter() {
          return new ShallowEtagHeaderFilter();
      }
      ```
    - **Cache-Control**:
      ```java
      @GetMapping("/users")
      public ResponseEntity<List<User>> getUsers() {
          HttpHeaders headers = new HttpHeaders();
          headers.setCacheControl(CacheControl.maxAge(1, TimeUnit.HOURS).cachePublic());
          return ResponseEntity.ok().headers(headers).body(userService.findAll());
      }
      ```
    - **Last-Modified**:
      ```java
      @GetMapping("/users/{id}")
      public ResponseEntity<User> getUser(@PathVariable Long id, @RequestHeader("If-Modified-Since") Optional<Date> ifModifiedSince) {
          User user = userService.findById(id);
          HttpHeaders headers = new HttpHeaders();
          headers.setLastModified(user.getLastModified());
          return ResponseEntity.ok().headers(headers).body(user);
      }
      ```

---

### 5. Mapping và validate **file upload** (multipart) cần cấu hình gì (`MultipartResolver`, giới hạn kích thước, lưu tạm)?
- **Cấu hình**:
    - **MultipartResolver**:
      ```java
      @Bean
      public CommonsMultipartResolver multipartResolver() {
          CommonsMultipartResolver resolver = new CommonsMultipartResolver();
          resolver.setMaxUploadSize(10_000_000); // 10MB
          resolver.setUploadTempDir(new FileSystemResource("/tmp"));
          return resolver;
      }
      ```
    - **Spring Boot**:
      ```properties
      spring.servlet.multipart.max-file-size=10MB
      spring.servlet.multipart.max-request-size=10MB
      spring.servlet.multipart.location=/tmp
      ```
- **Mapping**:
  ```java
  @PostMapping("/upload")
  public String uploadFile(@RequestParam("file") MultipartFile file) {
      // Validate
      if (file.isEmpty()) throw new IllegalArgumentException("File empty");
      // Save file
      file.transferTo(new File("/path/to/save/" + file.getOriginalFilename()));
      return "success";
  }
  ```

---

### 6. **Pagination & Sorting**: nhận `Pageable` từ request như thế nào? Tránh lộ thông tin nội bộ khi trả `Page<T>`.
- **Nhận `Pageable`**:
    - Dùng `Pageable` trong method signature:
      ```java
      @GetMapping("/users")
      public Page<UserDTO> getUsers(Pageable pageable) {
          return userService.findAll(pageable).map(UserDTO::fromEntity);
      }
      ```
    - Query params: `?page=0&size=10&sort=name,asc`.
- **Tránh lộ thông tin**:
    - Map `Page<Entity>` sang `Page<DTO>` để ẩn trường nhạy cảm.
    - Loại bỏ metadata nội bộ (như `PageImpl` fields) trong response.
    - Ví dụ:
      ```java
      public class PageDTO<T> {
          private List<T> content;
          private int page;
          private int size;
          private long totalElements;
          // Getters/Setters
      }
      ```

---

### 7. CORS: `@CrossOrigin` trên method/class vs cấu hình global khác gì?
- **`@CrossOrigin`**:
    - Áp dụng cho method/class cụ thể.
    - Linh hoạt, dễ cấu hình chi tiết.
    - Ví dụ:
      ```java
      @CrossOrigin(origins = "http://example.com")
      @GetMapping("/users")
      public List<User> getUsers() { ... }
      ```
- **Cấu hình global**:
    - Dùng `CorsFilter` hoặc `WebMvcConfigurer`:
      ```java
      @Bean
      public WebMvcConfigurer corsConfigurer() {
          return new WebMvcConfigurer() {
              @Override
              public void addCorsMappings(CorsRegistry registry) {
                  registry.addMapping("/**").allowedOrigins("*");
              }
          };
      }
      ```
    - Áp dụng cho tất cả endpoints, dễ quản lý tập trung.
- **Khác biệt**:
    - `@CrossOrigin`: Linh hoạt hơn, nhưng phải annotate nhiều nơi.
    - Global: Đơn giản hơn, nhưng ít tùy chỉnh.

---

### 8. ⚠️ Gài: Sự cố **JSON infinite recursion** (quan hệ vòng JPA) — dấu hiệu, nguyên nhân, hướng xử lý ở tầng MVC.
- **Dấu hiệu**: `StackOverflowError` hoặc response JSON lặp vô hạn.
- **Nguyên nhân**: Quan hệ hai chiều trong JPA (như `@OneToMany`/`@ManyToOne`) gây vòng lặp khi serialize.
- **Hướng xử lý**:
    1. **Dùng DTO**:
        - Map Entity sang DTO, loại bỏ quan hệ vòng.
        - Ví dụ: Dùng `MapStruct` để map `User` → `UserDTO`.
    2. **@JsonIgnore**:
       ```java
       @Entity
       public class User {
           @OneToMany(mappedBy = "user")
           @JsonIgnore
           private List<Order> orders;
       }
       ```
    3. **@JsonManagedReference/@JsonBackReference**:
       ```java
       @OneToMany(mappedBy = "user")
       @JsonManagedReference
       private List<Order> orders;
       ```
    4. **Custom serializer**:
        - Dùng `Jackson` custom serializer để kiểm soát output.

---

# 5) Mapping & annotations thường dùng

### 1. Phân biệt `@RequestMapping` (class/method-level) với `@GetMapping`, `@PostMapping`… Ưu/nhược trong tổ chức route.
- **`@RequestMapping`**:
    - Generic, hỗ trợ tất cả HTTP methods, có thể dùng trên class/method.
    - Ví dụ:
      ```java
      @RequestMapping("/users")
      public class UserController {
          @RequestMapping(method = RequestMethod.GET)
          public List<User> getUsers() { ... }
      }
      ```
- **`@GetMapping`, `@PostMapping`, …**:
    - Shortcut cho HTTP method cụ thể, chỉ dùng trên method.
    - Ví dụ:
      ```java
      @GetMapping("/users")
      public List<User> getUsers() { ... }
      ```
- **Ưu**:
    - `@GetMapping` ngắn gọn, rõ ràng ý nghĩa.
    - `@RequestMapping` linh hoạt, gộp nhiều method (như GET+POST).
- **Nhược**:
    - `@RequestMapping`: Dễ dài dòng, khó đọc.
    - `@GetMapping`: Không dùng được trên class.

---

### 2. `@PathVariable` — ép kiểu, optional, multi-variables, regex trong path; xử lý khi thiếu biến path.
- **Ép kiểu**: Spring tự động convert `String` thành type (như `Long`, `Integer`).
- **Optional**:
  ```java
  @GetMapping("/users/{id}")
  public User getUser(@PathVariable(required = false) Long id) {
      return id != null ? userService.findById(id) : null;
  }
  ```
- **Multi-variables**:
  ```java
  @GetMapping("/users/{id}/orders/{orderId}")
  public Order getOrder(@PathVariable Long id, @PathVariable Long orderId) { ... }
  ```
- **Regex**:
  ```java
  @GetMapping("/users/{id:\\d+}")
  public User getUser(@PathVariable Long id) { ... } // Chỉ chấp nhận số
  ```
- **Thiếu path variable**: Ném `404 Not Found` hoặc `MissingPathVariableException` nếu `required = true`.

---

### 3. `@RequestParam` — required vs defaultValue, multiple values (List/array), Map params.
- **Required**:
  ```java
  @GetMapping("/users")
  public List<User> getUsers(@RequestParam(required = false) String name) { ... }
  ```
    - Mặc định `required = true`, ném `MissingServletRequestParameterException` nếu thiếu.
- **DefaultValue**:
  ```java
  @GetMapping("/users")
  public List<User> getUsers(@RequestParam(defaultValue = "guest") String name) { ... }
  ```
- **Multiple values**:
  ```java
  @GetMapping("/users")
  public List<User> getUsers(@RequestParam List<String> roles) { ... } // ?roles=admin,user
  ```
- **Map params**:
  ```java
  @GetMapping("/users")
  public List<User> getUsers(@RequestParam Map<String, String> params) { ... } // ?name=John&role=admin
  ```

---

### 4. `@RequestBody` vs `@ModelAttribute`: khác biệt binding; khi nào form-encoded nên dùng cái nào?
- **`@RequestBody`**:
    - Bind request body (JSON/XML) vào object, dùng `HttpMessageConverter`.
    - Dùng cho REST API.
    - Ví dụ:
      ```java
      @PostMapping("/users")
      public User create(@RequestBody UserDTO userDTO) { ... }
      ```
- **`@ModelAttribute`**:
    - Bind form data hoặc query params vào object, dùng `WebDataBinder`.
    - Dùng cho form submission trong MVC.
    - Ví dụ:
      ```java
      @PostMapping("/users")
      public String create(@ModelAttribute UserForm userForm) { ... }
      ```
- **Khi dùng form-encoded**:
    - Dùng `@ModelAttribute` vì phù hợp với `application/x-www-form-urlencoded`.
    - `@RequestBody` phù hợp với JSON/XML.

---

### 5. ⚠️ Gài: Đặt **cả** `@RequestBody` **và** `@RequestParam` cho cùng dữ liệu—Spring xử lý ra sao?
- **Hành vi**:
    - Spring không cho phép `@RequestBody` và `@RequestParam` bind cùng một dữ liệu (như cùng field trong request).
    - `@RequestBody` đọc toàn bộ body, `@RequestParam` đọc query params hoặc form data.
    - Nếu body đã được `@RequestBody` đọc, `@RequestParam` không thể đọc lại (gây lỗi hoặc null).
- **Ví dụ lỗi**:
  ```java
  @PostMapping("/users")
  public String create(@RequestBody UserDTO userDTO, @RequestParam String name) { ... }
  ```
    - `name` sẽ null nếu body là JSON.
- **Giải pháp**: Tách rõ ràng `@RequestBody` cho JSON, `@RequestParam`/`@ModelAttribute` cho form/query.

---

### 6. `@ResponseBody` ở method vs `@RestController` ở class: hành vi có gì khác?
- **`@ResponseBody` trên method**:
    - Chỉ áp dụng cho method đó, serialize return value thành JSON/XML.
    - Dùng trong `@Controller` khi cần JSON cho một vài method.
- **`@RestController` trên class**:
    - Áp dụng `@ResponseBody` cho tất cả method trong class.
    - Tiện cho REST API, không cần annotate từng method.
- **Khác biệt**:
    - `@RestController` giảm boilerplate, nhưng không linh hoạt nếu cần cả MVC và REST.
    - `@ResponseBody` cho phép mix MVC và REST trong cùng controller.

---

### 7. `consumes`/`produces` trong mapping: cách Spring match theo **Content-Type**/**Accept**.
- **`consumes`**:
    - Chỉ định `Content-Type` của request body (như `application/json`).
    - Ví dụ:
      ```java
      @PostMapping(value = "/users", consumes = MediaType.APPLICATION_JSON_VALUE)
      public User create(@RequestBody UserDTO userDTO) { ... }
      ```
- **`produces`**:
    - Chỉ định `Accept` header của response (như `application/json`).
    - Ví dụ:
      ```java
      @GetMapping(value = "/users", produces = MediaType.APPLICATION_JSON_VALUE)
      public List<User> getUsers() { ... }
      ```
- **Matching**:
    - Spring so khớp `Content-Type` với `consumes`, `Accept` với `produces`.
    - Nếu không khớp, ném `406 Not Acceptable` hoặc `415 Unsupported Media Type`.

---

### 8. `@RequestHeader`, `@CookieValue`, `@RequestAttribute`: use case điển hình.
- **`@RequestHeader`**:
    - Lấy giá trị từ HTTP header.
    - Use-case: API versioning (`X-API-Version`), authentication token.
    - Ví dụ:
      ```java
      @GetMapping("/users")
      public List<User> getUsers(@RequestHeader("X-API-Version") String version) { ... }
      ```
- **`@CookieValue`**:
    - Lấy giá trị từ cookie.
    - Use-case: Session tracking, user preferences.
    - Ví dụ:
      ```java
      @GetMapping("/users")
      public List<User> getUsers(@CookieValue("session") String sessionId) { ... }
      ```
- **`@RequestAttribute`**:
    - Lấy attribute từ `HttpServletRequest` (set bởi Filter/Interceptor).
    - Use-case: Truyền dữ liệu từ Filter/Interceptor.
    - Ví dụ:
      ```java
      @GetMapping("/users")
      public List<User> getUsers(@RequestAttribute("userId") Long userId) { ... }
      ```

---

### 9. `@InitBinder` dùng để làm gì? Ảnh hưởng tới conversion/formatting ở level method/controller.
- **Dùng để**:
    - Tùy chỉnh `WebDataBinder` để bind request data (như `@ModelAttribute`).
    - Thêm validator, formatter, hoặc property editor.
- **Ví dụ**:
  ```java
  @InitBinder
  public void initBinder(WebDataBinder binder) {
      binder.addValidators(new UserValidator());
      binder.registerCustomEditor(LocalDate.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true));
  }
  ```
- **Ảnh hưởng**:
    - Áp dụng cho method/controller cụ thể (hoặc toàn cục qua `@ControllerAdvice`).
    - Điều chỉnh cách convert/formatting dữ liệu (như `String` → `LocalDate`).

---

### 10. ⚠️ Gài: **Matrix variables** là gì? Khi nào hoạt động/không hoạt động với `UrlPathHelper`/`PathPatternParser`?
- **Matrix variables**:
    - Tham số trong URL path, dạng `key=value` (như `/users;color=blue;size=10`).
    - Dùng để lọc/tìm kiếm thay vì query params.
    - Ví dụ:
      ```java
      @GetMapping("/users{;color}")
      public List<User> getUsers(@MatrixVariable String color) { ... }
      ```
- **Khi hoạt động**:
    - Cần bật `UrlPathHelper` hoặc `PathPatternParser`:
      ```java
      @Bean
      public WebMvcConfigurer configurer() {
          return new WebMvcConfigurer() {
              @Override
              public void configurePathMatch(PathMatchConfigurer configurer) {
                  configurer.setUseMatrixVariables(true);
              }
          };
      }
      ```
- **Khi không hoạt động**:
    - Tắt matrix variables (`removeSemicolonContent=true`).
    - Sử dụng `PathPatternParser` (Spring Boot 2.6+), vì mặc định không hỗ trợ matrix variables.

---

### 11. Versioning API qua **header**/**param**/**path** — mapping định nghĩa thế nào, trade-off từng cách.
- **Header**:
    - Dùng `@RequestMapping(headers = "X-API-Version=1")`.
    - **Trade-off**:
        - Ưu: Không thay đổi URL, dễ bảo trì.
        - Nhược: Client phải gửi header, khó debug.
- **Param**:
    - Dùng `@RequestParam("version")`.
    - **Trade-off**:
        - Ưu: Dễ test qua URL.
        - Nhược: Làm URL dài, lộ version.
- **Path**:
    - Dùng `@RequestMapping("/v1/users")`.
    - **Trade-off**:
        - Ưu: Rõ ràng, dễ truy cập.
        - Nhược: Thay đổi URL, khó scale khi có nhiều version.

---

### 12. Kiểm soát trailing slash và case-sensitivity trong path matching như thế nào?
- **Trailing slash**:
    - Cấu hình `WebMvcConfigurer`:
      ```java
      @Bean
      public WebMvcConfigurer configurer() {
          return new WebMvcConfigurer() {
              @Override
              public void configurePathMatch(PathMatchConfigurer configurer) {
                  configurer.setUseTrailingSlashMatch(true); // /users = /users/
              }
          };
      }
      ```
- **Case-sensitivity**:
    - Mặc định case-sensitive, tắt bằng:
      ```java
      configurer.setUseCaseSensitiveMatch(false); // /Users = /users
      ```
- **Lưu ý**: Spring Boot 2.6+ dùng `PathPatternParser`, cần cấu hình tương tự.

---

# 6) @Controller vs @RestController

### 1. Khác nhau về **mặc định** `@ResponseBody`: vì sao `@RestController` tiện cho API JSON?
- **`@Controller`**:
    - Dùng cho MVC, trả view name để render template.
    - Cần `@ResponseBody` để trả JSON.
- **`@RestController`**:
    - Kết hợp `@Controller` và `@ResponseBody`, tất cả method trả JSON/XML.
    - Tiện cho REST API vì không cần annotate `@ResponseBody` mỗi method.
- **Ví dụ**:
  ```java
  @RestController
  public class UserApiController {
      @GetMapping("/users")
      public List<User> getUsers() { // Tự động JSON
          return userService.findAll();
      }
  }
  ```

---

### 2. Dùng `@Controller` nhưng muốn trả JSON cho một vài method—cách nào sạch nhất?
- **Cách sạch nhất**:
    - Dùng `@ResponseBody` trên method:
      ```java
      @Controller
      public class UserController {
          @GetMapping("/api/users")
          @ResponseBody
          public List<User> getUsers() {
              return userService.findAll();
          }
          @GetMapping("/users")
          public String getUsersView(Model model) {
              model.addAttribute("users", userService.findAll());
              return "users";
          }
      }
      ```

---

### 3. ⚠️ Gài: Khi kết hợp `@Controller` + `@ResponseBody` + trả `String` — phân biệt trả **raw body** vs tên view.
- **Trả raw body**:
    - Nếu có `@ResponseBody`, `String` được trả như text/plain:
      ```java
      @GetMapping("/test")
      @ResponseBody
      public String test() {
          return "hello"; // Trả "hello" như text
      }
      ```
- **Trả tên view**:
    - Nếu không có `@ResponseBody`, `String` là view name:
      ```java
      @GetMapping("/test")
      public String test() {
          return "test"; // Render test.jsp
      }
      ```

---

### 4. Khi nào nên **không** dùng `@RestController` cho API? (VD: content negotiation phức tạp, hoặc cần render view).
- **Khi không dùng `@RestController`**:
    - Cần hỗ trợ cả MVC (render view) và REST (JSON).
    - Content negotiation phức tạp (như trả HTML hoặc JSON tùy client).
    - Ví dụ:
      ```java
      @Controller
      public class UserController {
          @GetMapping(value = "/users", produces = MediaType.TEXT_HTML_VALUE)
          public String getUsersView(Model model) {
              model.addAttribute("users", userService.findAll());
              return "users";
          }
          @GetMapping(value = "/users", produces = MediaType.APPLICATION_JSON_VALUE)
          @ResponseBody
          public List<User> getUsersApi() {
              return userService.findAll();
          }
      }
      ```

---

### 5. Tác động tới **Exception Handling**: `@ControllerAdvice` vs `@RestControllerAdvice` trả lỗi theo chuẩn JSON khác gì?
- **`@ControllerAdvice`**:
    - Xử lý lỗi cho `@Controller`, thường trả view name hoặc JSON (nếu `@ResponseBody`).
- **`@RestControllerAdvice`**:
    - Kết hợp `@ControllerAdvice` và `@ResponseBody`, luôn trả JSON.
- **Khác biệt**:
    - `@RestControllerAdvice` tiện cho REST API, đảm bảo lỗi luôn là JSON.
    - Ví dụ:
      ```java
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ExceptionHandler(Exception.class)
          public ResponseEntity<?> handleException(Exception ex) {
              return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + ex.getMessage());
          }
      }
      ```

---

# 7) Binding & Validation (@Valid, BindingResult, …)

### 1. Luồng **data binding** từ request → object: conversion service, formatters, property editors hoạt động thế nào?
- **Luồng**:
    1. Request data (query params, form, JSON) được đọc.
    2. `WebDataBinder` bind data vào object:
        - **ConversionService**: Convert `String` → target type (như `String` → `LocalDate`).
        - **Formatter**: Format/Parse dữ liệu (như `@DateTimeFormat`).
        - **PropertyEditor**: Custom conversion (như `String` → `Enum`).
    3. Validation (nếu có `@Valid`).
- **Ví dụ**:
  ```java
  @PostMapping("/users")
  public String create(@ModelAttribute @Valid UserForm userForm, BindingResult result) {
      if (result.hasErrors()) return "error";
      return "success";
  }
  ```

---

### 2. `@Valid` vs `@Validated`: khác biệt, **validation groups**, cách áp dụng cho create/update.
- **`@Valid`**:
    - Chuẩn JSR-303, kích hoạt validation cho object.
    - Không hỗ trợ validation groups.
- **`@Validated`**:
    - Spring-specific, hỗ trợ validation groups.
    - Ví dụ:
      ```java
      public interface CreateGroup {}
      public interface UpdateGroup {}
      public class UserDTO {
          @NotNull(groups = CreateGroup.class)
          private String name;
          @NotNull(groups = UpdateGroup.class)
          private Long id;
      }
      @PostMapping("/users")
      public void create(@Validated(CreateGroup.class) @RequestBody UserDTO userDTO) { ... }
      ```
- **Create/Update**:
    - Dùng groups để validate field khác nhau (như `name` cho create, `id` cho update).

---

### 3. ⚠️ Gài: `BindingResult` phải đứng ở đâu trong chữ ký method? Nếu thiếu thì chuyện gì xảy ra khi validation fail?
- **Vị trí**:
    - `BindingResult` phải đứng **ngay sau** object được validate (`@Valid`/`@Validated`).
    - Ví dụ:
      ```java
      @PostMapping("/users")
      public String create(@Valid @ModelAttribute UserForm userForm, BindingResult result) { ... }
      ```
- **Nếu thiếu**:
    - Validation fail gây `MethodArgumentNotValidException`, được xử lý bởi `@ExceptionHandler` hoặc ném ra ngoài.
    - Response không kiểm soát được, thường trả 400 Bad Request.

---

### 4. Validate **nested object** và **list**: yêu cầu chú thích gì trên field?
- **Nested object**:
    - Dùng `@Valid` trên field:
      ```java
      public class UserDTO {
          @Valid
          private AddressDTO address;
      }
      ```
- **List**:
    - Dùng `@Valid` trên collection:
      ```java
      public class OrderDTO {
          @Valid
          private List<ItemDTO> items;
      }
      ```
- **Lưu ý**: Spring validate từng phần tử trong list nếu có `@Valid`.

---

### 5. Tùy biến thông điệp lỗi i18n qua `MessageSource` (`messages.properties`): cơ chế key resolution.
- **Cơ chế**:
    - Spring dùng `MessageSource` (như `ResourceBundleMessageSource`) để lấy thông điệp từ `messages.properties`.
    - Key resolution:
        - `{constraint}.{field}` (như `NotNull.user.name`).
        - Fallback: `{constraint}` (như `NotNull`).
- **Ví dụ**:
  ```properties
  NotNull.user.name=Tên không được để trống
  ```
  ```java
  public class UserDTO {
      @NotNull(message = "{NotNull.user.name}")
      private String name;
  }
  ```

---

### 6. Viết **custom constraint** (annotation + validator) như thế nào? Case: unique email.
- **Annotation**:
  ```java
  @Target({ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @Constraint(validatedBy = UniqueEmailValidator.class)
  public @interface UniqueEmail {
      String message() default "Email already exists";
      Class<?>[] groups() default {};
      Class<? extends Payload>[] payload() default {};
  }
  ```
- **Validator**:
  ```java
  public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
      @Autowired
      private UserService userService;
      @Override
      public boolean isValid(String email, ConstraintValidatorContext context) {
          return email != null && !userService.existsByEmail(email);
      }
  }
  ```
- **Sử dụng**:
  ```java
  public class UserDTO {
      @UniqueEmail
      private String email;
  }
  ```

---

### 7. Validate **path variable**, **request param** (không có body) — dùng cơ chế gì?
- **Cơ chế**:
    - Dùng `@Validated` trên controller và `@Constraint` trên param:
      ```java
      @Validated
      @RestController
      public class UserController {
          @GetMapping("/users/{id}")
          public User getUser(@PathVariable @Min(1) Long id) { ... }
          @GetMapping("/users")
          public List<User> getUsers(@RequestParam @NotBlank String name) { ... }
      }
      ```
- **Lưu ý**: Cần `@Validated` trên class để kích hoạt validation.

---

### 8. ⚠️ Gài: Validate **partial update** (PATCH) — tránh bắt buộc field khi không gửi; các chiến lược khả thi.
- **Vấn đề**: `@Valid` yêu cầu tất cả field thỏa constraint, không phù hợp với PATCH.
- **Chiến lược**:
    1. **Dùng DTO riêng**:
       ```java
       public class UserPatchDTO {
           private Optional<String> name = Optional.empty();
           private Optional<String> email = Optional.empty();
       }
       ```
    2. **Validation groups**:
       ```java
       public class UserDTO {
           @NotNull(groups = CreateGroup.class)
           private String name;
           @NotNull(groups = CreateGroup.class)
           private String email;
       }
       @PatchMapping("/users")
       public void update(@Validated(UpdateGroup.class) @RequestBody UserDTO userDTO) { ... }
       ```
    3. **Custom validator**:
        - Validate chỉ field được gửi trong JSON.

---

### 9. Định dạng ngày/giờ trong binding: `@DateTimeFormat` vs `@JsonFormat` — phạm vi tác dụng khác nhau như thế nào?
- **`@DateTimeFormat`**:
    - Dùng cho form/query params (`@ModelAttribute`, `@RequestParam`).
    - Định dạng `String` → `LocalDate`/`LocalDateTime`.
    - Ví dụ:
      ```java
      @GetMapping("/events")
      public List<Event> getEvents(@RequestParam @DateTimeFormat(iso = ISO.DATE) LocalDate date) { ... }
      ```
- **`@JsonFormat`**:
    - Dùng cho JSON (`@RequestBody`, `@ResponseBody`).
    - Định dạng khi serialize/deserialize với Jackson.
    - Ví dụ:
      ```java
      public class EventDTO {
          @JsonFormat(pattern = "yyyy-MM-dd")
          private LocalDate date;
      }
      ```

---

### 10. Bind **enum** từ request (string/int): conversion & lỗi thường gặp.
- **Conversion**:
    - **String**: Spring tự map `String` → `Enum` dựa trên name:
      ```java
      public enum Role { ADMIN, USER }
      @GetMapping("/users")
      public List<User> getUsers(@RequestParam Role role) { ... } // ?role=ADMIN
      ```
    - **Int**: Dùng custom converter:
      ```java
      @Bean
      public Converter<String, Role> roleConverter() {
          return new Converter<String, Role>() {
              @Override
              public Role convert(String source) {
                  return Role.values()[Integer.parseInt(source)];
              }
          };
      }
      ```
- **Lỗi thường gặp**:
    - `IllegalArgumentException`: Giá trị không khớp với enum.
    - **Giải pháp**: Dùng `@RequestParam(defaultValue = "USER")` hoặc xử lý lỗi.

---

### 11. Thiết kế **error response** thống nhất cho toàn API khi validation fail: cần chứa những trường nào?
- **Trường cần**:
    - `status`: HTTP status code (như 400).
    - `error`: Mã lỗi nội bộ (như `VALIDATION_ERROR`).
    - `message`: Thông điệp người dùng hiểu (như “Invalid input”).
    - `details`: Chi tiết lỗi (như danh sách field lỗi).
- **Ví dụ**:
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
          ErrorResponse error = new ErrorResponse();
          error.setStatus(HttpStatus.BAD_REQUEST.value());
          error.setError("VALIDATION_ERROR");
          error.setMessage("Invalid input");
          error.setDetails(ex.getBindingResult().getFieldErrors().stream()
              .map(e -> e.getField() + ": " + e.getDefaultMessage())
              .collect(Collectors.toList()));
          return ResponseEntity.badRequest().body(error);
      }
  }
  public class ErrorResponse {
      private int status;
      private String error;
      private String message;
      private List<String> details;
      // Getters/Setters
  }
  ```

---

### 12. Tránh **over-posting**/**mass assignment**: kỹ thuật và vị trí phòng vệ (DTO, whitelist fields, binder, service).
- **Kỹ thuật**:
    1. **Dùng DTO**:
        - Chỉ expose field cần thiết:
          ```java
          public class UserDTO {
              private String name;
              private String email; // Không có password
          }
          ```
    2. **Whitelist fields**:
        - Dùng `@InitBinder` để giới hạn:
          ```java
          @InitBinder
          public void initBinder(WebDataBinder binder) {
              binder.setAllowedFields("name", "email");
          }
          ```
    3. **Service layer**:
        - Kiểm tra và map dữ liệu cẩn thận.
- **Vị trí phòng vệ**:
    - **DTO**: Tầng MVC, ngăn dữ liệu không mong muốn từ request.
    - **Binder**: Tầng controller, giới hạn field được bind.
    - **Service**: Tầng logic, kiểm tra dữ liệu trước khi lưu.

---

# 8) Xử lý lỗi & tư vấn toàn cục (Exception Handling)

### 1. `@ExceptionHandler` ở controller vs `@ControllerAdvice`/`@RestControllerAdvice` toàn cục: phạm vi, ưu tiên.
- **`@ExceptionHandler` trong controller**:
    - Phạm vi: Chỉ áp dụng cho controller chứa nó.
    - Ưu tiên: Cao hơn `@ControllerAdvice` nếu cùng exception.
- **`@ControllerAdvice`/`@RestControllerAdvice`**:
    - Phạm vi: Toàn cục, áp dụng cho tất cả controllers.
    - Ưu tiên: Thấp hơn `@ExceptionHandler` cục bộ.
- **Ví dụ**:
  ```java
  @Controller
  public class UserController {
      @ExceptionHandler(ValidationException.class)
      public String handleValidation() { ... } // Cục bộ
  }
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(ValidationException.class)
      public ResponseEntity<?> handleValidation() { ... } // Toàn cục
  }
  ```

---

### 2. ⚠️ Gài: Khi có **nhiều** handler bắt cùng exception, Spring chọn cái nào? `@Order` hoạt động ra sao?
- **Cách chọn**:
    - **Trong controller**: `@ExceptionHandler` cục bộ ưu tiên cao nhất.
    - **Nhiều `@ControllerAdvice`**: Spring chọn theo `@Order` (thấp hơn chạy trước) hoặc `Ordered` interface.
- **Ví dụ**:
  ```java
  @ControllerAdvice
  @Order(1)
  public class Advice1 {
      @ExceptionHandler(Exception.class)
      public ResponseEntity<?> handle() { ... }
  }
  @ControllerAdvice
  @Order(2)
  public class Advice2 {
      @ExceptionHandler(Exception.class)
      public ResponseEntity<?> handle() { ... }
  }
  ```
    - `Advice1` được gọi trước do `@Order(1)`.

---

### 3. `ResponseStatusException` vs `@ResponseStatus` vs trả `ResponseEntity` — chọn cái nào cho tính rõ ràng & testability?
- **`ResponseStatusException`**:
    - Ném exception với HTTP status và message:
      ```java
      throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found");
      ```
    - Rõ ràng, dễ test, nhưng không trả body phức tạp.
- **`@ResponseStatus`**:
    - Annotate trên exception class:
      ```java
      @ResponseStatus(HttpStatus.NOT_FOUND)
      public class UserNotFoundException extends RuntimeException {}
      ```
    - Rõ ràng, nhưng không linh hoạt (status cố định).
- **`ResponseEntity`**:
    - Trả response với status, headers, body:
      ```java
      return ResponseEntity.status(HttpStatus.NOT_FOUND).body("User not found");
      ```
    - Linh hoạt nhất, dễ test với body phức tạp.
- **Lựa chọn**:
    - `ResponseStatusException`: Dùng cho lỗi đơn giản, dễ throw.
    - `ResponseEntity`: Dùng khi cần response chi tiết.
    - `@ResponseStatus`: Dùng cho exception tái sử dụng.

---

### 4. Chuẩn lỗi REST: map lỗi chuẩn Spring (ví dụ `MethodArgumentNotValidException`) sang JSON domain-specific như thế nào?
- **Cách map**:
    - Dùng `@RestControllerAdvice` để catch `MethodArgumentNotValidException`:
      ```java
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ExceptionHandler(MethodArgumentNotValidException.class)
          public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
              ErrorResponse error = new ErrorResponse();
              error.setStatus(HttpStatus.BAD_REQUEST.value());
              error.setError("VALIDATION_ERROR");
              error.setMessage("Invalid input");
              error.setDetails(ex.getBindingResult().getFieldErrors().stream()
                  .map(e -> e.getField() + ": " + e.getDefaultMessage())
                  .collect(Collectors.toList()));
              return ResponseEntity.badRequest().body(error);
          }
      }
      ```
- **JSON output**:
  ```json
  {
      "status": 400,
      "error": "VALIDATION_ERROR",
      "message": "Invalid input",
      "details": ["name: must not be blank"]
  }
  ```

---

### 5. Log lỗi ở đâu để không trùng lặp (controller, advice, filter)? Mức log nào phù hợp (INFO/WARN/ERROR)?
- **Nơi log**:
    - **ControllerAdvice**: Tốt nhất cho lỗi toàn cục, tránh trùng lặp:
      ```java
      @RestControllerAdvice
      public class GlobalExceptionHandler {
          @ExceptionHandler(Exception.class)
          public ResponseEntity<?> handle(Exception ex) {
              log.error("Unexpected error", ex);
              return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error");
          }
      }
      ```
    - **Filter**: Log lỗi không đến được controller (như CORS, authentication).
    - **Controller**: Chỉ log lỗi cục bộ nếu cần.
- **Mức log**:
    - **ERROR**: Lỗi nghiêm trọng (như `SQLException`).
    - **WARN**: Lỗi client (như validation fail).
    - **INFO**: Thông tin request/response (không lạm dụng).

---

# 9) Bảo mật & các chủ đề cận kề MVC (nhẹ)

### 1. Ảnh hưởng của **CSRF** tới form POST trong MVC truyền thống; cách bật/tắt hợp lý khi chỉ có REST API.
- **Ảnh hưởng CSRF**:
    - CSRF tấn công giả mạo request POST từ site khác.
    - Spring Security bật CSRF mặc định, yêu cầu token trong form POST.
- **Bật/tắt**:
    - **Bật**: Dùng `<input type="hidden" name="_csrf" th:value="${_csrf.token}"/>` trong Thymeleaf.
    - **Tắt** (cho REST API):
      ```java
      @Configuration
      public class SecurityConfig extends WebSecurityConfigurerAdapter {
          @Override
          protected void configure(HttpSecurity http) throws Exception {
              http.csrf().disable();
          }
      }
      ```
    - Tắt hợp lý khi API dùng token-based authentication (như JWT).

---

### 2. Thêm **rate limit**/**throttling** ở tầng MVC (interceptor/filter) — câu hỏi thiết kế.
- **Thiết kế**:
    - Dùng **Interceptor** để kiểm soát rate limit:
      ```java
      public class RateLimitInterceptor implements HandlerInterceptor {
          private final RateLimiter limiter = RateLimiter.create(10.0); // 10 requests/s
          @Override
          public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
              if (!limiter.tryAcquire()) {
                  response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
                  return false;
              }
              return true;
          }
      }
      ```
    - **Cấu hình**:
      ```java
      @Bean
      public WebMvcConfigurer rateLimitConfigurer() {
          return new WebMvcConfigurer() {
              @Override
              public void addInterceptors(InterceptorRegistry registry) {
                  registry.addInterceptor(new RateLimitInterceptor());
              }
          };
      }
      ```
- **Use-case**: Giới hạn API calls theo user hoặc IP.

---

### 3. ⚠️ Gài: Truyền trực tiếp entity JPA qua JSON có nguy cơ gì (lazy loading, N+1, dữ liệu nhạy cảm)?
- **Nguy cơ**:
    - **Lazy loading**: Gây `LazyInitializationException` nếu truy cập quan hệ ngoài session.
    - **N+1**: Fetch quan hệ lặp lại, làm chậm response.
    - **Dữ liệu nhạy cảm**: Lộ field như `password`.
- **Giải pháp**:
    - Dùng DTO để map Entity, loại bỏ quan hệ và field nhạy cảm.
    - Dùng `@JsonIgnore` hoặc `@JsonManagedReference` cho quan hệ.
    - Cấu hình `OpenSessionInView=false` để tránh lazy loading.

---

# 10) Mini case thực chiến (luyện nói 2–5 phút mỗi case)

### 1. Thiết kế endpoint **tạo user** (POST) với validation groups (Create vs Update). Trả 201 + Location. Trình bày mapping & error format.
- **Thiết kế**:
  ```java
  public interface CreateGroup {}
  public interface UpdateGroup {}
  public class UserDTO {
      @NotNull(groups = CreateGroup.class)
      private String name;
      @NotNull(groups = {CreateGroup.class, UpdateGroup.class})
      private String email;
      @NotNull(groups = UpdateGroup.class)
      private Long id;
  }
  @RestController
  @Validated
  public class UserController {
      @PostMapping("/users")
      public ResponseEntity<UserDTO> create(@Validated(CreateGroup.class) @RequestBody UserDTO userDTO) {
          UserDTO saved = userService.save(userDTO);
          URI location = ServletUriComponentsBuilder.fromCurrentRequest()
              .path("/{id}")
              .buildAndExpand(saved.getId())
              .toUri();
          return ResponseEntity.created(location).body(saved);
      }
  }
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
          ErrorResponse error = new ErrorResponse();
          error.setStatus(HttpStatus.BAD_REQUEST.value());
          error.setError("VALIDATION_ERROR");
          error.setMessage("Invalid input");
          error.setDetails(ex.getBindingResult().getFieldErrors().stream()
              .map(e -> e.getField() + ": " + e.getDefaultMessage())
              .collect(Collectors.toList()));
          return ResponseEntity.badRequest().body(error);
      }
  }
  ```
- **Error format**:
  ```json
  {
      "status": 400,
      "error": "VALIDATION_ERROR",
      "message": "Invalid input",
      "details": ["name: must not be null"]
  }
  ```

---

### 2. API **search** với `@RequestParam` nhiều tiêu chí + phân trang `Pageable`. Cách validate tham số & trả metadata trang.
- **Thiết kế**:
  ```java
  @RestController
  @Validated
  public class UserController {
      @GetMapping("/users")
      public PageDTO<UserDTO> search(
          @RequestParam @NotBlank String name,
          @RequestParam(defaultValue = "USER") Role role,
          Pageable pageable) {
          Page<User> page = userService.search(name, role, pageable);
          return new PageDTO<>(page.map(UserDTO::fromEntity));
      }
  }
  public class PageDTO<T> {
      private List<T> content;
      private int page;
      private int size;
      private long totalElements;
      // Constructor, Getters/Setters
  }
  ```
- **Validation**:
    - Dùng `@NotBlank` để validate `name`.
    - Dùng `defaultValue` cho `role`.
- **Metadata**:
    - Trả `content`, `page`, `size`, `totalElements` để client biết trạng thái trang.

---
